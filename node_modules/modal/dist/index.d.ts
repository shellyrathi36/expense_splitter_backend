import { BinaryWriter, BinaryReader } from '@bufbuild/protobuf/wire';

declare enum GPUType {
    /**
     * GPU_TYPE_UNSPECIFIED - Note: this enum is no longer used by current clients - don't add new types
     * Old clients still send it, so we use it server-side for compatibility
     */
    GPU_TYPE_UNSPECIFIED = 0,
    GPU_TYPE_T4 = 1,
    GPU_TYPE_A100 = 2,
    GPU_TYPE_A10G = 3,
    GPU_TYPE_ANY = 4,
    GPU_TYPE_A100_80GB = 8,
    GPU_TYPE_L4 = 9,
    GPU_TYPE_H100 = 10,
    GPU_TYPE_L40S = 11,
    GPU_TYPE_H200 = 12,
    UNRECOGNIZED = -1
}
declare enum ParameterType {
    PARAM_TYPE_UNSPECIFIED = 0,
    PARAM_TYPE_STRING = 1,
    PARAM_TYPE_INT = 2,
    /** PARAM_TYPE_PICKLE - currently unused */
    PARAM_TYPE_PICKLE = 3,
    PARAM_TYPE_BYTES = 4,
    /** PARAM_TYPE_UNKNOWN - used in schemas to signify unrecognized or un-annotated types */
    PARAM_TYPE_UNKNOWN = 5,
    PARAM_TYPE_LIST = 6,
    PARAM_TYPE_DICT = 7,
    PARAM_TYPE_NONE = 8,
    PARAM_TYPE_BOOL = 9,
    UNRECOGNIZED = -1
}
declare enum RegistryAuthType {
    /** REGISTRY_AUTH_TYPE_UNSPECIFIED - Older clients send this instead of "public". */
    REGISTRY_AUTH_TYPE_UNSPECIFIED = 0,
    REGISTRY_AUTH_TYPE_AWS = 1,
    REGISTRY_AUTH_TYPE_GCP = 2,
    REGISTRY_AUTH_TYPE_PUBLIC = 3,
    REGISTRY_AUTH_TYPE_STATIC_CREDS = 4,
    UNRECOGNIZED = -1
}
/** TODO: rename into NamedPayloadType or similar */
interface ClassParameterSpec {
    name: string;
    /** TODO: deprecate - use full_type instead */
    type: ParameterType;
    hasDefault: boolean;
    /** Default *values* are only registered for class parameters */
    stringDefault?: string | undefined;
    intDefault?: number | undefined;
    pickleDefault?: Uint8Array | undefined;
    bytesDefault?: Uint8Array | undefined;
    boolDefault?: boolean | undefined;
    /** supersedes `type` */
    fullType: GenericPayloadType | undefined;
}
declare const ClassParameterSpec: MessageFns<ClassParameterSpec>;
interface GPUConfig {
    /** Deprecated, at some point */
    type: GPUType;
    count: number;
    gpuType: string;
}
declare const GPUConfig: MessageFns<GPUConfig>;
interface GenericPayloadType {
    baseType: ParameterType;
    /** sub-type for generic types like lists */
    subTypes: GenericPayloadType[];
}
declare const GenericPayloadType: MessageFns<GenericPayloadType>;
interface ImageRegistryConfig {
    registryAuthType: RegistryAuthType;
    secretId: string;
}
declare const ImageRegistryConfig: MessageFns<ImageRegistryConfig>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create(base?: DeepPartial<T>): T;
    fromPartial(object: DeepPartial<T>): T;
}

/** Options for `Secret.fromName()`. */
type SecretFromNameOptions = {
    environment?: string;
    requiredKeys?: string[];
};
/** Secrets provide a dictionary of environment variables for Images. */
declare class Secret {
    readonly secretId: string;
    readonly name?: string;
    /** @ignore */
    constructor(secretId: string, name?: string);
    /** Reference a Secret by its name. */
    static fromName(name: string, options?: SecretFromNameOptions): Promise<Secret>;
    /** Create a Secret from a plain object of key-value pairs. */
    static fromObject(entries: Record<string, string>, options?: {
        environment?: string;
    }): Promise<Secret>;
}

/** Options for deleting an Image. */
type ImageDeleteOptions = Record<never, never>;
/** Options for Image.dockerfileCommands(). */
type ImageDockerfileCommandsOptions = {
    /** Environment variables to set in the build environment. */
    env?: Record<string, string>;
    /** Secrets that will be made available as environment variables to this layer's build environment. */
    secrets?: Secret[];
    /** GPU reservation for this layer's build environment (e.g. "A100", "T4:2", "A100-80GB:4"). */
    gpu?: string;
    /** Ignore cached builds for this layer, similar to 'docker build --no-cache'. */
    forceBuild?: boolean;
};
/** Represents a single image layer with its build configuration. */
type Layer = {
    commands: string[];
    env?: Record<string, string>;
    secrets?: Secret[];
    gpuConfig?: GPUConfig;
    forceBuild?: boolean;
};
/** A container image, used for starting Sandboxes. */
declare class Image {
    #private;
    /** @ignore */
    constructor(imageId: string, tag: string, imageRegistryConfig?: ImageRegistryConfig, layers?: Layer[]);
    get imageId(): string;
    /**
     * Creates an Image from an Image ID
     *
     * @param imageId - Image ID.
     */
    static fromId(imageId: string): Promise<Image>;
    /**
     * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
     *
     * @param tag - The registry tag for the Image.
     * @param secret - Optional. A Secret containing credentials for registry authentication.
     */
    static fromRegistry(tag: string, secret?: Secret): Image;
    /**
     * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
     *
     * @param tag - The registry tag for the Image.
     * @param secret - A Secret containing credentials for registry authentication.
     */
    static fromAwsEcr(tag: string, secret: Secret): Image;
    /**
     * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
     *
     * @param tag - The registry tag for the Image.
     * @param secret - A Secret containing credentials for registry authentication.
     */
    static fromGcpArtifactRegistry(tag: string, secret: Secret): Image;
    private static validateDockerfileCommands;
    /**
     * Extend an image with arbitrary Dockerfile-like commands.
     *
     * Each call creates a new Image layer that will be built sequentially.
     * The provided options apply only to this layer.
     *
     * @param commands - Array of Dockerfile commands as strings
     * @param options - Optional configuration for this layer's build
     * @returns A new Image instance
     */
    dockerfileCommands(commands: string[], options?: ImageDockerfileCommandsOptions): Image;
    /**
     * Eagerly builds an Image on Modal.
     *
     * @param app - App to use to build the Image.
     */
    build(app: App): Promise<Image>;
    /** Delete an Image by ID. Warning: This removes an *entire Image*, and cannot be undone. */
    static delete(imageId: string, _?: ImageDeleteOptions): Promise<void>;
}

/** File open modes supported by the filesystem API. */
type SandboxFileMode = "r" | "w" | "a" | "r+" | "w+" | "a+";
/**
 * SandboxFile represents an open file in the Sandbox filesystem.
 * Provides read/write operations similar to Node.js `fsPromises.FileHandle`.
 */
declare class SandboxFile {
    #private;
    /** @ignore */
    constructor(fileDescriptor: string, taskId: string);
    /**
     * Read data from the file.
     * @returns Promise that resolves to the read data as Uint8Array
     */
    read(): Promise<Uint8Array>;
    /**
     * Write data to the file.
     * @param data - Data to write (string or Uint8Array)
     */
    write(data: Uint8Array): Promise<void>;
    /**
     * Flush any buffered data to the file.
     */
    flush(): Promise<void>;
    /**
     * Close the file handle.
     */
    close(): Promise<void>;
}

/**
 * Wrapper around `ReadableStream` with convenience functions.
 *
 * The Stream API is a modern standard for asynchronous data streams across
 * network and process boundaries. It allows you to read data in chunks, pipe
 * and transform it, and handle backpressure.
 *
 * This wrapper adds some extra functions like `.readText()` to read the entire
 * stream as a string, or `readBytes()` to read binary data.
 *
 * Background: https://developer.mozilla.org/en-US/docs/Web/API/Streams_API
 */
interface ModalReadStream<R = any> extends ReadableStream<R> {
    /** Read the entire stream as a string. */
    readText(): Promise<string>;
    /** Read the entire stream as a byte array. */
    readBytes(): Promise<Uint8Array>;
}
/**
 * Wrapper around `WritableStream` with convenience functions.
 *
 * The Stream API is a modern standard for asynchronous data streams across
 * network and process boundaries. It allows you to read data in chunks, pipe
 * and transform it, and handle backpressure.
 *
 * This wrapper adds some extra functions like `.writeText()` to write a string
 * to the stream, or `writeBytes()` to write binary data.
 *
 * Background: https://developer.mozilla.org/en-US/docs/Web/API/Streams_API
 */
interface ModalWriteStream<R = any> extends WritableStream<R> {
    /** Write a string to the stream. Only if this is a text stream. */
    writeText(text: string): Promise<void>;
    /** Write a byte array to the stream. Only if this is a byte stream. */
    writeBytes(bytes: Uint8Array): Promise<void>;
}

/**
 * Stdin is always present, but this option allow you to drop stdout or stderr
 * if you don't need them. The default is "pipe", matching Node.js behavior.
 *
 * If behavior is set to "ignore", the output streams will be empty.
 */
type StdioBehavior = "pipe" | "ignore";
/**
 * Specifies the type of data that will be read from the Sandbox or container
 * process. "text" means the data will be read as UTF-8 text, while "binary"
 * means the data will be read as raw bytes (Uint8Array).
 */
type StreamMode = "text" | "binary";
/** Options for `Sandbox.list()`. */
type SandboxListOptions = {
    /** Filter Sandboxes for a specific App. */
    appId?: string;
    /** Only return Sandboxes that include all specified tags. */
    tags?: Record<string, string>;
    /** Override environment for the request; defaults to current profile. */
    environment?: string;
};
/** Options to configure a `Sandbox.exec()` operation. */
type ExecOptions = {
    /** Specifies text or binary encoding for input and output streams. */
    mode?: StreamMode;
    /** Whether to pipe or ignore standard output. */
    stdout?: StdioBehavior;
    /** Whether to pipe or ignore standard error. */
    stderr?: StdioBehavior;
    /** Working directory to run the command in. */
    workdir?: string;
    /** Timeout for the process in milliseconds. Defaults to 0 (no timeout). */
    timeout?: number;
    /** Environment variables to set for the command. */
    env?: Record<string, string>;
    /** Secrets to inject as environment variables for the commmand.*/
    secrets?: Secret[];
    /** Enable a PTY for the command. */
    pty?: boolean;
};
/** A port forwarded from within a running Modal Sandbox. */
declare class Tunnel {
    host: string;
    port: number;
    unencryptedHost?: string | undefined;
    unencryptedPort?: number | undefined;
    /** @ignore */
    constructor(host: string, port: number, unencryptedHost?: string | undefined, unencryptedPort?: number | undefined);
    /** Get the public HTTPS URL of the forwarded port. */
    get url(): string;
    /** Get the public TLS socket as a [host, port] tuple. */
    get tlsSocket(): [string, number];
    /** Get the public TCP socket as a [host, port] tuple. */
    get tcpSocket(): [string, number];
}
/** Sandboxes are secure, isolated containers in Modal that boot in seconds. */
declare class Sandbox {
    #private;
    readonly sandboxId: string;
    stdin: ModalWriteStream<string>;
    stdout: ModalReadStream<string>;
    stderr: ModalReadStream<string>;
    /** @ignore */
    constructor(sandboxId: string);
    /** Set tags (key-value pairs) on the Sandbox. Tags can be used to filter results in `Sandbox.list`. */
    setTags(tags: Record<string, string>): Promise<void>;
    /** Get tags (key-value pairs) currently attached to this Sandbox from the server. */
    getTags(): Promise<Record<string, string>>;
    /** Returns a running Sandbox object from an ID.
     *
     * @returns Sandbox with ID
     */
    static fromId(sandboxId: string): Promise<Sandbox>;
    /** Get a running Sandbox by name from a deployed App.
     *
     * Raises a NotFoundError if no running Sandbox is found with the given name.
     * A Sandbox's name is the `name` argument passed to `App.createSandbox`.
     *
     * @param appName - Name of the deployed App
     * @param name - Name of the Sandbox
     * @param environment - Optional override for the environment
     * @returns Promise that resolves to a Sandbox
     */
    static fromName(appName: string, name: string, environment?: string): Promise<Sandbox>;
    /**
     * Open a file in the Sandbox filesystem.
     * @param path - Path to the file to open
     * @param mode - File open mode (r, w, a, r+, w+, a+)
     * @returns Promise that resolves to a SandboxFile
     */
    open(path: string, mode?: SandboxFileMode): Promise<SandboxFile>;
    exec(command: string[], options?: ExecOptions & {
        mode?: "text";
    }): Promise<ContainerProcess<string>>;
    exec(command: string[], options: ExecOptions & {
        mode: "binary";
    }): Promise<ContainerProcess<Uint8Array>>;
    terminate(): Promise<void>;
    wait(): Promise<number>;
    /** Get Tunnel metadata for the Sandbox.
     *
     * Raises `SandboxTimeoutError` if the tunnels are not available after the timeout.
     *
     * @returns A dictionary of Tunnel objects which are keyed by the container port.
     */
    tunnels(timeout?: number): Promise<Record<number, Tunnel>>;
    /**
     * Snapshot the filesystem of the Sandbox.
     *
     * Returns an `Image` object which can be used to spawn a new Sandbox with the same filesystem.
     *
     * @param timeout - Timeout for the snapshot operation in milliseconds
     * @returns Promise that resolves to an Image
     */
    snapshotFilesystem(timeout?: number): Promise<Image>;
    /**
     * Check if the Sandbox has finished running.
     *
     * Returns `null` if the Sandbox is still running, else returns the exit code.
     */
    poll(): Promise<number | null>;
    /**
     * List all Sandboxes for the current Environment or App ID (if specified).
     * If tags are specified, only Sandboxes that have at least those tags are returned.
     */
    static list(options?: SandboxListOptions): AsyncGenerator<Sandbox, void, unknown>;
}
declare class ContainerProcess<R extends string | Uint8Array = any> {
    #private;
    stdin: ModalWriteStream<R>;
    stdout: ModalReadStream<R>;
    stderr: ModalReadStream<R>;
    returncode: number | null;
    constructor(execId: string, options?: ExecOptions);
    /** Wait for process completion and return the exit code. */
    wait(): Promise<number>;
}

type HeartbeatFunction = () => Promise<any>;
declare class EphemeralHeartbeatManager {
    private readonly heartbeatFn;
    private readonly abortController;
    constructor(heartbeatFn: HeartbeatFunction);
    private start;
    stop(): void;
}

/** Options for `Volume.fromName()`. */
type VolumeFromNameOptions = {
    environment?: string;
    createIfMissing?: boolean;
};
/** Volumes provide persistent storage that can be mounted in Modal Functions. */
declare class Volume {
    #private;
    readonly volumeId: string;
    readonly name?: string;
    private _readOnly;
    /** @ignore */
    constructor(volumeId: string, name?: string, readOnly?: boolean, ephemeralHbManager?: EphemeralHeartbeatManager);
    static fromName(name: string, options?: VolumeFromNameOptions): Promise<Volume>;
    /** Configure Volume to mount as read-only. */
    readOnly(): Volume;
    get isReadOnly(): boolean;
    /**
     * Create a nameless, temporary Volume.
     * You will need to call `closeEphemeral()` to delete the Volume.
     */
    static ephemeral(options?: EphemeralOptions): Promise<Volume>;
    /** Delete the ephemeral Volume. Only usable with `Volume.ephemeral()`. */
    closeEphemeral(): void;
}

/** Options for `Proxy.fromName()`. */
type ProxyFromNameOptions = {
    environment?: string;
};
/** Proxy objects give your Modal containers a static outbound IP address. */
declare class Proxy {
    readonly proxyId: string;
    /** @ignore */
    constructor(proxyId: string);
    /** Reference a Proxy by its name. */
    static fromName(name: string, options?: ProxyFromNameOptions): Promise<Proxy>;
}

/** Cloud Bucket Mounts provide access to cloud storage buckets within Modal Functions. */
declare class CloudBucketMount {
    readonly bucketName: string;
    readonly secret?: Secret;
    readonly readOnly: boolean;
    readonly requesterPays: boolean;
    readonly bucketEndpointUrl?: string;
    readonly keyPrefix?: string;
    readonly oidcAuthRoleArn?: string;
    constructor(bucketName: string, options?: {
        secret?: Secret;
        readOnly?: boolean;
        requesterPays?: boolean;
        bucketEndpointUrl?: string;
        keyPrefix?: string;
        oidcAuthRoleArn?: string;
    });
}

/** Options for functions that find deployed Modal objects. */
type LookupOptions = {
    environment?: string;
    createIfMissing?: boolean;
};
/** Options for deleting a named object. */
type DeleteOptions = {
    environment?: string;
};
/** Options for constructors that create a temporary, nameless object. */
type EphemeralOptions = {
    environment?: string;
};
/** Options for `App.createSandbox()`. */
type SandboxCreateOptions = {
    /** Reservation of physical CPU cores for the Sandbox, can be fractional. */
    cpu?: number;
    /** Reservation of memory in MiB. */
    memory?: number;
    /** GPU reservation for the Sandbox (e.g. "A100", "T4:2", "A100-80GB:4"). */
    gpu?: string;
    /** Timeout of the Sandbox container, defaults to 10 minutes. */
    timeout?: number;
    /** The amount of time in milliseconds that a sandbox can be idle before being terminated. */
    idleTimeout?: number;
    /** Working directory of the Sandbox. */
    workdir?: string;
    /**
     * Sequence of program arguments for the main process.
     * Default behavior is to sleep indefinitely until timeout or termination.
     */
    command?: string[];
    /** Environment variables to set in the Sandbox. */
    env?: Record<string, string>;
    /** Secrets to inject into the Sandbox as environment variables. */
    secrets?: Secret[];
    /** Mount points for Modal Volumes. */
    volumes?: Record<string, Volume>;
    /** Mount points for cloud buckets. */
    cloudBucketMounts?: Record<string, CloudBucketMount>;
    /** Enable a PTY for the Sandbox. */
    pty?: boolean;
    /** List of ports to tunnel into the Sandbox. Encrypted ports are tunneled with TLS. */
    encryptedPorts?: number[];
    /** List of encrypted ports to tunnel into the Sandbox, using HTTP/2. */
    h2Ports?: number[];
    /** List of ports to tunnel into the Sandbox without encryption. */
    unencryptedPorts?: number[];
    /** Whether to block all network access from the Sandbox. */
    blockNetwork?: boolean;
    /** List of CIDRs the Sandbox is allowed to access. If None, all CIDRs are allowed. Cannot be used with blockNetwork. */
    cidrAllowlist?: string[];
    /** Cloud provider to run the Sandbox on. */
    cloud?: string;
    /** Region(s) to run the Sandbox on. */
    regions?: string[];
    /** Enable verbose logging. */
    verbose?: boolean;
    /** Reference to a Modal Proxy to use in front of this Sandbox. */
    proxy?: Proxy;
    /** Optional name for the Sandbox. Unique within an App. */
    name?: string;
};
/** Represents a deployed Modal App. */
declare class App {
    readonly appId: string;
    readonly name?: string;
    /** @ignore */
    constructor(appId: string, name?: string);
    /** Lookup a deployed App by name, or create if it does not exist. */
    static lookup(name: string, options?: LookupOptions): Promise<App>;
    createSandbox(image: Image, options?: SandboxCreateOptions): Promise<Sandbox>;
    /**
     * @deprecated Use `Image.fromRegistry` instead.
     */
    imageFromRegistry(tag: string, secret?: Secret): Promise<Image>;
    /**
     * @deprecated Use `Image.fromAwsEcr` instead.
     */
    imageFromAwsEcr(tag: string, secret: Secret): Promise<Image>;
    /**
     * @deprecated Use `Image.fromGcpArtifactRegistry` instead.
     */
    imageFromGcpArtifactRegistry(tag: string, secret: Secret): Promise<Image>;
}

/** Options for initializing a client at runtime. */
type ClientOptions = {
    tokenId: string;
    tokenSecret: string;
    environment?: string;
};
/**
 * Initialize the Modal client, passing in token authentication credentials.
 *
 * You should call this function at the start of your application if not
 * configuring Modal with a `.modal.toml` file or environment variables.
 */
declare function initializeClient(options: ClientOptions): void;

/** Options for `FunctionCall.get()`. */
type FunctionCallGetOptions = {
    timeout?: number;
};
/** Options for `FunctionCall.cancel()`. */
type FunctionCallCancelOptions = {
    terminateContainers?: boolean;
};
/**
 * Represents a Modal FunctionCall. Function Calls are Function invocations with
 * a given input. They can be consumed asynchronously (see `get()`) or cancelled
 * (see `cancel()`).
 */
declare class FunctionCall {
    readonly functionCallId: string;
    /** @ignore */
    constructor(functionCallId: string);
    /** Create a new Function call from ID. */
    fromId(functionCallId: string): FunctionCall;
    /** Get the result of a Function call, optionally waiting with a timeout. */
    get(options?: FunctionCallGetOptions): Promise<any>;
    /** Cancel a running Function call. */
    cancel(options?: FunctionCallCancelOptions): Promise<void>;
}

/** Simple data structure storing stats for a running Function. */
interface FunctionStats {
    backlog: number;
    numTotalRunners: number;
}
/** Options for overriding a Function's autoscaler behavior. */
interface UpdateAutoscalerOptions {
    minContainers?: number;
    maxContainers?: number;
    bufferContainers?: number;
    scaledownWindow?: number;
}
/** Represents a deployed Modal Function, which can be invoked remotely. */
declare class Function_ {
    #private;
    readonly functionId: string;
    readonly methodName?: string;
    /** @ignore */
    constructor(functionId: string, methodName?: string, inputPlaneUrl?: string, webUrl?: string);
    static lookup(appName: string, name: string, options?: LookupOptions): Promise<Function_>;
    remote(args?: any[], kwargs?: Record<string, any>): Promise<any>;
    spawn(args?: any[], kwargs?: Record<string, any>): Promise<FunctionCall>;
    getCurrentStats(): Promise<FunctionStats>;
    updateAutoscaler(options: UpdateAutoscalerOptions): Promise<void>;
    /**
     * URL of a Function running as a web endpoint.
     * @returns The web URL if this Function is a web endpoint, otherwise undefined
     */
    getWebUrl(): Promise<string | undefined>;
}

/** Retry policy configuration for a Modal Function/Cls. */
declare class Retries {
    readonly maxRetries: number;
    readonly backoffCoefficient: number;
    readonly initialDelayMs: number;
    readonly maxDelayMs: number;
    constructor(options: {
        maxRetries: number;
        backoffCoefficient?: number;
        initialDelayMs?: number;
        maxDelayMs?: number;
    });
}

type ClsOptions = {
    cpu?: number;
    memory?: number;
    gpu?: string;
    env?: Record<string, string>;
    secrets?: Secret[];
    volumes?: Record<string, Volume>;
    retries?: number | Retries;
    maxContainers?: number;
    bufferContainers?: number;
    scaledownWindow?: number;
    timeout?: number;
};
type ClsConcurrencyOptions = {
    maxInputs: number;
    targetInputs?: number;
};
type ClsBatchingOptions = {
    maxBatchSize: number;
    waitMs: number;
};
type ServiceOptions = ClsOptions & {
    maxConcurrentInputs?: number;
    targetConcurrentInputs?: number;
    batchMaxSize?: number;
    batchWaitMs?: number;
};
/** Represents a deployed Modal Cls. */
declare class Cls {
    #private;
    /** @ignore */
    constructor(serviceFunctionId: string, schema: ClassParameterSpec[], methodNames: string[], inputPlaneUrl?: string, options?: ServiceOptions);
    static lookup(appName: string, name: string, options?: LookupOptions): Promise<Cls>;
    /** Create a new instance of the Cls with parameters and/or runtime options. */
    instance(params?: Record<string, any>): Promise<ClsInstance>;
    /** Override the static Function configuration at runtime. */
    withOptions(options: ClsOptions): Cls;
    /** Create an instance of the Cls with input concurrency enabled or overridden with new values. */
    withConcurrency(options: ClsConcurrencyOptions): Cls;
    /** Create an instance of the Cls with dynamic batching enabled or overridden with new values. */
    withBatching(options: ClsBatchingOptions): Cls;
}
/** Represents an instance of a deployed Modal Cls, optionally with parameters. */
declare class ClsInstance {
    #private;
    constructor(methods: Map<string, Function_>);
    method(name: string): Function_;
}

/** Function execution exceeds the allowed time limit. */
declare class FunctionTimeoutError extends Error {
    constructor(message: string);
}
/** An error on the Modal server, or a Python exception. */
declare class RemoteError extends Error {
    constructor(message: string);
}
/** A retryable internal error from Modal. */
declare class InternalFailure extends Error {
    constructor(message: string);
}
/** Some resource was not found. */
declare class NotFoundError extends Error {
    constructor(message: string);
}
/** A resource already exists. */
declare class AlreadyExistsError extends Error {
    constructor(message: string);
}
/** A request or other operation was invalid. */
declare class InvalidError extends Error {
    constructor(message: string);
}
/** The Queue is empty. */
declare class QueueEmptyError extends Error {
    constructor(message: string);
}
/** The Queue is full. */
declare class QueueFullError extends Error {
    constructor(message: string);
}
/** Sandbox operations that exceed the allowed time limit. */
declare class SandboxTimeoutError extends Error {
    constructor(message?: string);
}

/** Options to configure a `Queue.clear()` operation. */
type QueueClearOptions = {
    /** Partition to clear, uses default partition if not set. */
    partition?: string;
    /** Set to clear all Queue partitions. */
    all?: boolean;
};
/** Options to configure a `Queue.get()` or `Queue.getMany()` operation. */
type QueueGetOptions = {
    /** How long to wait if the Queue is empty (default: indefinite). */
    timeout?: number;
    /** Partition to fetch values from, uses default partition if not set. */
    partition?: string;
};
/** Options to configure a `Queue.put()` or `Queue.putMany()` operation. */
type QueuePutOptions = {
    /** How long to wait if the Queue is full (default: indefinite). */
    timeout?: number;
    /** Partition to add items to, uses default partition if not set. */
    partition?: string;
    /** TTL for the partition in seconds (default: 1 day). */
    partitionTtl?: number;
};
/** Options to configure a `Queue.len()` operation. */
type QueueLenOptions = {
    /** Partition to compute length, uses default partition if not set. */
    partition?: string;
    /** Return the total length across all partitions. */
    total?: boolean;
};
/** Options to configure a `Queue.iterate()` operation. */
type QueueIterateOptions = {
    /** How long to wait between successive items before exiting iteration (default: 0). */
    itemPollTimeout?: number;
    /** Partition to iterate, uses default partition if not set. */
    partition?: string;
};
/**
 * Distributed, FIFO queue for data flow in Modal Apps.
 */
declare class Queue {
    #private;
    readonly queueId: string;
    readonly name?: string;
    /** @ignore */
    constructor(queueId: string, name?: string, ephemeralHbManager?: EphemeralHeartbeatManager);
    /**
     * Create a nameless, temporary Queue.
     * You will need to call `closeEphemeral()` to delete the Queue.
     */
    static ephemeral(options?: EphemeralOptions): Promise<Queue>;
    /** Delete the ephemeral Queue. Only usable with `Queue.ephemeral()`. */
    closeEphemeral(): void;
    /**
     * Lookup a Queue by name.
     */
    static lookup(name: string, options?: LookupOptions): Promise<Queue>;
    /** Delete a Queue by name. */
    static delete(name: string, options?: DeleteOptions): Promise<void>;
    /**
     * Remove all objects from a Queue partition.
     */
    clear(options?: QueueClearOptions): Promise<void>;
    /**
     * Remove and return the next object from the Queue.
     *
     * By default, this will wait until at least one item is present in the Queue.
     * If `timeout` is set, raises `QueueEmptyError` if no items are available
     * within that timeout in milliseconds.
     */
    get(options?: QueueGetOptions): Promise<any | null>;
    /**
     * Remove and return up to `n` objects from the Queue.
     *
     * By default, this will wait until at least one item is present in the Queue.
     * If `timeout` is set, raises `QueueEmptyError` if no items are available
     * within that timeout in milliseconds.
     */
    getMany(n: number, options?: QueueGetOptions): Promise<any[]>;
    /**
     * Add an item to the end of the Queue.
     *
     * If the Queue is full, this will retry with exponential backoff until the
     * provided `timeout` is reached, or indefinitely if `timeout` is not set.
     * Raises `QueueFullError` if the Queue is still full after the timeout.
     */
    put(v: any, options?: QueuePutOptions): Promise<void>;
    /**
     * Add several items to the end of the Queue.
     *
     * If the Queue is full, this will retry with exponential backoff until the
     * provided `timeout` is reached, or indefinitely if `timeout` is not set.
     * Raises `QueueFullError` if the Queue is still full after the timeout.
     */
    putMany(values: any[], options?: QueuePutOptions): Promise<void>;
    /** Return the number of objects in the Queue. */
    len(options?: QueueLenOptions): Promise<number>;
    /** Iterate through items in a Queue without mutation. */
    iterate(options?: QueueIterateOptions): AsyncGenerator<any, void, unknown>;
}

export { AlreadyExistsError, App, type ClientOptions, CloudBucketMount, Cls, type ClsBatchingOptions, type ClsConcurrencyOptions, ClsInstance, type ClsOptions, ContainerProcess, type DeleteOptions, type EphemeralOptions, type ExecOptions, FunctionCall, type FunctionCallCancelOptions, type FunctionCallGetOptions, type FunctionStats, FunctionTimeoutError, Function_, Image, type ImageDeleteOptions, type ImageDockerfileCommandsOptions, InternalFailure, InvalidError, type LookupOptions, type ModalReadStream, type ModalWriteStream, NotFoundError, Proxy, type ProxyFromNameOptions, Queue, type QueueClearOptions, QueueEmptyError, QueueFullError, type QueueGetOptions, type QueueIterateOptions, type QueueLenOptions, type QueuePutOptions, RemoteError, Retries, Sandbox, type SandboxCreateOptions, SandboxFile, type SandboxFileMode, type SandboxListOptions, SandboxTimeoutError, Secret, type SecretFromNameOptions, type StdioBehavior, type StreamMode, Tunnel, type UpdateAutoscalerOptions, Volume, type VolumeFromNameOptions, initializeClient };

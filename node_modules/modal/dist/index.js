// src/app.ts
import { ClientError as ClientError5, Status as Status5 } from "nice-grpc";

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt64 = /* @__PURE__ */ makeInt64Support();
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
  if (globalThis[symbol] == void 0) {
    const te = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (e) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
var BinaryWriter = class {
  constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      // eslint-disable-next-line
      // @ts-expect-error TS7029: Fallthrough case in switch
      case WireType.Bit64:
        this.pos += 4;
      // eslint-disable-next-line no-fallthrough
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
};
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}

// proto/google/protobuf/empty.ts
function createBaseEmpty() {
  return {};
}
var Empty = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseEmpty();
    return message;
  }
};

// proto/google/protobuf/struct.ts
function nullValueFromJSON(object) {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return 0 /* NULL_VALUE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function nullValueToJSON(object) {
  switch (object) {
    case 0 /* NULL_VALUE */:
      return "NULL_VALUE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseStruct() {
  return { fields: {} };
}
var Struct = {
  encode(message, writer = new BinaryWriter()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        Struct_FieldsEntry.encode({ key, value }, writer.uint32(10).fork()).join();
      }
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fields: isObject(object.fields) ? Object.entries(object.fields).reduce((acc, [key, value]) => {
        acc[key] = value;
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return Struct.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStruct();
    message.fields = Object.entries(object.fields ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    return message;
  },
  wrap(object) {
    const struct = createBaseStruct();
    if (object !== void 0) {
      for (const key of Object.keys(object)) {
        struct.fields[key] = object[key];
      }
    }
    return struct;
  },
  unwrap(message) {
    const object = {};
    if (message.fields) {
      for (const key of Object.keys(message.fields)) {
        object[key] = message.fields[key];
      }
    }
    return object;
  }
};
function createBaseStruct_FieldsEntry() {
  return { key: "", value: void 0 };
}
var Struct_FieldsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Struct_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStruct_FieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseValue() {
  return {
    nullValue: void 0,
    numberValue: void 0,
    stringValue: void 0,
    boolValue: void 0,
    structValue: void 0,
    listValue: void 0
  };
}
var Value = {
  encode(message, writer = new BinaryWriter()) {
    if (message.nullValue !== void 0) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).join();
    }
    if (message.listValue !== void 0) {
      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.nullValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.numberValue = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : void 0,
      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : void 0,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : void 0,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : void 0,
      structValue: isObject(object.structValue) ? object.structValue : void 0,
      listValue: globalThis.Array.isArray(object.listValue) ? [...object.listValue] : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.nullValue !== void 0) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      obj.numberValue = message.numberValue;
    }
    if (message.stringValue !== void 0) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== void 0) {
      obj.boolValue = message.boolValue;
    }
    if (message.structValue !== void 0) {
      obj.structValue = message.structValue;
    }
    if (message.listValue !== void 0) {
      obj.listValue = message.listValue;
    }
    return obj;
  },
  create(base) {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseValue();
    message.nullValue = object.nullValue ?? void 0;
    message.numberValue = object.numberValue ?? void 0;
    message.stringValue = object.stringValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    message.structValue = object.structValue ?? void 0;
    message.listValue = object.listValue ?? void 0;
    return message;
  },
  wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = 0 /* NULL_VALUE */;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (globalThis.Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new globalThis.Error("Unsupported any value type: " + typeof value);
    }
    return result;
  },
  unwrap(message) {
    if (message.stringValue !== void 0) {
      return message.stringValue;
    } else if (message?.numberValue !== void 0) {
      return message.numberValue;
    } else if (message?.boolValue !== void 0) {
      return message.boolValue;
    } else if (message?.structValue !== void 0) {
      return message.structValue;
    } else if (message?.listValue !== void 0) {
      return message.listValue;
    } else if (message?.nullValue !== void 0) {
      return null;
    }
    return void 0;
  }
};
function createBaseListValue() {
  return { values: [] };
}
var ListValue = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.values) {
      Value.encode(Value.wrap(v), writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { values: globalThis.Array.isArray(object?.values) ? [...object.values] : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return ListValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
  wrap(array) {
    const result = createBaseListValue();
    result.values = array ?? [];
    return result;
  },
  unwrap(message) {
    if (message?.hasOwnProperty("values") && globalThis.Array.isArray(message.values)) {
      return message.values;
    } else {
      return message;
    }
  }
};
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSet(value) {
  return value !== null && value !== void 0;
}

// proto/google/protobuf/wrappers.ts
function createBaseStringValue() {
  return { value: "" };
}
var StringValue = {
  encode(message, writer = new BinaryWriter()) {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { value: isSet2(object.value) ? globalThis.String(object.value) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return StringValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseStringValue();
    message.value = object.value ?? "";
    return message;
  }
};
function isSet2(value) {
  return value !== null && value !== void 0;
}

// proto/modal_proto/api.ts
function appDeployVisibilityFromJSON(object) {
  switch (object) {
    case 0:
    case "APP_DEPLOY_VISIBILITY_UNSPECIFIED":
      return 0 /* APP_DEPLOY_VISIBILITY_UNSPECIFIED */;
    case 1:
    case "APP_DEPLOY_VISIBILITY_WORKSPACE":
      return 1 /* APP_DEPLOY_VISIBILITY_WORKSPACE */;
    case 2:
    case "APP_DEPLOY_VISIBILITY_PUBLIC":
      return 2 /* APP_DEPLOY_VISIBILITY_PUBLIC */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function appDeployVisibilityToJSON(object) {
  switch (object) {
    case 0 /* APP_DEPLOY_VISIBILITY_UNSPECIFIED */:
      return "APP_DEPLOY_VISIBILITY_UNSPECIFIED";
    case 1 /* APP_DEPLOY_VISIBILITY_WORKSPACE */:
      return "APP_DEPLOY_VISIBILITY_WORKSPACE";
    case 2 /* APP_DEPLOY_VISIBILITY_PUBLIC */:
      return "APP_DEPLOY_VISIBILITY_PUBLIC";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function appDisconnectReasonFromJSON(object) {
  switch (object) {
    case 0:
    case "APP_DISCONNECT_REASON_UNSPECIFIED":
      return 0 /* APP_DISCONNECT_REASON_UNSPECIFIED */;
    case 1:
    case "APP_DISCONNECT_REASON_LOCAL_EXCEPTION":
      return 1 /* APP_DISCONNECT_REASON_LOCAL_EXCEPTION */;
    case 2:
    case "APP_DISCONNECT_REASON_KEYBOARD_INTERRUPT":
      return 2 /* APP_DISCONNECT_REASON_KEYBOARD_INTERRUPT */;
    case 3:
    case "APP_DISCONNECT_REASON_ENTRYPOINT_COMPLETED":
      return 3 /* APP_DISCONNECT_REASON_ENTRYPOINT_COMPLETED */;
    case 4:
    case "APP_DISCONNECT_REASON_DEPLOYMENT_EXCEPTION":
      return 4 /* APP_DISCONNECT_REASON_DEPLOYMENT_EXCEPTION */;
    case 5:
    case "APP_DISCONNECT_REASON_REMOTE_EXCEPTION":
      return 5 /* APP_DISCONNECT_REASON_REMOTE_EXCEPTION */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function appDisconnectReasonToJSON(object) {
  switch (object) {
    case 0 /* APP_DISCONNECT_REASON_UNSPECIFIED */:
      return "APP_DISCONNECT_REASON_UNSPECIFIED";
    case 1 /* APP_DISCONNECT_REASON_LOCAL_EXCEPTION */:
      return "APP_DISCONNECT_REASON_LOCAL_EXCEPTION";
    case 2 /* APP_DISCONNECT_REASON_KEYBOARD_INTERRUPT */:
      return "APP_DISCONNECT_REASON_KEYBOARD_INTERRUPT";
    case 3 /* APP_DISCONNECT_REASON_ENTRYPOINT_COMPLETED */:
      return "APP_DISCONNECT_REASON_ENTRYPOINT_COMPLETED";
    case 4 /* APP_DISCONNECT_REASON_DEPLOYMENT_EXCEPTION */:
      return "APP_DISCONNECT_REASON_DEPLOYMENT_EXCEPTION";
    case 5 /* APP_DISCONNECT_REASON_REMOTE_EXCEPTION */:
      return "APP_DISCONNECT_REASON_REMOTE_EXCEPTION";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function appStateFromJSON(object) {
  switch (object) {
    case 0:
    case "APP_STATE_UNSPECIFIED":
      return 0 /* APP_STATE_UNSPECIFIED */;
    case 1:
    case "APP_STATE_EPHEMERAL":
      return 1 /* APP_STATE_EPHEMERAL */;
    case 2:
    case "APP_STATE_DETACHED":
      return 2 /* APP_STATE_DETACHED */;
    case 3:
    case "APP_STATE_DEPLOYED":
      return 3 /* APP_STATE_DEPLOYED */;
    case 4:
    case "APP_STATE_STOPPING":
      return 4 /* APP_STATE_STOPPING */;
    case 5:
    case "APP_STATE_STOPPED":
      return 5 /* APP_STATE_STOPPED */;
    case 6:
    case "APP_STATE_INITIALIZING":
      return 6 /* APP_STATE_INITIALIZING */;
    case 7:
    case "APP_STATE_DISABLED":
      return 7 /* APP_STATE_DISABLED */;
    case 8:
    case "APP_STATE_DETACHED_DISCONNECTED":
      return 8 /* APP_STATE_DETACHED_DISCONNECTED */;
    case 9:
    case "APP_STATE_DERIVED":
      return 9 /* APP_STATE_DERIVED */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function appStateToJSON(object) {
  switch (object) {
    case 0 /* APP_STATE_UNSPECIFIED */:
      return "APP_STATE_UNSPECIFIED";
    case 1 /* APP_STATE_EPHEMERAL */:
      return "APP_STATE_EPHEMERAL";
    case 2 /* APP_STATE_DETACHED */:
      return "APP_STATE_DETACHED";
    case 3 /* APP_STATE_DEPLOYED */:
      return "APP_STATE_DEPLOYED";
    case 4 /* APP_STATE_STOPPING */:
      return "APP_STATE_STOPPING";
    case 5 /* APP_STATE_STOPPED */:
      return "APP_STATE_STOPPED";
    case 6 /* APP_STATE_INITIALIZING */:
      return "APP_STATE_INITIALIZING";
    case 7 /* APP_STATE_DISABLED */:
      return "APP_STATE_DISABLED";
    case 8 /* APP_STATE_DETACHED_DISCONNECTED */:
      return "APP_STATE_DETACHED_DISCONNECTED";
    case 9 /* APP_STATE_DERIVED */:
      return "APP_STATE_DERIVED";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function appStopSourceFromJSON(object) {
  switch (object) {
    case 0:
    case "APP_STOP_SOURCE_UNSPECIFIED":
      return 0 /* APP_STOP_SOURCE_UNSPECIFIED */;
    case 1:
    case "APP_STOP_SOURCE_CLI":
      return 1 /* APP_STOP_SOURCE_CLI */;
    case 2:
    case "APP_STOP_SOURCE_PYTHON_CLIENT":
      return 2 /* APP_STOP_SOURCE_PYTHON_CLIENT */;
    case 3:
    case "APP_STOP_SOURCE_WEB":
      return 3 /* APP_STOP_SOURCE_WEB */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function appStopSourceToJSON(object) {
  switch (object) {
    case 0 /* APP_STOP_SOURCE_UNSPECIFIED */:
      return "APP_STOP_SOURCE_UNSPECIFIED";
    case 1 /* APP_STOP_SOURCE_CLI */:
      return "APP_STOP_SOURCE_CLI";
    case 2 /* APP_STOP_SOURCE_PYTHON_CLIENT */:
      return "APP_STOP_SOURCE_PYTHON_CLIENT";
    case 3 /* APP_STOP_SOURCE_WEB */:
      return "APP_STOP_SOURCE_WEB";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function certificateStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "CERTIFICATE_STATUS_PENDING":
      return 0 /* CERTIFICATE_STATUS_PENDING */;
    case 1:
    case "CERTIFICATE_STATUS_ISSUED":
      return 1 /* CERTIFICATE_STATUS_ISSUED */;
    case 2:
    case "CERTIFICATE_STATUS_FAILED":
      return 2 /* CERTIFICATE_STATUS_FAILED */;
    case 3:
    case "CERTIFICATE_STATUS_REVOKED":
      return 3 /* CERTIFICATE_STATUS_REVOKED */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function certificateStatusToJSON(object) {
  switch (object) {
    case 0 /* CERTIFICATE_STATUS_PENDING */:
      return "CERTIFICATE_STATUS_PENDING";
    case 1 /* CERTIFICATE_STATUS_ISSUED */:
      return "CERTIFICATE_STATUS_ISSUED";
    case 2 /* CERTIFICATE_STATUS_FAILED */:
      return "CERTIFICATE_STATUS_FAILED";
    case 3 /* CERTIFICATE_STATUS_REVOKED */:
      return "CERTIFICATE_STATUS_REVOKED";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function checkpointStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "CHECKPOINT_STATUS_UNSPECIFIED":
      return 0 /* CHECKPOINT_STATUS_UNSPECIFIED */;
    case 1:
    case "CHECKPOINT_STATUS_PENDING":
      return 1 /* CHECKPOINT_STATUS_PENDING */;
    case 2:
    case "CHECKPOINT_STATUS_PROCESSING":
      return 2 /* CHECKPOINT_STATUS_PROCESSING */;
    case 3:
    case "CHECKPOINT_STATUS_READY":
      return 3 /* CHECKPOINT_STATUS_READY */;
    case 4:
    case "CHECKPOINT_STATUS_FAILED":
      return 4 /* CHECKPOINT_STATUS_FAILED */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function checkpointStatusToJSON(object) {
  switch (object) {
    case 0 /* CHECKPOINT_STATUS_UNSPECIFIED */:
      return "CHECKPOINT_STATUS_UNSPECIFIED";
    case 1 /* CHECKPOINT_STATUS_PENDING */:
      return "CHECKPOINT_STATUS_PENDING";
    case 2 /* CHECKPOINT_STATUS_PROCESSING */:
      return "CHECKPOINT_STATUS_PROCESSING";
    case 3 /* CHECKPOINT_STATUS_READY */:
      return "CHECKPOINT_STATUS_READY";
    case 4 /* CHECKPOINT_STATUS_FAILED */:
      return "CHECKPOINT_STATUS_FAILED";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function cloudProviderFromJSON(object) {
  switch (object) {
    case 0:
    case "CLOUD_PROVIDER_UNSPECIFIED":
      return 0 /* CLOUD_PROVIDER_UNSPECIFIED */;
    case 1:
    case "CLOUD_PROVIDER_AWS":
      return 1 /* CLOUD_PROVIDER_AWS */;
    case 2:
    case "CLOUD_PROVIDER_GCP":
      return 2 /* CLOUD_PROVIDER_GCP */;
    case 3:
    case "CLOUD_PROVIDER_AUTO":
      return 3 /* CLOUD_PROVIDER_AUTO */;
    case 4:
    case "CLOUD_PROVIDER_OCI":
      return 4 /* CLOUD_PROVIDER_OCI */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function cloudProviderToJSON(object) {
  switch (object) {
    case 0 /* CLOUD_PROVIDER_UNSPECIFIED */:
      return "CLOUD_PROVIDER_UNSPECIFIED";
    case 1 /* CLOUD_PROVIDER_AWS */:
      return "CLOUD_PROVIDER_AWS";
    case 2 /* CLOUD_PROVIDER_GCP */:
      return "CLOUD_PROVIDER_GCP";
    case 3 /* CLOUD_PROVIDER_AUTO */:
      return "CLOUD_PROVIDER_AUTO";
    case 4 /* CLOUD_PROVIDER_OCI */:
      return "CLOUD_PROVIDER_OCI";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function dNSRecordTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "DNS_RECORD_TYPE_A":
      return 0 /* DNS_RECORD_TYPE_A */;
    case 1:
    case "DNS_RECORD_TYPE_TXT":
      return 1 /* DNS_RECORD_TYPE_TXT */;
    case 2:
    case "DNS_RECORD_TYPE_CNAME":
      return 2 /* DNS_RECORD_TYPE_CNAME */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function dNSRecordTypeToJSON(object) {
  switch (object) {
    case 0 /* DNS_RECORD_TYPE_A */:
      return "DNS_RECORD_TYPE_A";
    case 1 /* DNS_RECORD_TYPE_TXT */:
      return "DNS_RECORD_TYPE_TXT";
    case 2 /* DNS_RECORD_TYPE_CNAME */:
      return "DNS_RECORD_TYPE_CNAME";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function dataFormatFromJSON(object) {
  switch (object) {
    case 0:
    case "DATA_FORMAT_UNSPECIFIED":
      return 0 /* DATA_FORMAT_UNSPECIFIED */;
    case 1:
    case "DATA_FORMAT_PICKLE":
      return 1 /* DATA_FORMAT_PICKLE */;
    case 2:
    case "DATA_FORMAT_ASGI":
      return 2 /* DATA_FORMAT_ASGI */;
    case 3:
    case "DATA_FORMAT_GENERATOR_DONE":
      return 3 /* DATA_FORMAT_GENERATOR_DONE */;
    case 4:
    case "DATA_FORMAT_CBOR":
      return 4 /* DATA_FORMAT_CBOR */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function dataFormatToJSON(object) {
  switch (object) {
    case 0 /* DATA_FORMAT_UNSPECIFIED */:
      return "DATA_FORMAT_UNSPECIFIED";
    case 1 /* DATA_FORMAT_PICKLE */:
      return "DATA_FORMAT_PICKLE";
    case 2 /* DATA_FORMAT_ASGI */:
      return "DATA_FORMAT_ASGI";
    case 3 /* DATA_FORMAT_GENERATOR_DONE */:
      return "DATA_FORMAT_GENERATOR_DONE";
    case 4 /* DATA_FORMAT_CBOR */:
      return "DATA_FORMAT_CBOR";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function deploymentNamespaceFromJSON(object) {
  switch (object) {
    case 0:
    case "DEPLOYMENT_NAMESPACE_UNSPECIFIED":
      return 0 /* DEPLOYMENT_NAMESPACE_UNSPECIFIED */;
    case 1:
    case "DEPLOYMENT_NAMESPACE_WORKSPACE":
      return 1 /* DEPLOYMENT_NAMESPACE_WORKSPACE */;
    case 3:
    case "DEPLOYMENT_NAMESPACE_GLOBAL":
      return 3 /* DEPLOYMENT_NAMESPACE_GLOBAL */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function deploymentNamespaceToJSON(object) {
  switch (object) {
    case 0 /* DEPLOYMENT_NAMESPACE_UNSPECIFIED */:
      return "DEPLOYMENT_NAMESPACE_UNSPECIFIED";
    case 1 /* DEPLOYMENT_NAMESPACE_WORKSPACE */:
      return "DEPLOYMENT_NAMESPACE_WORKSPACE";
    case 3 /* DEPLOYMENT_NAMESPACE_GLOBAL */:
      return "DEPLOYMENT_NAMESPACE_GLOBAL";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function execOutputOptionFromJSON(object) {
  switch (object) {
    case 0:
    case "EXEC_OUTPUT_OPTION_UNSPECIFIED":
      return 0 /* EXEC_OUTPUT_OPTION_UNSPECIFIED */;
    case 1:
    case "EXEC_OUTPUT_OPTION_DEVNULL":
      return 1 /* EXEC_OUTPUT_OPTION_DEVNULL */;
    case 2:
    case "EXEC_OUTPUT_OPTION_PIPE":
      return 2 /* EXEC_OUTPUT_OPTION_PIPE */;
    case 3:
    case "EXEC_OUTPUT_OPTION_STDOUT":
      return 3 /* EXEC_OUTPUT_OPTION_STDOUT */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function execOutputOptionToJSON(object) {
  switch (object) {
    case 0 /* EXEC_OUTPUT_OPTION_UNSPECIFIED */:
      return "EXEC_OUTPUT_OPTION_UNSPECIFIED";
    case 1 /* EXEC_OUTPUT_OPTION_DEVNULL */:
      return "EXEC_OUTPUT_OPTION_DEVNULL";
    case 2 /* EXEC_OUTPUT_OPTION_PIPE */:
      return "EXEC_OUTPUT_OPTION_PIPE";
    case 3 /* EXEC_OUTPUT_OPTION_STDOUT */:
      return "EXEC_OUTPUT_OPTION_STDOUT";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function fileDescriptorFromJSON(object) {
  switch (object) {
    case 0:
    case "FILE_DESCRIPTOR_UNSPECIFIED":
      return 0 /* FILE_DESCRIPTOR_UNSPECIFIED */;
    case 1:
    case "FILE_DESCRIPTOR_STDOUT":
      return 1 /* FILE_DESCRIPTOR_STDOUT */;
    case 2:
    case "FILE_DESCRIPTOR_STDERR":
      return 2 /* FILE_DESCRIPTOR_STDERR */;
    case 3:
    case "FILE_DESCRIPTOR_INFO":
      return 3 /* FILE_DESCRIPTOR_INFO */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function fileDescriptorToJSON(object) {
  switch (object) {
    case 0 /* FILE_DESCRIPTOR_UNSPECIFIED */:
      return "FILE_DESCRIPTOR_UNSPECIFIED";
    case 1 /* FILE_DESCRIPTOR_STDOUT */:
      return "FILE_DESCRIPTOR_STDOUT";
    case 2 /* FILE_DESCRIPTOR_STDERR */:
      return "FILE_DESCRIPTOR_STDERR";
    case 3 /* FILE_DESCRIPTOR_INFO */:
      return "FILE_DESCRIPTOR_INFO";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function functionCallInvocationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "FUNCTION_CALL_INVOCATION_TYPE_UNSPECIFIED":
      return 0 /* FUNCTION_CALL_INVOCATION_TYPE_UNSPECIFIED */;
    case 1:
    case "FUNCTION_CALL_INVOCATION_TYPE_SYNC_LEGACY":
      return 1 /* FUNCTION_CALL_INVOCATION_TYPE_SYNC_LEGACY */;
    case 2:
    case "FUNCTION_CALL_INVOCATION_TYPE_ASYNC_LEGACY":
      return 2 /* FUNCTION_CALL_INVOCATION_TYPE_ASYNC_LEGACY */;
    case 3:
    case "FUNCTION_CALL_INVOCATION_TYPE_ASYNC":
      return 3 /* FUNCTION_CALL_INVOCATION_TYPE_ASYNC */;
    case 4:
    case "FUNCTION_CALL_INVOCATION_TYPE_SYNC":
      return 4 /* FUNCTION_CALL_INVOCATION_TYPE_SYNC */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function functionCallInvocationTypeToJSON(object) {
  switch (object) {
    case 0 /* FUNCTION_CALL_INVOCATION_TYPE_UNSPECIFIED */:
      return "FUNCTION_CALL_INVOCATION_TYPE_UNSPECIFIED";
    case 1 /* FUNCTION_CALL_INVOCATION_TYPE_SYNC_LEGACY */:
      return "FUNCTION_CALL_INVOCATION_TYPE_SYNC_LEGACY";
    case 2 /* FUNCTION_CALL_INVOCATION_TYPE_ASYNC_LEGACY */:
      return "FUNCTION_CALL_INVOCATION_TYPE_ASYNC_LEGACY";
    case 3 /* FUNCTION_CALL_INVOCATION_TYPE_ASYNC */:
      return "FUNCTION_CALL_INVOCATION_TYPE_ASYNC";
    case 4 /* FUNCTION_CALL_INVOCATION_TYPE_SYNC */:
      return "FUNCTION_CALL_INVOCATION_TYPE_SYNC";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function functionCallTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "FUNCTION_CALL_TYPE_UNSPECIFIED":
      return 0 /* FUNCTION_CALL_TYPE_UNSPECIFIED */;
    case 1:
    case "FUNCTION_CALL_TYPE_UNARY":
      return 1 /* FUNCTION_CALL_TYPE_UNARY */;
    case 2:
    case "FUNCTION_CALL_TYPE_MAP":
      return 2 /* FUNCTION_CALL_TYPE_MAP */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function functionCallTypeToJSON(object) {
  switch (object) {
    case 0 /* FUNCTION_CALL_TYPE_UNSPECIFIED */:
      return "FUNCTION_CALL_TYPE_UNSPECIFIED";
    case 1 /* FUNCTION_CALL_TYPE_UNARY */:
      return "FUNCTION_CALL_TYPE_UNARY";
    case 2 /* FUNCTION_CALL_TYPE_MAP */:
      return "FUNCTION_CALL_TYPE_MAP";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function gPUTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "GPU_TYPE_UNSPECIFIED":
      return 0 /* GPU_TYPE_UNSPECIFIED */;
    case 1:
    case "GPU_TYPE_T4":
      return 1 /* GPU_TYPE_T4 */;
    case 2:
    case "GPU_TYPE_A100":
      return 2 /* GPU_TYPE_A100 */;
    case 3:
    case "GPU_TYPE_A10G":
      return 3 /* GPU_TYPE_A10G */;
    case 4:
    case "GPU_TYPE_ANY":
      return 4 /* GPU_TYPE_ANY */;
    case 8:
    case "GPU_TYPE_A100_80GB":
      return 8 /* GPU_TYPE_A100_80GB */;
    case 9:
    case "GPU_TYPE_L4":
      return 9 /* GPU_TYPE_L4 */;
    case 10:
    case "GPU_TYPE_H100":
      return 10 /* GPU_TYPE_H100 */;
    case 11:
    case "GPU_TYPE_L40S":
      return 11 /* GPU_TYPE_L40S */;
    case 12:
    case "GPU_TYPE_H200":
      return 12 /* GPU_TYPE_H200 */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function gPUTypeToJSON(object) {
  switch (object) {
    case 0 /* GPU_TYPE_UNSPECIFIED */:
      return "GPU_TYPE_UNSPECIFIED";
    case 1 /* GPU_TYPE_T4 */:
      return "GPU_TYPE_T4";
    case 2 /* GPU_TYPE_A100 */:
      return "GPU_TYPE_A100";
    case 3 /* GPU_TYPE_A10G */:
      return "GPU_TYPE_A10G";
    case 4 /* GPU_TYPE_ANY */:
      return "GPU_TYPE_ANY";
    case 8 /* GPU_TYPE_A100_80GB */:
      return "GPU_TYPE_A100_80GB";
    case 9 /* GPU_TYPE_L4 */:
      return "GPU_TYPE_L4";
    case 10 /* GPU_TYPE_H100 */:
      return "GPU_TYPE_H100";
    case 11 /* GPU_TYPE_L40S */:
      return "GPU_TYPE_L40S";
    case 12 /* GPU_TYPE_H200 */:
      return "GPU_TYPE_H200";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function objectCreationTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "OBJECT_CREATION_TYPE_UNSPECIFIED":
      return 0 /* OBJECT_CREATION_TYPE_UNSPECIFIED */;
    case 1:
    case "OBJECT_CREATION_TYPE_CREATE_IF_MISSING":
      return 1 /* OBJECT_CREATION_TYPE_CREATE_IF_MISSING */;
    case 2:
    case "OBJECT_CREATION_TYPE_CREATE_FAIL_IF_EXISTS":
      return 2 /* OBJECT_CREATION_TYPE_CREATE_FAIL_IF_EXISTS */;
    case 3:
    case "OBJECT_CREATION_TYPE_CREATE_OVERWRITE_IF_EXISTS":
      return 3 /* OBJECT_CREATION_TYPE_CREATE_OVERWRITE_IF_EXISTS */;
    case 4:
    case "OBJECT_CREATION_TYPE_ANONYMOUS_OWNED_BY_APP":
      return 4 /* OBJECT_CREATION_TYPE_ANONYMOUS_OWNED_BY_APP */;
    case 5:
    case "OBJECT_CREATION_TYPE_EPHEMERAL":
      return 5 /* OBJECT_CREATION_TYPE_EPHEMERAL */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function objectCreationTypeToJSON(object) {
  switch (object) {
    case 0 /* OBJECT_CREATION_TYPE_UNSPECIFIED */:
      return "OBJECT_CREATION_TYPE_UNSPECIFIED";
    case 1 /* OBJECT_CREATION_TYPE_CREATE_IF_MISSING */:
      return "OBJECT_CREATION_TYPE_CREATE_IF_MISSING";
    case 2 /* OBJECT_CREATION_TYPE_CREATE_FAIL_IF_EXISTS */:
      return "OBJECT_CREATION_TYPE_CREATE_FAIL_IF_EXISTS";
    case 3 /* OBJECT_CREATION_TYPE_CREATE_OVERWRITE_IF_EXISTS */:
      return "OBJECT_CREATION_TYPE_CREATE_OVERWRITE_IF_EXISTS";
    case 4 /* OBJECT_CREATION_TYPE_ANONYMOUS_OWNED_BY_APP */:
      return "OBJECT_CREATION_TYPE_ANONYMOUS_OWNED_BY_APP";
    case 5 /* OBJECT_CREATION_TYPE_EPHEMERAL */:
      return "OBJECT_CREATION_TYPE_EPHEMERAL";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function parameterTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "PARAM_TYPE_UNSPECIFIED":
      return 0 /* PARAM_TYPE_UNSPECIFIED */;
    case 1:
    case "PARAM_TYPE_STRING":
      return 1 /* PARAM_TYPE_STRING */;
    case 2:
    case "PARAM_TYPE_INT":
      return 2 /* PARAM_TYPE_INT */;
    case 3:
    case "PARAM_TYPE_PICKLE":
      return 3 /* PARAM_TYPE_PICKLE */;
    case 4:
    case "PARAM_TYPE_BYTES":
      return 4 /* PARAM_TYPE_BYTES */;
    case 5:
    case "PARAM_TYPE_UNKNOWN":
      return 5 /* PARAM_TYPE_UNKNOWN */;
    case 6:
    case "PARAM_TYPE_LIST":
      return 6 /* PARAM_TYPE_LIST */;
    case 7:
    case "PARAM_TYPE_DICT":
      return 7 /* PARAM_TYPE_DICT */;
    case 8:
    case "PARAM_TYPE_NONE":
      return 8 /* PARAM_TYPE_NONE */;
    case 9:
    case "PARAM_TYPE_BOOL":
      return 9 /* PARAM_TYPE_BOOL */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function parameterTypeToJSON(object) {
  switch (object) {
    case 0 /* PARAM_TYPE_UNSPECIFIED */:
      return "PARAM_TYPE_UNSPECIFIED";
    case 1 /* PARAM_TYPE_STRING */:
      return "PARAM_TYPE_STRING";
    case 2 /* PARAM_TYPE_INT */:
      return "PARAM_TYPE_INT";
    case 3 /* PARAM_TYPE_PICKLE */:
      return "PARAM_TYPE_PICKLE";
    case 4 /* PARAM_TYPE_BYTES */:
      return "PARAM_TYPE_BYTES";
    case 5 /* PARAM_TYPE_UNKNOWN */:
      return "PARAM_TYPE_UNKNOWN";
    case 6 /* PARAM_TYPE_LIST */:
      return "PARAM_TYPE_LIST";
    case 7 /* PARAM_TYPE_DICT */:
      return "PARAM_TYPE_DICT";
    case 8 /* PARAM_TYPE_NONE */:
      return "PARAM_TYPE_NONE";
    case 9 /* PARAM_TYPE_BOOL */:
      return "PARAM_TYPE_BOOL";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function progressTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "IMAGE_SNAPSHOT_UPLOAD":
      return 0 /* IMAGE_SNAPSHOT_UPLOAD */;
    case 1:
    case "FUNCTION_QUEUED":
      return 1 /* FUNCTION_QUEUED */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function progressTypeToJSON(object) {
  switch (object) {
    case 0 /* IMAGE_SNAPSHOT_UPLOAD */:
      return "IMAGE_SNAPSHOT_UPLOAD";
    case 1 /* FUNCTION_QUEUED */:
      return "FUNCTION_QUEUED";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function proxyIpStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "PROXY_IP_STATUS_UNSPECIFIED":
      return 0 /* PROXY_IP_STATUS_UNSPECIFIED */;
    case 1:
    case "PROXY_IP_STATUS_CREATING":
      return 1 /* PROXY_IP_STATUS_CREATING */;
    case 2:
    case "PROXY_IP_STATUS_ONLINE":
      return 2 /* PROXY_IP_STATUS_ONLINE */;
    case 3:
    case "PROXY_IP_STATUS_TERMINATED":
      return 3 /* PROXY_IP_STATUS_TERMINATED */;
    case 4:
    case "PROXY_IP_STATUS_UNHEALTHY":
      return 4 /* PROXY_IP_STATUS_UNHEALTHY */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function proxyIpStatusToJSON(object) {
  switch (object) {
    case 0 /* PROXY_IP_STATUS_UNSPECIFIED */:
      return "PROXY_IP_STATUS_UNSPECIFIED";
    case 1 /* PROXY_IP_STATUS_CREATING */:
      return "PROXY_IP_STATUS_CREATING";
    case 2 /* PROXY_IP_STATUS_ONLINE */:
      return "PROXY_IP_STATUS_ONLINE";
    case 3 /* PROXY_IP_STATUS_TERMINATED */:
      return "PROXY_IP_STATUS_TERMINATED";
    case 4 /* PROXY_IP_STATUS_UNHEALTHY */:
      return "PROXY_IP_STATUS_UNHEALTHY";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function rateLimitIntervalFromJSON(object) {
  switch (object) {
    case 0:
    case "RATE_LIMIT_INTERVAL_UNSPECIFIED":
      return 0 /* RATE_LIMIT_INTERVAL_UNSPECIFIED */;
    case 1:
    case "RATE_LIMIT_INTERVAL_SECOND":
      return 1 /* RATE_LIMIT_INTERVAL_SECOND */;
    case 2:
    case "RATE_LIMIT_INTERVAL_MINUTE":
      return 2 /* RATE_LIMIT_INTERVAL_MINUTE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function rateLimitIntervalToJSON(object) {
  switch (object) {
    case 0 /* RATE_LIMIT_INTERVAL_UNSPECIFIED */:
      return "RATE_LIMIT_INTERVAL_UNSPECIFIED";
    case 1 /* RATE_LIMIT_INTERVAL_SECOND */:
      return "RATE_LIMIT_INTERVAL_SECOND";
    case 2 /* RATE_LIMIT_INTERVAL_MINUTE */:
      return "RATE_LIMIT_INTERVAL_MINUTE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function registryAuthTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "REGISTRY_AUTH_TYPE_UNSPECIFIED":
      return 0 /* REGISTRY_AUTH_TYPE_UNSPECIFIED */;
    case 1:
    case "REGISTRY_AUTH_TYPE_AWS":
      return 1 /* REGISTRY_AUTH_TYPE_AWS */;
    case 2:
    case "REGISTRY_AUTH_TYPE_GCP":
      return 2 /* REGISTRY_AUTH_TYPE_GCP */;
    case 3:
    case "REGISTRY_AUTH_TYPE_PUBLIC":
      return 3 /* REGISTRY_AUTH_TYPE_PUBLIC */;
    case 4:
    case "REGISTRY_AUTH_TYPE_STATIC_CREDS":
      return 4 /* REGISTRY_AUTH_TYPE_STATIC_CREDS */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function registryAuthTypeToJSON(object) {
  switch (object) {
    case 0 /* REGISTRY_AUTH_TYPE_UNSPECIFIED */:
      return "REGISTRY_AUTH_TYPE_UNSPECIFIED";
    case 1 /* REGISTRY_AUTH_TYPE_AWS */:
      return "REGISTRY_AUTH_TYPE_AWS";
    case 2 /* REGISTRY_AUTH_TYPE_GCP */:
      return "REGISTRY_AUTH_TYPE_GCP";
    case 3 /* REGISTRY_AUTH_TYPE_PUBLIC */:
      return "REGISTRY_AUTH_TYPE_PUBLIC";
    case 4 /* REGISTRY_AUTH_TYPE_STATIC_CREDS */:
      return "REGISTRY_AUTH_TYPE_STATIC_CREDS";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function seekWhenceFromJSON(object) {
  switch (object) {
    case 0:
    case "SEEK_SET":
      return 0 /* SEEK_SET */;
    case 1:
    case "SEEK_CUR":
      return 1 /* SEEK_CUR */;
    case 2:
    case "SEEK_END":
      return 2 /* SEEK_END */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function seekWhenceToJSON(object) {
  switch (object) {
    case 0 /* SEEK_SET */:
      return "SEEK_SET";
    case 1 /* SEEK_CUR */:
      return "SEEK_CUR";
    case 2 /* SEEK_END */:
      return "SEEK_END";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function systemErrorCodeFromJSON(object) {
  switch (object) {
    case 0:
    case "SYSTEM_ERROR_CODE_UNSPECIFIED":
      return 0 /* SYSTEM_ERROR_CODE_UNSPECIFIED */;
    case 1:
    case "SYSTEM_ERROR_CODE_PERM":
      return 1 /* SYSTEM_ERROR_CODE_PERM */;
    case 2:
    case "SYSTEM_ERROR_CODE_NOENT":
      return 2 /* SYSTEM_ERROR_CODE_NOENT */;
    case 5:
    case "SYSTEM_ERROR_CODE_IO":
      return 5 /* SYSTEM_ERROR_CODE_IO */;
    case 6:
    case "SYSTEM_ERROR_CODE_NXIO":
      return 6 /* SYSTEM_ERROR_CODE_NXIO */;
    case 12:
    case "SYSTEM_ERROR_CODE_NOMEM":
      return 12 /* SYSTEM_ERROR_CODE_NOMEM */;
    case 13:
    case "SYSTEM_ERROR_CODE_ACCES":
      return 13 /* SYSTEM_ERROR_CODE_ACCES */;
    case 17:
    case "SYSTEM_ERROR_CODE_EXIST":
      return 17 /* SYSTEM_ERROR_CODE_EXIST */;
    case 20:
    case "SYSTEM_ERROR_CODE_NOTDIR":
      return 20 /* SYSTEM_ERROR_CODE_NOTDIR */;
    case 21:
    case "SYSTEM_ERROR_CODE_ISDIR":
      return 21 /* SYSTEM_ERROR_CODE_ISDIR */;
    case 22:
    case "SYSTEM_ERROR_CODE_INVAL":
      return 22 /* SYSTEM_ERROR_CODE_INVAL */;
    case 24:
    case "SYSTEM_ERROR_CODE_MFILE":
      return 24 /* SYSTEM_ERROR_CODE_MFILE */;
    case 27:
    case "SYSTEM_ERROR_CODE_FBIG":
      return 27 /* SYSTEM_ERROR_CODE_FBIG */;
    case 28:
    case "SYSTEM_ERROR_CODE_NOSPC":
      return 28 /* SYSTEM_ERROR_CODE_NOSPC */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function systemErrorCodeToJSON(object) {
  switch (object) {
    case 0 /* SYSTEM_ERROR_CODE_UNSPECIFIED */:
      return "SYSTEM_ERROR_CODE_UNSPECIFIED";
    case 1 /* SYSTEM_ERROR_CODE_PERM */:
      return "SYSTEM_ERROR_CODE_PERM";
    case 2 /* SYSTEM_ERROR_CODE_NOENT */:
      return "SYSTEM_ERROR_CODE_NOENT";
    case 5 /* SYSTEM_ERROR_CODE_IO */:
      return "SYSTEM_ERROR_CODE_IO";
    case 6 /* SYSTEM_ERROR_CODE_NXIO */:
      return "SYSTEM_ERROR_CODE_NXIO";
    case 12 /* SYSTEM_ERROR_CODE_NOMEM */:
      return "SYSTEM_ERROR_CODE_NOMEM";
    case 13 /* SYSTEM_ERROR_CODE_ACCES */:
      return "SYSTEM_ERROR_CODE_ACCES";
    case 17 /* SYSTEM_ERROR_CODE_EXIST */:
      return "SYSTEM_ERROR_CODE_EXIST";
    case 20 /* SYSTEM_ERROR_CODE_NOTDIR */:
      return "SYSTEM_ERROR_CODE_NOTDIR";
    case 21 /* SYSTEM_ERROR_CODE_ISDIR */:
      return "SYSTEM_ERROR_CODE_ISDIR";
    case 22 /* SYSTEM_ERROR_CODE_INVAL */:
      return "SYSTEM_ERROR_CODE_INVAL";
    case 24 /* SYSTEM_ERROR_CODE_MFILE */:
      return "SYSTEM_ERROR_CODE_MFILE";
    case 27 /* SYSTEM_ERROR_CODE_FBIG */:
      return "SYSTEM_ERROR_CODE_FBIG";
    case 28 /* SYSTEM_ERROR_CODE_NOSPC */:
      return "SYSTEM_ERROR_CODE_NOSPC";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function taskSnapshotBehaviorFromJSON(object) {
  switch (object) {
    case 0:
    case "TASK_SNAPSHOT_BEHAVIOR_UNSPECIFIED":
      return 0 /* TASK_SNAPSHOT_BEHAVIOR_UNSPECIFIED */;
    case 1:
    case "TASK_SNAPSHOT_BEHAVIOR_SNAPSHOT":
      return 1 /* TASK_SNAPSHOT_BEHAVIOR_SNAPSHOT */;
    case 2:
    case "TASK_SNAPSHOT_BEHAVIOR_RESTORE":
      return 2 /* TASK_SNAPSHOT_BEHAVIOR_RESTORE */;
    case 3:
    case "TASK_SNAPSHOT_BEHAVIOR_NONE":
      return 3 /* TASK_SNAPSHOT_BEHAVIOR_NONE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function taskSnapshotBehaviorToJSON(object) {
  switch (object) {
    case 0 /* TASK_SNAPSHOT_BEHAVIOR_UNSPECIFIED */:
      return "TASK_SNAPSHOT_BEHAVIOR_UNSPECIFIED";
    case 1 /* TASK_SNAPSHOT_BEHAVIOR_SNAPSHOT */:
      return "TASK_SNAPSHOT_BEHAVIOR_SNAPSHOT";
    case 2 /* TASK_SNAPSHOT_BEHAVIOR_RESTORE */:
      return "TASK_SNAPSHOT_BEHAVIOR_RESTORE";
    case 3 /* TASK_SNAPSHOT_BEHAVIOR_NONE */:
      return "TASK_SNAPSHOT_BEHAVIOR_NONE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function taskStateFromJSON(object) {
  switch (object) {
    case 0:
    case "TASK_STATE_UNSPECIFIED":
      return 0 /* TASK_STATE_UNSPECIFIED */;
    case 6:
    case "TASK_STATE_CREATED":
      return 6 /* TASK_STATE_CREATED */;
    case 1:
    case "TASK_STATE_QUEUED":
      return 1 /* TASK_STATE_QUEUED */;
    case 2:
    case "TASK_STATE_WORKER_ASSIGNED":
      return 2 /* TASK_STATE_WORKER_ASSIGNED */;
    case 3:
    case "TASK_STATE_LOADING_IMAGE":
      return 3 /* TASK_STATE_LOADING_IMAGE */;
    case 4:
    case "TASK_STATE_ACTIVE":
      return 4 /* TASK_STATE_ACTIVE */;
    case 5:
    case "TASK_STATE_COMPLETED":
      return 5 /* TASK_STATE_COMPLETED */;
    case 7:
    case "TASK_STATE_CREATING_CONTAINER":
      return 7 /* TASK_STATE_CREATING_CONTAINER */;
    case 8:
    case "TASK_STATE_IDLE":
      return 8 /* TASK_STATE_IDLE */;
    case 9:
    case "TASK_STATE_PREEMPTIBLE":
      return 9 /* TASK_STATE_PREEMPTIBLE */;
    case 10:
    case "TASK_STATE_PREEMPTED":
      return 10 /* TASK_STATE_PREEMPTED */;
    case 11:
    case "TASK_STATE_LOADING_CHECKPOINT_IMAGE":
      return 11 /* TASK_STATE_LOADING_CHECKPOINT_IMAGE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function taskStateToJSON(object) {
  switch (object) {
    case 0 /* TASK_STATE_UNSPECIFIED */:
      return "TASK_STATE_UNSPECIFIED";
    case 6 /* TASK_STATE_CREATED */:
      return "TASK_STATE_CREATED";
    case 1 /* TASK_STATE_QUEUED */:
      return "TASK_STATE_QUEUED";
    case 2 /* TASK_STATE_WORKER_ASSIGNED */:
      return "TASK_STATE_WORKER_ASSIGNED";
    case 3 /* TASK_STATE_LOADING_IMAGE */:
      return "TASK_STATE_LOADING_IMAGE";
    case 4 /* TASK_STATE_ACTIVE */:
      return "TASK_STATE_ACTIVE";
    case 5 /* TASK_STATE_COMPLETED */:
      return "TASK_STATE_COMPLETED";
    case 7 /* TASK_STATE_CREATING_CONTAINER */:
      return "TASK_STATE_CREATING_CONTAINER";
    case 8 /* TASK_STATE_IDLE */:
      return "TASK_STATE_IDLE";
    case 9 /* TASK_STATE_PREEMPTIBLE */:
      return "TASK_STATE_PREEMPTIBLE";
    case 10 /* TASK_STATE_PREEMPTED */:
      return "TASK_STATE_PREEMPTED";
    case 11 /* TASK_STATE_LOADING_CHECKPOINT_IMAGE */:
      return "TASK_STATE_LOADING_CHECKPOINT_IMAGE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function tunnelTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "TUNNEL_TYPE_UNSPECIFIED":
      return 0 /* TUNNEL_TYPE_UNSPECIFIED */;
    case 1:
    case "TUNNEL_TYPE_H2":
      return 1 /* TUNNEL_TYPE_H2 */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function tunnelTypeToJSON(object) {
  switch (object) {
    case 0 /* TUNNEL_TYPE_UNSPECIFIED */:
      return "TUNNEL_TYPE_UNSPECIFIED";
    case 1 /* TUNNEL_TYPE_H2 */:
      return "TUNNEL_TYPE_H2";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function volumeFsVersionFromJSON(object) {
  switch (object) {
    case 0:
    case "VOLUME_FS_VERSION_UNSPECIFIED":
      return 0 /* VOLUME_FS_VERSION_UNSPECIFIED */;
    case 1:
    case "VOLUME_FS_VERSION_V1":
      return 1 /* VOLUME_FS_VERSION_V1 */;
    case 2:
    case "VOLUME_FS_VERSION_V2":
      return 2 /* VOLUME_FS_VERSION_V2 */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function volumeFsVersionToJSON(object) {
  switch (object) {
    case 0 /* VOLUME_FS_VERSION_UNSPECIFIED */:
      return "VOLUME_FS_VERSION_UNSPECIFIED";
    case 1 /* VOLUME_FS_VERSION_V1 */:
      return "VOLUME_FS_VERSION_V1";
    case 2 /* VOLUME_FS_VERSION_V2 */:
      return "VOLUME_FS_VERSION_V2";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function webhookAsyncModeFromJSON(object) {
  switch (object) {
    case 0:
    case "WEBHOOK_ASYNC_MODE_UNSPECIFIED":
      return 0 /* WEBHOOK_ASYNC_MODE_UNSPECIFIED */;
    case 2:
    case "WEBHOOK_ASYNC_MODE_DISABLED":
      return 2 /* WEBHOOK_ASYNC_MODE_DISABLED */;
    case 3:
    case "WEBHOOK_ASYNC_MODE_TRIGGER":
      return 3 /* WEBHOOK_ASYNC_MODE_TRIGGER */;
    case 4:
    case "WEBHOOK_ASYNC_MODE_AUTO":
      return 4 /* WEBHOOK_ASYNC_MODE_AUTO */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function webhookAsyncModeToJSON(object) {
  switch (object) {
    case 0 /* WEBHOOK_ASYNC_MODE_UNSPECIFIED */:
      return "WEBHOOK_ASYNC_MODE_UNSPECIFIED";
    case 2 /* WEBHOOK_ASYNC_MODE_DISABLED */:
      return "WEBHOOK_ASYNC_MODE_DISABLED";
    case 3 /* WEBHOOK_ASYNC_MODE_TRIGGER */:
      return "WEBHOOK_ASYNC_MODE_TRIGGER";
    case 4 /* WEBHOOK_ASYNC_MODE_AUTO */:
      return "WEBHOOK_ASYNC_MODE_AUTO";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function webhookTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "WEBHOOK_TYPE_UNSPECIFIED":
      return 0 /* WEBHOOK_TYPE_UNSPECIFIED */;
    case 1:
    case "WEBHOOK_TYPE_ASGI_APP":
      return 1 /* WEBHOOK_TYPE_ASGI_APP */;
    case 2:
    case "WEBHOOK_TYPE_FUNCTION":
      return 2 /* WEBHOOK_TYPE_FUNCTION */;
    case 3:
    case "WEBHOOK_TYPE_WSGI_APP":
      return 3 /* WEBHOOK_TYPE_WSGI_APP */;
    case 4:
    case "WEBHOOK_TYPE_WEB_SERVER":
      return 4 /* WEBHOOK_TYPE_WEB_SERVER */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function webhookTypeToJSON(object) {
  switch (object) {
    case 0 /* WEBHOOK_TYPE_UNSPECIFIED */:
      return "WEBHOOK_TYPE_UNSPECIFIED";
    case 1 /* WEBHOOK_TYPE_ASGI_APP */:
      return "WEBHOOK_TYPE_ASGI_APP";
    case 2 /* WEBHOOK_TYPE_FUNCTION */:
      return "WEBHOOK_TYPE_FUNCTION";
    case 3 /* WEBHOOK_TYPE_WSGI_APP */:
      return "WEBHOOK_TYPE_WSGI_APP";
    case 4 /* WEBHOOK_TYPE_WEB_SERVER */:
      return "WEBHOOK_TYPE_WEB_SERVER";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function classParameterInfo_ParameterSerializationFormatFromJSON(object) {
  switch (object) {
    case 0:
    case "PARAM_SERIALIZATION_FORMAT_UNSPECIFIED":
      return 0 /* PARAM_SERIALIZATION_FORMAT_UNSPECIFIED */;
    case 1:
    case "PARAM_SERIALIZATION_FORMAT_PICKLE":
      return 1 /* PARAM_SERIALIZATION_FORMAT_PICKLE */;
    case 2:
    case "PARAM_SERIALIZATION_FORMAT_PROTO":
      return 2 /* PARAM_SERIALIZATION_FORMAT_PROTO */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function classParameterInfo_ParameterSerializationFormatToJSON(object) {
  switch (object) {
    case 0 /* PARAM_SERIALIZATION_FORMAT_UNSPECIFIED */:
      return "PARAM_SERIALIZATION_FORMAT_UNSPECIFIED";
    case 1 /* PARAM_SERIALIZATION_FORMAT_PICKLE */:
      return "PARAM_SERIALIZATION_FORMAT_PICKLE";
    case 2 /* PARAM_SERIALIZATION_FORMAT_PROTO */:
      return "PARAM_SERIALIZATION_FORMAT_PROTO";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function cloudBucketMount_BucketTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "S3":
      return 1 /* S3 */;
    case 2:
    case "R2":
      return 2 /* R2 */;
    case 3:
    case "GCP":
      return 3 /* GCP */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function cloudBucketMount_BucketTypeToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "UNSPECIFIED";
    case 1 /* S3 */:
      return "S3";
    case 2 /* R2 */:
      return "R2";
    case 3 /* GCP */:
      return "GCP";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function fileEntry_FileTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "FILE":
      return 1 /* FILE */;
    case 2:
    case "DIRECTORY":
      return 2 /* DIRECTORY */;
    case 3:
    case "SYMLINK":
      return 3 /* SYMLINK */;
    case 4:
    case "FIFO":
      return 4 /* FIFO */;
    case 5:
    case "SOCKET":
      return 5 /* SOCKET */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function fileEntry_FileTypeToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "UNSPECIFIED";
    case 1 /* FILE */:
      return "FILE";
    case 2 /* DIRECTORY */:
      return "DIRECTORY";
    case 3 /* SYMLINK */:
      return "SYMLINK";
    case 4 /* FIFO */:
      return "FIFO";
    case 5 /* SOCKET */:
      return "SOCKET";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function function_DefinitionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "DEFINITION_TYPE_UNSPECIFIED":
      return 0 /* DEFINITION_TYPE_UNSPECIFIED */;
    case 1:
    case "DEFINITION_TYPE_SERIALIZED":
      return 1 /* DEFINITION_TYPE_SERIALIZED */;
    case 2:
    case "DEFINITION_TYPE_FILE":
      return 2 /* DEFINITION_TYPE_FILE */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function function_DefinitionTypeToJSON(object) {
  switch (object) {
    case 0 /* DEFINITION_TYPE_UNSPECIFIED */:
      return "DEFINITION_TYPE_UNSPECIFIED";
    case 1 /* DEFINITION_TYPE_SERIALIZED */:
      return "DEFINITION_TYPE_SERIALIZED";
    case 2 /* DEFINITION_TYPE_FILE */:
      return "DEFINITION_TYPE_FILE";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function function_FunctionTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "FUNCTION_TYPE_UNSPECIFIED":
      return 0 /* FUNCTION_TYPE_UNSPECIFIED */;
    case 1:
    case "FUNCTION_TYPE_GENERATOR":
      return 1 /* FUNCTION_TYPE_GENERATOR */;
    case 2:
    case "FUNCTION_TYPE_FUNCTION":
      return 2 /* FUNCTION_TYPE_FUNCTION */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function function_FunctionTypeToJSON(object) {
  switch (object) {
    case 0 /* FUNCTION_TYPE_UNSPECIFIED */:
      return "FUNCTION_TYPE_UNSPECIFIED";
    case 1 /* FUNCTION_TYPE_GENERATOR */:
      return "FUNCTION_TYPE_GENERATOR";
    case 2 /* FUNCTION_TYPE_FUNCTION */:
      return "FUNCTION_TYPE_FUNCTION";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function functionSchema_FunctionSchemaTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "FUNCTION_SCHEMA_UNSPECIFIED":
      return 0 /* FUNCTION_SCHEMA_UNSPECIFIED */;
    case 1:
    case "FUNCTION_SCHEMA_V1":
      return 1 /* FUNCTION_SCHEMA_V1 */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function functionSchema_FunctionSchemaTypeToJSON(object) {
  switch (object) {
    case 0 /* FUNCTION_SCHEMA_UNSPECIFIED */:
      return "FUNCTION_SCHEMA_UNSPECIFIED";
    case 1 /* FUNCTION_SCHEMA_V1 */:
      return "FUNCTION_SCHEMA_V1";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function genericResult_GenericStatusFromJSON(object) {
  switch (object) {
    case 0:
    case "GENERIC_STATUS_UNSPECIFIED":
      return 0 /* GENERIC_STATUS_UNSPECIFIED */;
    case 1:
    case "GENERIC_STATUS_SUCCESS":
      return 1 /* GENERIC_STATUS_SUCCESS */;
    case 2:
    case "GENERIC_STATUS_FAILURE":
      return 2 /* GENERIC_STATUS_FAILURE */;
    case 3:
    case "GENERIC_STATUS_TERMINATED":
      return 3 /* GENERIC_STATUS_TERMINATED */;
    case 4:
    case "GENERIC_STATUS_TIMEOUT":
      return 4 /* GENERIC_STATUS_TIMEOUT */;
    case 5:
    case "GENERIC_STATUS_INIT_FAILURE":
      return 5 /* GENERIC_STATUS_INIT_FAILURE */;
    case 6:
    case "GENERIC_STATUS_INTERNAL_FAILURE":
      return 6 /* GENERIC_STATUS_INTERNAL_FAILURE */;
    case 7:
    case "GENERIC_STATUS_IDLE_TIMEOUT":
      return 7 /* GENERIC_STATUS_IDLE_TIMEOUT */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function genericResult_GenericStatusToJSON(object) {
  switch (object) {
    case 0 /* GENERIC_STATUS_UNSPECIFIED */:
      return "GENERIC_STATUS_UNSPECIFIED";
    case 1 /* GENERIC_STATUS_SUCCESS */:
      return "GENERIC_STATUS_SUCCESS";
    case 2 /* GENERIC_STATUS_FAILURE */:
      return "GENERIC_STATUS_FAILURE";
    case 3 /* GENERIC_STATUS_TERMINATED */:
      return "GENERIC_STATUS_TERMINATED";
    case 4 /* GENERIC_STATUS_TIMEOUT */:
      return "GENERIC_STATUS_TIMEOUT";
    case 5 /* GENERIC_STATUS_INIT_FAILURE */:
      return "GENERIC_STATUS_INIT_FAILURE";
    case 6 /* GENERIC_STATUS_INTERNAL_FAILURE */:
      return "GENERIC_STATUS_INTERNAL_FAILURE";
    case 7 /* GENERIC_STATUS_IDLE_TIMEOUT */:
      return "GENERIC_STATUS_IDLE_TIMEOUT";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function networkAccess_NetworkAccessTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return 0 /* UNSPECIFIED */;
    case 1:
    case "OPEN":
      return 1 /* OPEN */;
    case 2:
    case "BLOCKED":
      return 2 /* BLOCKED */;
    case 3:
    case "ALLOWLIST":
      return 3 /* ALLOWLIST */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function networkAccess_NetworkAccessTypeToJSON(object) {
  switch (object) {
    case 0 /* UNSPECIFIED */:
      return "UNSPECIFIED";
    case 1 /* OPEN */:
      return "OPEN";
    case 2 /* BLOCKED */:
      return "BLOCKED";
    case 3 /* ALLOWLIST */:
      return "ALLOWLIST";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function pTYInfo_PTYTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "PTY_TYPE_UNSPECIFIED":
      return 0 /* PTY_TYPE_UNSPECIFIED */;
    case 1:
    case "PTY_TYPE_FUNCTION":
      return 1 /* PTY_TYPE_FUNCTION */;
    case 2:
    case "PTY_TYPE_SHELL":
      return 2 /* PTY_TYPE_SHELL */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function pTYInfo_PTYTypeToJSON(object) {
  switch (object) {
    case 0 /* PTY_TYPE_UNSPECIFIED */:
      return "PTY_TYPE_UNSPECIFIED";
    case 1 /* PTY_TYPE_FUNCTION */:
      return "PTY_TYPE_FUNCTION";
    case 2 /* PTY_TYPE_SHELL */:
      return "PTY_TYPE_SHELL";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function sandboxRestoreRequest_SandboxNameOverrideTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "SANDBOX_NAME_OVERRIDE_TYPE_UNSPECIFIED":
      return 0 /* SANDBOX_NAME_OVERRIDE_TYPE_UNSPECIFIED */;
    case 1:
    case "SANDBOX_NAME_OVERRIDE_TYPE_NONE":
      return 1 /* SANDBOX_NAME_OVERRIDE_TYPE_NONE */;
    case 2:
    case "SANDBOX_NAME_OVERRIDE_TYPE_STRING":
      return 2 /* SANDBOX_NAME_OVERRIDE_TYPE_STRING */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function sandboxRestoreRequest_SandboxNameOverrideTypeToJSON(object) {
  switch (object) {
    case 0 /* SANDBOX_NAME_OVERRIDE_TYPE_UNSPECIFIED */:
      return "SANDBOX_NAME_OVERRIDE_TYPE_UNSPECIFIED";
    case 1 /* SANDBOX_NAME_OVERRIDE_TYPE_NONE */:
      return "SANDBOX_NAME_OVERRIDE_TYPE_NONE";
    case 2 /* SANDBOX_NAME_OVERRIDE_TYPE_STRING */:
      return "SANDBOX_NAME_OVERRIDE_TYPE_STRING";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function warning_WarningTypeFromJSON(object) {
  switch (object) {
    case 0:
    case "WARNING_TYPE_UNSPECIFIED":
      return 0 /* WARNING_TYPE_UNSPECIFIED */;
    case 1:
    case "WARNING_TYPE_CLIENT_DEPRECATION":
      return 1 /* WARNING_TYPE_CLIENT_DEPRECATION */;
    case 2:
    case "WARNING_TYPE_RESOURCE_LIMIT":
      return 2 /* WARNING_TYPE_RESOURCE_LIMIT */;
    case 3:
    case "WARNING_TYPE_FUNCTION_CONFIGURATION":
      return 3 /* WARNING_TYPE_FUNCTION_CONFIGURATION */;
    case -1:
    case "UNRECOGNIZED":
    default:
      return -1 /* UNRECOGNIZED */;
  }
}
function warning_WarningTypeToJSON(object) {
  switch (object) {
    case 0 /* WARNING_TYPE_UNSPECIFIED */:
      return "WARNING_TYPE_UNSPECIFIED";
    case 1 /* WARNING_TYPE_CLIENT_DEPRECATION */:
      return "WARNING_TYPE_CLIENT_DEPRECATION";
    case 2 /* WARNING_TYPE_RESOURCE_LIMIT */:
      return "WARNING_TYPE_RESOURCE_LIMIT";
    case 3 /* WARNING_TYPE_FUNCTION_CONFIGURATION */:
      return "WARNING_TYPE_FUNCTION_CONFIGURATION";
    case -1 /* UNRECOGNIZED */:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseAppClientDisconnectRequest() {
  return { appId: "", reason: 0, exception: "" };
}
var AppClientDisconnectRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.reason !== 0) {
      writer.uint32(16).int32(message.reason);
    }
    if (message.exception !== "") {
      writer.uint32(26).string(message.exception);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppClientDisconnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.reason = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.exception = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      reason: isSet3(object.reason) ? appDisconnectReasonFromJSON(object.reason) : 0,
      exception: isSet3(object.exception) ? globalThis.String(object.exception) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.reason !== 0) {
      obj.reason = appDisconnectReasonToJSON(message.reason);
    }
    if (message.exception !== "") {
      obj.exception = message.exception;
    }
    return obj;
  },
  create(base) {
    return AppClientDisconnectRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppClientDisconnectRequest();
    message.appId = object.appId ?? "";
    message.reason = object.reason ?? 0;
    message.exception = object.exception ?? "";
    return message;
  }
};
function createBaseAppCreateRequest() {
  return { clientId: "", description: "", environmentName: "", appState: 0 };
}
var AppCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.environmentName !== "") {
      writer.uint32(42).string(message.environmentName);
    }
    if (message.appState !== 0) {
      writer.uint32(48).int32(message.appState);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.appState = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      clientId: isSet3(object.clientId) ? globalThis.String(object.clientId) : "",
      description: isSet3(object.description) ? globalThis.String(object.description) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      appState: isSet3(object.appState) ? appStateFromJSON(object.appState) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.appState !== 0) {
      obj.appState = appStateToJSON(message.appState);
    }
    return obj;
  },
  create(base) {
    return AppCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppCreateRequest();
    message.clientId = object.clientId ?? "";
    message.description = object.description ?? "";
    message.environmentName = object.environmentName ?? "";
    message.appState = object.appState ?? 0;
    return message;
  }
};
function createBaseAppCreateResponse() {
  return { appId: "", appPageUrl: "", appLogsUrl: "" };
}
var AppCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.appPageUrl !== "") {
      writer.uint32(18).string(message.appPageUrl);
    }
    if (message.appLogsUrl !== "") {
      writer.uint32(26).string(message.appLogsUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.appPageUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.appLogsUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      appPageUrl: isSet3(object.appPageUrl) ? globalThis.String(object.appPageUrl) : "",
      appLogsUrl: isSet3(object.appLogsUrl) ? globalThis.String(object.appLogsUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.appPageUrl !== "") {
      obj.appPageUrl = message.appPageUrl;
    }
    if (message.appLogsUrl !== "") {
      obj.appLogsUrl = message.appLogsUrl;
    }
    return obj;
  },
  create(base) {
    return AppCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppCreateResponse();
    message.appId = object.appId ?? "";
    message.appPageUrl = object.appPageUrl ?? "";
    message.appLogsUrl = object.appLogsUrl ?? "";
    return message;
  }
};
function createBaseAppDeployRequest() {
  return { appId: "", name: "", objectEntity: "", visibility: 0, tag: "" };
}
var AppDeployRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.objectEntity !== "") {
      writer.uint32(34).string(message.objectEntity);
    }
    if (message.visibility !== 0) {
      writer.uint32(40).int32(message.visibility);
    }
    if (message.tag !== "") {
      writer.uint32(50).string(message.tag);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppDeployRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.objectEntity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.visibility = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      objectEntity: isSet3(object.objectEntity) ? globalThis.String(object.objectEntity) : "",
      visibility: isSet3(object.visibility) ? appDeployVisibilityFromJSON(object.visibility) : 0,
      tag: isSet3(object.tag) ? globalThis.String(object.tag) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.objectEntity !== "") {
      obj.objectEntity = message.objectEntity;
    }
    if (message.visibility !== 0) {
      obj.visibility = appDeployVisibilityToJSON(message.visibility);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },
  create(base) {
    return AppDeployRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppDeployRequest();
    message.appId = object.appId ?? "";
    message.name = object.name ?? "";
    message.objectEntity = object.objectEntity ?? "";
    message.visibility = object.visibility ?? 0;
    message.tag = object.tag ?? "";
    return message;
  }
};
function createBaseAppDeployResponse() {
  return { url: "" };
}
var AppDeployResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppDeployResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { url: isSet3(object.url) ? globalThis.String(object.url) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return AppDeployResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppDeployResponse();
    message.url = object.url ?? "";
    return message;
  }
};
function createBaseAppDeploymentHistory() {
  return {
    appId: "",
    version: 0,
    clientVersion: "",
    deployedAt: 0,
    deployedBy: "",
    deployedByAvatarUrl: "",
    tag: "",
    rollbackVersion: 0,
    rollbackAllowed: false,
    commitInfo: void 0
  };
}
var AppDeploymentHistory = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.version !== 0) {
      writer.uint32(16).uint32(message.version);
    }
    if (message.clientVersion !== "") {
      writer.uint32(26).string(message.clientVersion);
    }
    if (message.deployedAt !== 0) {
      writer.uint32(33).double(message.deployedAt);
    }
    if (message.deployedBy !== "") {
      writer.uint32(42).string(message.deployedBy);
    }
    if (message.deployedByAvatarUrl !== "") {
      writer.uint32(74).string(message.deployedByAvatarUrl);
    }
    if (message.tag !== "") {
      writer.uint32(50).string(message.tag);
    }
    if (message.rollbackVersion !== 0) {
      writer.uint32(56).uint32(message.rollbackVersion);
    }
    if (message.rollbackAllowed !== false) {
      writer.uint32(64).bool(message.rollbackAllowed);
    }
    if (message.commitInfo !== void 0) {
      CommitInfo.encode(message.commitInfo, writer.uint32(82).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppDeploymentHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.version = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.clientVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }
          message.deployedAt = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.deployedBy = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.deployedByAvatarUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.tag = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.rollbackVersion = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.rollbackAllowed = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.commitInfo = CommitInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      version: isSet3(object.version) ? globalThis.Number(object.version) : 0,
      clientVersion: isSet3(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      deployedAt: isSet3(object.deployedAt) ? globalThis.Number(object.deployedAt) : 0,
      deployedBy: isSet3(object.deployedBy) ? globalThis.String(object.deployedBy) : "",
      deployedByAvatarUrl: isSet3(object.deployedByAvatarUrl) ? globalThis.String(object.deployedByAvatarUrl) : "",
      tag: isSet3(object.tag) ? globalThis.String(object.tag) : "",
      rollbackVersion: isSet3(object.rollbackVersion) ? globalThis.Number(object.rollbackVersion) : 0,
      rollbackAllowed: isSet3(object.rollbackAllowed) ? globalThis.Boolean(object.rollbackAllowed) : false,
      commitInfo: isSet3(object.commitInfo) ? CommitInfo.fromJSON(object.commitInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.deployedAt !== 0) {
      obj.deployedAt = message.deployedAt;
    }
    if (message.deployedBy !== "") {
      obj.deployedBy = message.deployedBy;
    }
    if (message.deployedByAvatarUrl !== "") {
      obj.deployedByAvatarUrl = message.deployedByAvatarUrl;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.rollbackVersion !== 0) {
      obj.rollbackVersion = Math.round(message.rollbackVersion);
    }
    if (message.rollbackAllowed !== false) {
      obj.rollbackAllowed = message.rollbackAllowed;
    }
    if (message.commitInfo !== void 0) {
      obj.commitInfo = CommitInfo.toJSON(message.commitInfo);
    }
    return obj;
  },
  create(base) {
    return AppDeploymentHistory.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppDeploymentHistory();
    message.appId = object.appId ?? "";
    message.version = object.version ?? 0;
    message.clientVersion = object.clientVersion ?? "";
    message.deployedAt = object.deployedAt ?? 0;
    message.deployedBy = object.deployedBy ?? "";
    message.deployedByAvatarUrl = object.deployedByAvatarUrl ?? "";
    message.tag = object.tag ?? "";
    message.rollbackVersion = object.rollbackVersion ?? 0;
    message.rollbackAllowed = object.rollbackAllowed ?? false;
    message.commitInfo = object.commitInfo !== void 0 && object.commitInfo !== null ? CommitInfo.fromPartial(object.commitInfo) : void 0;
    return message;
  }
};
function createBaseAppDeploymentHistoryRequest() {
  return { appId: "" };
}
var AppDeploymentHistoryRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppDeploymentHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet3(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppDeploymentHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppDeploymentHistoryRequest();
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseAppDeploymentHistoryResponse() {
  return { appDeploymentHistories: [] };
}
var AppDeploymentHistoryResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.appDeploymentHistories) {
      AppDeploymentHistory.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppDeploymentHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appDeploymentHistories.push(AppDeploymentHistory.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appDeploymentHistories: globalThis.Array.isArray(object?.appDeploymentHistories) ? object.appDeploymentHistories.map((e) => AppDeploymentHistory.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appDeploymentHistories?.length) {
      obj.appDeploymentHistories = message.appDeploymentHistories.map((e) => AppDeploymentHistory.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AppDeploymentHistoryResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppDeploymentHistoryResponse();
    message.appDeploymentHistories = object.appDeploymentHistories?.map((e) => AppDeploymentHistory.fromPartial(e)) || [];
    return message;
  }
};
function createBaseAppGetByDeploymentNameRequest() {
  return { name: "", environmentName: "" };
}
var AppGetByDeploymentNameRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.environmentName !== "") {
      writer.uint32(34).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetByDeploymentNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return AppGetByDeploymentNameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetByDeploymentNameRequest();
    message.name = object.name ?? "";
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseAppGetByDeploymentNameResponse() {
  return { appId: "" };
}
var AppGetByDeploymentNameResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetByDeploymentNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet3(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppGetByDeploymentNameResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetByDeploymentNameResponse();
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseAppGetLayoutRequest() {
  return { appId: "" };
}
var AppGetLayoutRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet3(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppGetLayoutRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetLayoutRequest();
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseAppGetLayoutResponse() {
  return { appLayout: void 0 };
}
var AppGetLayoutResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appLayout !== void 0) {
      AppLayout.encode(message.appLayout, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetLayoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appLayout = AppLayout.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appLayout: isSet3(object.appLayout) ? AppLayout.fromJSON(object.appLayout) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.appLayout !== void 0) {
      obj.appLayout = AppLayout.toJSON(message.appLayout);
    }
    return obj;
  },
  create(base) {
    return AppGetLayoutResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetLayoutResponse();
    message.appLayout = object.appLayout !== void 0 && object.appLayout !== null ? AppLayout.fromPartial(object.appLayout) : void 0;
    return message;
  }
};
function createBaseAppGetLogsRequest() {
  return {
    appId: "",
    timeout: 0,
    lastEntryId: "",
    functionId: "",
    inputId: "",
    taskId: "",
    functionCallId: "",
    fileDescriptor: 0,
    sandboxId: ""
  };
}
var AppGetLogsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    if (message.lastEntryId !== "") {
      writer.uint32(34).string(message.lastEntryId);
    }
    if (message.functionId !== "") {
      writer.uint32(42).string(message.functionId);
    }
    if (message.inputId !== "") {
      writer.uint32(50).string(message.inputId);
    }
    if (message.taskId !== "") {
      writer.uint32(58).string(message.taskId);
    }
    if (message.functionCallId !== "") {
      writer.uint32(74).string(message.functionCallId);
    }
    if (message.fileDescriptor !== 0) {
      writer.uint32(64).int32(message.fileDescriptor);
    }
    if (message.sandboxId !== "") {
      writer.uint32(82).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.fileDescriptor = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      fileDescriptor: isSet3(object.fileDescriptor) ? fileDescriptorFromJSON(object.fileDescriptor) : 0,
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.fileDescriptor !== 0) {
      obj.fileDescriptor = fileDescriptorToJSON(message.fileDescriptor);
    }
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return AppGetLogsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetLogsRequest();
    message.appId = object.appId ?? "";
    message.timeout = object.timeout ?? 0;
    message.lastEntryId = object.lastEntryId ?? "";
    message.functionId = object.functionId ?? "";
    message.inputId = object.inputId ?? "";
    message.taskId = object.taskId ?? "";
    message.functionCallId = object.functionCallId ?? "";
    message.fileDescriptor = object.fileDescriptor ?? 0;
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseAppGetObjectsItem() {
  return { tag: "", object: void 0 };
}
var AppGetObjectsItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.object !== void 0) {
      Object_.encode(message.object, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetObjectsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.object = Object_.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tag: isSet3(object.tag) ? globalThis.String(object.tag) : "",
      object: isSet3(object.object) ? Object_.fromJSON(object.object) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.object !== void 0) {
      obj.object = Object_.toJSON(message.object);
    }
    return obj;
  },
  create(base) {
    return AppGetObjectsItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetObjectsItem();
    message.tag = object.tag ?? "";
    message.object = object.object !== void 0 && object.object !== null ? Object_.fromPartial(object.object) : void 0;
    return message;
  }
};
function createBaseAppGetObjectsRequest() {
  return { appId: "", includeUnindexed: false, onlyClassFunction: false };
}
var AppGetObjectsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.includeUnindexed !== false) {
      writer.uint32(16).bool(message.includeUnindexed);
    }
    if (message.onlyClassFunction !== false) {
      writer.uint32(24).bool(message.onlyClassFunction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetObjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.includeUnindexed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.onlyClassFunction = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      includeUnindexed: isSet3(object.includeUnindexed) ? globalThis.Boolean(object.includeUnindexed) : false,
      onlyClassFunction: isSet3(object.onlyClassFunction) ? globalThis.Boolean(object.onlyClassFunction) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.includeUnindexed !== false) {
      obj.includeUnindexed = message.includeUnindexed;
    }
    if (message.onlyClassFunction !== false) {
      obj.onlyClassFunction = message.onlyClassFunction;
    }
    return obj;
  },
  create(base) {
    return AppGetObjectsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetObjectsRequest();
    message.appId = object.appId ?? "";
    message.includeUnindexed = object.includeUnindexed ?? false;
    message.onlyClassFunction = object.onlyClassFunction ?? false;
    return message;
  }
};
function createBaseAppGetObjectsResponse() {
  return { items: [] };
}
var AppGetObjectsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      AppGetObjectsItem.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetObjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.items.push(AppGetObjectsItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => AppGetObjectsItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => AppGetObjectsItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AppGetObjectsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetObjectsResponse();
    message.items = object.items?.map((e) => AppGetObjectsItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseAppGetOrCreateRequest() {
  return { appName: "", environmentName: "", objectCreationType: 0 };
}
var AppGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appName !== "") {
      writer.uint32(10).string(message.appName);
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(24).int32(message.objectCreationType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appName: isSet3(object.appName) ? globalThis.String(object.appName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    return obj;
  },
  create(base) {
    return AppGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetOrCreateRequest();
    message.appName = object.appName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    return message;
  }
};
function createBaseAppGetOrCreateResponse() {
  return { appId: "" };
}
var AppGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet3(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppGetOrCreateResponse();
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseAppHeartbeatRequest() {
  return { appId: "" };
}
var AppHeartbeatRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet3(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppHeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppHeartbeatRequest();
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseAppLayout() {
  return { objects: [], functionIds: {}, classIds: {} };
}
var AppLayout = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.objects) {
      Object_.encode(v, writer.uint32(10).fork()).join();
    }
    Object.entries(message.functionIds).forEach(([key, value]) => {
      AppLayout_FunctionIdsEntry.encode({ key, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.classIds).forEach(([key, value]) => {
      AppLayout_ClassIdsEntry.encode({ key, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.objects.push(Object_.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          const entry2 = AppLayout_FunctionIdsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.functionIds[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          const entry3 = AppLayout_ClassIdsEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.classIds[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      objects: globalThis.Array.isArray(object?.objects) ? object.objects.map((e) => Object_.fromJSON(e)) : [],
      functionIds: isObject2(object.functionIds) ? Object.entries(object.functionIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      classIds: isObject2(object.classIds) ? Object.entries(object.classIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => Object_.toJSON(e));
    }
    if (message.functionIds) {
      const entries = Object.entries(message.functionIds);
      if (entries.length > 0) {
        obj.functionIds = {};
        entries.forEach(([k, v]) => {
          obj.functionIds[k] = v;
        });
      }
    }
    if (message.classIds) {
      const entries = Object.entries(message.classIds);
      if (entries.length > 0) {
        obj.classIds = {};
        entries.forEach(([k, v]) => {
          obj.classIds[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return AppLayout.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppLayout();
    message.objects = object.objects?.map((e) => Object_.fromPartial(e)) || [];
    message.functionIds = Object.entries(object.functionIds ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.classIds = Object.entries(object.classIds ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseAppLayout_FunctionIdsEntry() {
  return { key: "", value: "" };
}
var AppLayout_FunctionIdsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppLayout_FunctionIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return AppLayout_FunctionIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppLayout_FunctionIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseAppLayout_ClassIdsEntry() {
  return { key: "", value: "" };
}
var AppLayout_ClassIdsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppLayout_ClassIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return AppLayout_ClassIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppLayout_ClassIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseAppListRequest() {
  return { environmentName: "" };
}
var AppListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return AppListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppListRequest();
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseAppListResponse() {
  return { apps: [] };
}
var AppListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.apps) {
      AppListResponse_AppListItem.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.apps.push(AppListResponse_AppListItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      apps: globalThis.Array.isArray(object?.apps) ? object.apps.map((e) => AppListResponse_AppListItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.apps?.length) {
      obj.apps = message.apps.map((e) => AppListResponse_AppListItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AppListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppListResponse();
    message.apps = object.apps?.map((e) => AppListResponse_AppListItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseAppListResponse_AppListItem() {
  return { appId: "", description: "", state: 0, createdAt: 0, stoppedAt: 0, nRunningTasks: 0, name: "" };
}
var AppListResponse_AppListItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.createdAt !== 0) {
      writer.uint32(41).double(message.createdAt);
    }
    if (message.stoppedAt !== 0) {
      writer.uint32(49).double(message.stoppedAt);
    }
    if (message.nRunningTasks !== 0) {
      writer.uint32(64).int32(message.nRunningTasks);
    }
    if (message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppListResponse_AppListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.state = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }
          message.stoppedAt = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.nRunningTasks = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      description: isSet3(object.description) ? globalThis.String(object.description) : "",
      state: isSet3(object.state) ? appStateFromJSON(object.state) : 0,
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      stoppedAt: isSet3(object.stoppedAt) ? globalThis.Number(object.stoppedAt) : 0,
      nRunningTasks: isSet3(object.nRunningTasks) ? globalThis.Number(object.nRunningTasks) : 0,
      name: isSet3(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = appStateToJSON(message.state);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.stoppedAt !== 0) {
      obj.stoppedAt = message.stoppedAt;
    }
    if (message.nRunningTasks !== 0) {
      obj.nRunningTasks = Math.round(message.nRunningTasks);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return AppListResponse_AppListItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppListResponse_AppListItem();
    message.appId = object.appId ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.stoppedAt = object.stoppedAt ?? 0;
    message.nRunningTasks = object.nRunningTasks ?? 0;
    message.name = object.name ?? "";
    return message;
  }
};
function createBaseAppLookupRequest() {
  return { appName: "", environmentName: "" };
}
var AppLookupRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appName !== "") {
      writer.uint32(18).string(message.appName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppLookupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.appName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appName: isSet3(object.appName) ? globalThis.String(object.appName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return AppLookupRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppLookupRequest();
    message.appName = object.appName ?? "";
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseAppLookupResponse() {
  return { appId: "" };
}
var AppLookupResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppLookupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { appId: isSet3(object.appId) ? globalThis.String(object.appId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return AppLookupResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppLookupResponse();
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseAppPublishRequest() {
  return {
    appId: "",
    name: "",
    deploymentTag: "",
    appState: 0,
    functionIds: {},
    classIds: {},
    definitionIds: {},
    rollbackVersion: 0,
    clientVersion: "",
    commitInfo: void 0
  };
}
var AppPublishRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.deploymentTag !== "") {
      writer.uint32(26).string(message.deploymentTag);
    }
    if (message.appState !== 0) {
      writer.uint32(32).int32(message.appState);
    }
    Object.entries(message.functionIds).forEach(([key, value]) => {
      AppPublishRequest_FunctionIdsEntry.encode({ key, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.classIds).forEach(([key, value]) => {
      AppPublishRequest_ClassIdsEntry.encode({ key, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.definitionIds).forEach(([key, value]) => {
      AppPublishRequest_DefinitionIdsEntry.encode({ key, value }, writer.uint32(58).fork()).join();
    });
    if (message.rollbackVersion !== 0) {
      writer.uint32(64).uint32(message.rollbackVersion);
    }
    if (message.clientVersion !== "") {
      writer.uint32(74).string(message.clientVersion);
    }
    if (message.commitInfo !== void 0) {
      CommitInfo.encode(message.commitInfo, writer.uint32(82).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.deploymentTag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.appState = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          const entry5 = AppPublishRequest_FunctionIdsEntry.decode(reader, reader.uint32());
          if (entry5.value !== void 0) {
            message.functionIds[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          const entry6 = AppPublishRequest_ClassIdsEntry.decode(reader, reader.uint32());
          if (entry6.value !== void 0) {
            message.classIds[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          const entry7 = AppPublishRequest_DefinitionIdsEntry.decode(reader, reader.uint32());
          if (entry7.value !== void 0) {
            message.definitionIds[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.rollbackVersion = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.clientVersion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.commitInfo = CommitInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      deploymentTag: isSet3(object.deploymentTag) ? globalThis.String(object.deploymentTag) : "",
      appState: isSet3(object.appState) ? appStateFromJSON(object.appState) : 0,
      functionIds: isObject2(object.functionIds) ? Object.entries(object.functionIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      classIds: isObject2(object.classIds) ? Object.entries(object.classIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      definitionIds: isObject2(object.definitionIds) ? Object.entries(object.definitionIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      rollbackVersion: isSet3(object.rollbackVersion) ? globalThis.Number(object.rollbackVersion) : 0,
      clientVersion: isSet3(object.clientVersion) ? globalThis.String(object.clientVersion) : "",
      commitInfo: isSet3(object.commitInfo) ? CommitInfo.fromJSON(object.commitInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.deploymentTag !== "") {
      obj.deploymentTag = message.deploymentTag;
    }
    if (message.appState !== 0) {
      obj.appState = appStateToJSON(message.appState);
    }
    if (message.functionIds) {
      const entries = Object.entries(message.functionIds);
      if (entries.length > 0) {
        obj.functionIds = {};
        entries.forEach(([k, v]) => {
          obj.functionIds[k] = v;
        });
      }
    }
    if (message.classIds) {
      const entries = Object.entries(message.classIds);
      if (entries.length > 0) {
        obj.classIds = {};
        entries.forEach(([k, v]) => {
          obj.classIds[k] = v;
        });
      }
    }
    if (message.definitionIds) {
      const entries = Object.entries(message.definitionIds);
      if (entries.length > 0) {
        obj.definitionIds = {};
        entries.forEach(([k, v]) => {
          obj.definitionIds[k] = v;
        });
      }
    }
    if (message.rollbackVersion !== 0) {
      obj.rollbackVersion = Math.round(message.rollbackVersion);
    }
    if (message.clientVersion !== "") {
      obj.clientVersion = message.clientVersion;
    }
    if (message.commitInfo !== void 0) {
      obj.commitInfo = CommitInfo.toJSON(message.commitInfo);
    }
    return obj;
  },
  create(base) {
    return AppPublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppPublishRequest();
    message.appId = object.appId ?? "";
    message.name = object.name ?? "";
    message.deploymentTag = object.deploymentTag ?? "";
    message.appState = object.appState ?? 0;
    message.functionIds = Object.entries(object.functionIds ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.classIds = Object.entries(object.classIds ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.definitionIds = Object.entries(object.definitionIds ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.rollbackVersion = object.rollbackVersion ?? 0;
    message.clientVersion = object.clientVersion ?? "";
    message.commitInfo = object.commitInfo !== void 0 && object.commitInfo !== null ? CommitInfo.fromPartial(object.commitInfo) : void 0;
    return message;
  }
};
function createBaseAppPublishRequest_FunctionIdsEntry() {
  return { key: "", value: "" };
}
var AppPublishRequest_FunctionIdsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppPublishRequest_FunctionIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return AppPublishRequest_FunctionIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppPublishRequest_FunctionIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseAppPublishRequest_ClassIdsEntry() {
  return { key: "", value: "" };
}
var AppPublishRequest_ClassIdsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppPublishRequest_ClassIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return AppPublishRequest_ClassIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppPublishRequest_ClassIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseAppPublishRequest_DefinitionIdsEntry() {
  return { key: "", value: "" };
}
var AppPublishRequest_DefinitionIdsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppPublishRequest_DefinitionIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return AppPublishRequest_DefinitionIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppPublishRequest_DefinitionIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseAppPublishResponse() {
  return { url: "", serverWarnings: [] };
}
var AppPublishResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    for (const v of message.serverWarnings) {
      Warning.encode(v, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppPublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.serverWarnings.push(Warning.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet3(object.url) ? globalThis.String(object.url) : "",
      serverWarnings: globalThis.Array.isArray(object?.serverWarnings) ? object.serverWarnings.map((e) => Warning.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.serverWarnings?.length) {
      obj.serverWarnings = message.serverWarnings.map((e) => Warning.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return AppPublishResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppPublishResponse();
    message.url = object.url ?? "";
    message.serverWarnings = object.serverWarnings?.map((e) => Warning.fromPartial(e)) || [];
    return message;
  }
};
function createBaseAppRollbackRequest() {
  return { appId: "", version: 0 };
}
var AppRollbackRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppRollbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.version = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      version: isSet3(object.version) ? globalThis.Number(object.version) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },
  create(base) {
    return AppRollbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppRollbackRequest();
    message.appId = object.appId ?? "";
    message.version = object.version ?? 0;
    return message;
  }
};
function createBaseAppSetObjectsRequest() {
  return { appId: "", indexedObjectIds: {}, clientId: "", unindexedObjectIds: [], newAppState: 0 };
}
var AppSetObjectsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    Object.entries(message.indexedObjectIds).forEach(([key, value]) => {
      AppSetObjectsRequest_IndexedObjectIdsEntry.encode({ key, value }, writer.uint32(18).fork()).join();
    });
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    for (const v of message.unindexedObjectIds) {
      writer.uint32(34).string(v);
    }
    if (message.newAppState !== 0) {
      writer.uint32(40).int32(message.newAppState);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSetObjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          const entry2 = AppSetObjectsRequest_IndexedObjectIdsEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.indexedObjectIds[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.unindexedObjectIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.newAppState = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      indexedObjectIds: isObject2(object.indexedObjectIds) ? Object.entries(object.indexedObjectIds).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      clientId: isSet3(object.clientId) ? globalThis.String(object.clientId) : "",
      unindexedObjectIds: globalThis.Array.isArray(object?.unindexedObjectIds) ? object.unindexedObjectIds.map((e) => globalThis.String(e)) : [],
      newAppState: isSet3(object.newAppState) ? appStateFromJSON(object.newAppState) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.indexedObjectIds) {
      const entries = Object.entries(message.indexedObjectIds);
      if (entries.length > 0) {
        obj.indexedObjectIds = {};
        entries.forEach(([k, v]) => {
          obj.indexedObjectIds[k] = v;
        });
      }
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.unindexedObjectIds?.length) {
      obj.unindexedObjectIds = message.unindexedObjectIds;
    }
    if (message.newAppState !== 0) {
      obj.newAppState = appStateToJSON(message.newAppState);
    }
    return obj;
  },
  create(base) {
    return AppSetObjectsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppSetObjectsRequest();
    message.appId = object.appId ?? "";
    message.indexedObjectIds = Object.entries(object.indexedObjectIds ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.clientId = object.clientId ?? "";
    message.unindexedObjectIds = object.unindexedObjectIds?.map((e) => e) || [];
    message.newAppState = object.newAppState ?? 0;
    return message;
  }
};
function createBaseAppSetObjectsRequest_IndexedObjectIdsEntry() {
  return { key: "", value: "" };
}
var AppSetObjectsRequest_IndexedObjectIdsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppSetObjectsRequest_IndexedObjectIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return AppSetObjectsRequest_IndexedObjectIdsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppSetObjectsRequest_IndexedObjectIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseAppStopRequest() {
  return { appId: "", source: 0 };
}
var AppStopRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.source !== 0) {
      writer.uint32(16).int32(message.source);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAppStopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.source = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      source: isSet3(object.source) ? appStopSourceFromJSON(object.source) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.source !== 0) {
      obj.source = appStopSourceToJSON(message.source);
    }
    return obj;
  },
  create(base) {
    return AppStopRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAppStopRequest();
    message.appId = object.appId ?? "";
    message.source = object.source ?? 0;
    return message;
  }
};
function createBaseAttemptAwaitRequest() {
  return { attemptToken: "", requestedAt: 0, timeoutSecs: 0 };
}
var AttemptAwaitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.attemptToken !== "") {
      writer.uint32(10).string(message.attemptToken);
    }
    if (message.requestedAt !== 0) {
      writer.uint32(17).double(message.requestedAt);
    }
    if (message.timeoutSecs !== 0) {
      writer.uint32(29).float(message.timeoutSecs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAttemptAwaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.requestedAt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.timeoutSecs = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : "",
      requestedAt: isSet3(object.requestedAt) ? globalThis.Number(object.requestedAt) : 0,
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.attemptToken !== "") {
      obj.attemptToken = message.attemptToken;
    }
    if (message.requestedAt !== 0) {
      obj.requestedAt = message.requestedAt;
    }
    if (message.timeoutSecs !== 0) {
      obj.timeoutSecs = message.timeoutSecs;
    }
    return obj;
  },
  create(base) {
    return AttemptAwaitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAttemptAwaitRequest();
    message.attemptToken = object.attemptToken ?? "";
    message.requestedAt = object.requestedAt ?? 0;
    message.timeoutSecs = object.timeoutSecs ?? 0;
    return message;
  }
};
function createBaseAttemptAwaitResponse() {
  return { output: void 0 };
}
var AttemptAwaitResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.output !== void 0) {
      FunctionGetOutputsItem.encode(message.output, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAttemptAwaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.output = FunctionGetOutputsItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { output: isSet3(object.output) ? FunctionGetOutputsItem.fromJSON(object.output) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.output !== void 0) {
      obj.output = FunctionGetOutputsItem.toJSON(message.output);
    }
    return obj;
  },
  create(base) {
    return AttemptAwaitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAttemptAwaitResponse();
    message.output = object.output !== void 0 && object.output !== null ? FunctionGetOutputsItem.fromPartial(object.output) : void 0;
    return message;
  }
};
function createBaseAttemptRetryRequest() {
  return { functionId: "", parentInputId: "", input: void 0, attemptToken: "" };
}
var AttemptRetryRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.parentInputId !== "") {
      writer.uint32(18).string(message.parentInputId);
    }
    if (message.input !== void 0) {
      FunctionPutInputsItem.encode(message.input, writer.uint32(26).fork()).join();
    }
    if (message.attemptToken !== "") {
      writer.uint32(34).string(message.attemptToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAttemptRetryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.parentInputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.input = FunctionPutInputsItem.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      parentInputId: isSet3(object.parentInputId) ? globalThis.String(object.parentInputId) : "",
      input: isSet3(object.input) ? FunctionPutInputsItem.fromJSON(object.input) : void 0,
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.parentInputId !== "") {
      obj.parentInputId = message.parentInputId;
    }
    if (message.input !== void 0) {
      obj.input = FunctionPutInputsItem.toJSON(message.input);
    }
    if (message.attemptToken !== "") {
      obj.attemptToken = message.attemptToken;
    }
    return obj;
  },
  create(base) {
    return AttemptRetryRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAttemptRetryRequest();
    message.functionId = object.functionId ?? "";
    message.parentInputId = object.parentInputId ?? "";
    message.input = object.input !== void 0 && object.input !== null ? FunctionPutInputsItem.fromPartial(object.input) : void 0;
    message.attemptToken = object.attemptToken ?? "";
    return message;
  }
};
function createBaseAttemptRetryResponse() {
  return { attemptToken: "" };
}
var AttemptRetryResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.attemptToken !== "") {
      writer.uint32(10).string(message.attemptToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAttemptRetryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.attemptToken !== "") {
      obj.attemptToken = message.attemptToken;
    }
    return obj;
  },
  create(base) {
    return AttemptRetryResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAttemptRetryResponse();
    message.attemptToken = object.attemptToken ?? "";
    return message;
  }
};
function createBaseAttemptStartRequest() {
  return { functionId: "", parentInputId: "", input: void 0 };
}
var AttemptStartRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.parentInputId !== "") {
      writer.uint32(18).string(message.parentInputId);
    }
    if (message.input !== void 0) {
      FunctionPutInputsItem.encode(message.input, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAttemptStartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.parentInputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.input = FunctionPutInputsItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      parentInputId: isSet3(object.parentInputId) ? globalThis.String(object.parentInputId) : "",
      input: isSet3(object.input) ? FunctionPutInputsItem.fromJSON(object.input) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.parentInputId !== "") {
      obj.parentInputId = message.parentInputId;
    }
    if (message.input !== void 0) {
      obj.input = FunctionPutInputsItem.toJSON(message.input);
    }
    return obj;
  },
  create(base) {
    return AttemptStartRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAttemptStartRequest();
    message.functionId = object.functionId ?? "";
    message.parentInputId = object.parentInputId ?? "";
    message.input = object.input !== void 0 && object.input !== null ? FunctionPutInputsItem.fromPartial(object.input) : void 0;
    return message;
  }
};
function createBaseAttemptStartResponse() {
  return { attemptToken: "", retryPolicy: void 0 };
}
var AttemptStartResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.attemptToken !== "") {
      writer.uint32(10).string(message.attemptToken);
    }
    if (message.retryPolicy !== void 0) {
      FunctionRetryPolicy.encode(message.retryPolicy, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAttemptStartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.retryPolicy = FunctionRetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : "",
      retryPolicy: isSet3(object.retryPolicy) ? FunctionRetryPolicy.fromJSON(object.retryPolicy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.attemptToken !== "") {
      obj.attemptToken = message.attemptToken;
    }
    if (message.retryPolicy !== void 0) {
      obj.retryPolicy = FunctionRetryPolicy.toJSON(message.retryPolicy);
    }
    return obj;
  },
  create(base) {
    return AttemptStartResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAttemptStartResponse();
    message.attemptToken = object.attemptToken ?? "";
    message.retryPolicy = object.retryPolicy !== void 0 && object.retryPolicy !== null ? FunctionRetryPolicy.fromPartial(object.retryPolicy) : void 0;
    return message;
  }
};
function createBaseAuthTokenGetRequest() {
  return {};
}
var AuthTokenGetRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthTokenGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return AuthTokenGetRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseAuthTokenGetRequest();
    return message;
  }
};
function createBaseAuthTokenGetResponse() {
  return { token: "" };
}
var AuthTokenGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAuthTokenGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { token: isSet3(object.token) ? globalThis.String(object.token) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },
  create(base) {
    return AuthTokenGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAuthTokenGetResponse();
    message.token = object.token ?? "";
    return message;
  }
};
function createBaseAutoscalerSettings() {
  return {
    minContainers: void 0,
    maxContainers: void 0,
    bufferContainers: void 0,
    scaleupWindow: void 0,
    scaledownWindow: void 0
  };
}
var AutoscalerSettings = {
  encode(message, writer = new BinaryWriter()) {
    if (message.minContainers !== void 0) {
      writer.uint32(8).uint32(message.minContainers);
    }
    if (message.maxContainers !== void 0) {
      writer.uint32(16).uint32(message.maxContainers);
    }
    if (message.bufferContainers !== void 0) {
      writer.uint32(24).uint32(message.bufferContainers);
    }
    if (message.scaleupWindow !== void 0) {
      writer.uint32(32).uint32(message.scaleupWindow);
    }
    if (message.scaledownWindow !== void 0) {
      writer.uint32(40).uint32(message.scaledownWindow);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutoscalerSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.minContainers = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.maxContainers = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.bufferContainers = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.scaleupWindow = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.scaledownWindow = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      minContainers: isSet3(object.minContainers) ? globalThis.Number(object.minContainers) : void 0,
      maxContainers: isSet3(object.maxContainers) ? globalThis.Number(object.maxContainers) : void 0,
      bufferContainers: isSet3(object.bufferContainers) ? globalThis.Number(object.bufferContainers) : void 0,
      scaleupWindow: isSet3(object.scaleupWindow) ? globalThis.Number(object.scaleupWindow) : void 0,
      scaledownWindow: isSet3(object.scaledownWindow) ? globalThis.Number(object.scaledownWindow) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.minContainers !== void 0) {
      obj.minContainers = Math.round(message.minContainers);
    }
    if (message.maxContainers !== void 0) {
      obj.maxContainers = Math.round(message.maxContainers);
    }
    if (message.bufferContainers !== void 0) {
      obj.bufferContainers = Math.round(message.bufferContainers);
    }
    if (message.scaleupWindow !== void 0) {
      obj.scaleupWindow = Math.round(message.scaleupWindow);
    }
    if (message.scaledownWindow !== void 0) {
      obj.scaledownWindow = Math.round(message.scaledownWindow);
    }
    return obj;
  },
  create(base) {
    return AutoscalerSettings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutoscalerSettings();
    message.minContainers = object.minContainers ?? void 0;
    message.maxContainers = object.maxContainers ?? void 0;
    message.bufferContainers = object.bufferContainers ?? void 0;
    message.scaleupWindow = object.scaleupWindow ?? void 0;
    message.scaledownWindow = object.scaledownWindow ?? void 0;
    return message;
  }
};
function createBaseAutoscalingMetrics() {
  return { cpuUsagePercent: 0, memoryUsagePercent: 0, concurrentRequests: 0, timestamp: 0 };
}
var AutoscalingMetrics = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cpuUsagePercent !== 0) {
      writer.uint32(9).double(message.cpuUsagePercent);
    }
    if (message.memoryUsagePercent !== 0) {
      writer.uint32(17).double(message.memoryUsagePercent);
    }
    if (message.concurrentRequests !== 0) {
      writer.uint32(24).uint32(message.concurrentRequests);
    }
    if (message.timestamp !== 0) {
      writer.uint32(33).double(message.timestamp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }
          message.cpuUsagePercent = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.memoryUsagePercent = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.concurrentRequests = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }
          message.timestamp = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cpuUsagePercent: isSet3(object.cpuUsagePercent) ? globalThis.Number(object.cpuUsagePercent) : 0,
      memoryUsagePercent: isSet3(object.memoryUsagePercent) ? globalThis.Number(object.memoryUsagePercent) : 0,
      concurrentRequests: isSet3(object.concurrentRequests) ? globalThis.Number(object.concurrentRequests) : 0,
      timestamp: isSet3(object.timestamp) ? globalThis.Number(object.timestamp) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cpuUsagePercent !== 0) {
      obj.cpuUsagePercent = message.cpuUsagePercent;
    }
    if (message.memoryUsagePercent !== 0) {
      obj.memoryUsagePercent = message.memoryUsagePercent;
    }
    if (message.concurrentRequests !== 0) {
      obj.concurrentRequests = Math.round(message.concurrentRequests);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },
  create(base) {
    return AutoscalingMetrics.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseAutoscalingMetrics();
    message.cpuUsagePercent = object.cpuUsagePercent ?? 0;
    message.memoryUsagePercent = object.memoryUsagePercent ?? 0;
    message.concurrentRequests = object.concurrentRequests ?? 0;
    message.timestamp = object.timestamp ?? 0;
    return message;
  }
};
function createBaseBaseImage() {
  return { imageId: "", dockerTag: "" };
}
var BaseImage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    if (message.dockerTag !== "") {
      writer.uint32(18).string(message.dockerTag);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dockerTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      dockerTag: isSet3(object.dockerTag) ? globalThis.String(object.dockerTag) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.dockerTag !== "") {
      obj.dockerTag = message.dockerTag;
    }
    return obj;
  },
  create(base) {
    return BaseImage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBaseImage();
    message.imageId = object.imageId ?? "";
    message.dockerTag = object.dockerTag ?? "";
    return message;
  }
};
function createBaseBlobCreateRequest() {
  return { contentMd5: "", contentSha256Base64: "", contentLength: 0 };
}
var BlobCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.contentMd5 !== "") {
      writer.uint32(10).string(message.contentMd5);
    }
    if (message.contentSha256Base64 !== "") {
      writer.uint32(18).string(message.contentSha256Base64);
    }
    if (message.contentLength !== 0) {
      writer.uint32(24).int64(message.contentLength);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlobCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.contentMd5 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.contentSha256Base64 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.contentLength = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contentMd5: isSet3(object.contentMd5) ? globalThis.String(object.contentMd5) : "",
      contentSha256Base64: isSet3(object.contentSha256Base64) ? globalThis.String(object.contentSha256Base64) : "",
      contentLength: isSet3(object.contentLength) ? globalThis.Number(object.contentLength) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contentMd5 !== "") {
      obj.contentMd5 = message.contentMd5;
    }
    if (message.contentSha256Base64 !== "") {
      obj.contentSha256Base64 = message.contentSha256Base64;
    }
    if (message.contentLength !== 0) {
      obj.contentLength = Math.round(message.contentLength);
    }
    return obj;
  },
  create(base) {
    return BlobCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlobCreateRequest();
    message.contentMd5 = object.contentMd5 ?? "";
    message.contentSha256Base64 = object.contentSha256Base64 ?? "";
    message.contentLength = object.contentLength ?? 0;
    return message;
  }
};
function createBaseBlobCreateResponse() {
  return {
    blobId: "",
    uploadUrl: void 0,
    multipart: void 0,
    blobIds: [],
    uploadUrls: void 0,
    multiparts: void 0
  };
}
var BlobCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.blobId !== "") {
      writer.uint32(18).string(message.blobId);
    }
    if (message.uploadUrl !== void 0) {
      writer.uint32(10).string(message.uploadUrl);
    }
    if (message.multipart !== void 0) {
      MultiPartUpload.encode(message.multipart, writer.uint32(26).fork()).join();
    }
    for (const v of message.blobIds) {
      writer.uint32(34).string(v);
    }
    if (message.uploadUrls !== void 0) {
      UploadUrlList.encode(message.uploadUrls, writer.uint32(42).fork()).join();
    }
    if (message.multiparts !== void 0) {
      MultiPartUploadList.encode(message.multiparts, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlobCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.blobId = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.uploadUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.multipart = MultiPartUpload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.blobIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.uploadUrls = UploadUrlList.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.multiparts = MultiPartUploadList.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      blobId: isSet3(object.blobId) ? globalThis.String(object.blobId) : "",
      uploadUrl: isSet3(object.uploadUrl) ? globalThis.String(object.uploadUrl) : void 0,
      multipart: isSet3(object.multipart) ? MultiPartUpload.fromJSON(object.multipart) : void 0,
      blobIds: globalThis.Array.isArray(object?.blobIds) ? object.blobIds.map((e) => globalThis.String(e)) : [],
      uploadUrls: isSet3(object.uploadUrls) ? UploadUrlList.fromJSON(object.uploadUrls) : void 0,
      multiparts: isSet3(object.multiparts) ? MultiPartUploadList.fromJSON(object.multiparts) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.blobId !== "") {
      obj.blobId = message.blobId;
    }
    if (message.uploadUrl !== void 0) {
      obj.uploadUrl = message.uploadUrl;
    }
    if (message.multipart !== void 0) {
      obj.multipart = MultiPartUpload.toJSON(message.multipart);
    }
    if (message.blobIds?.length) {
      obj.blobIds = message.blobIds;
    }
    if (message.uploadUrls !== void 0) {
      obj.uploadUrls = UploadUrlList.toJSON(message.uploadUrls);
    }
    if (message.multiparts !== void 0) {
      obj.multiparts = MultiPartUploadList.toJSON(message.multiparts);
    }
    return obj;
  },
  create(base) {
    return BlobCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlobCreateResponse();
    message.blobId = object.blobId ?? "";
    message.uploadUrl = object.uploadUrl ?? void 0;
    message.multipart = object.multipart !== void 0 && object.multipart !== null ? MultiPartUpload.fromPartial(object.multipart) : void 0;
    message.blobIds = object.blobIds?.map((e) => e) || [];
    message.uploadUrls = object.uploadUrls !== void 0 && object.uploadUrls !== null ? UploadUrlList.fromPartial(object.uploadUrls) : void 0;
    message.multiparts = object.multiparts !== void 0 && object.multiparts !== null ? MultiPartUploadList.fromPartial(object.multiparts) : void 0;
    return message;
  }
};
function createBaseBlobGetRequest() {
  return { blobId: "" };
}
var BlobGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.blobId !== "") {
      writer.uint32(10).string(message.blobId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlobGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.blobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { blobId: isSet3(object.blobId) ? globalThis.String(object.blobId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.blobId !== "") {
      obj.blobId = message.blobId;
    }
    return obj;
  },
  create(base) {
    return BlobGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlobGetRequest();
    message.blobId = object.blobId ?? "";
    return message;
  }
};
function createBaseBlobGetResponse() {
  return { downloadUrl: "" };
}
var BlobGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.downloadUrl !== "") {
      writer.uint32(10).string(message.downloadUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBlobGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.downloadUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { downloadUrl: isSet3(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    return obj;
  },
  create(base) {
    return BlobGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBlobGetResponse();
    message.downloadUrl = object.downloadUrl ?? "";
    return message;
  }
};
function createBaseBuildFunction() {
  return { definition: "", globals: new Uint8Array(0), input: void 0 };
}
var BuildFunction = {
  encode(message, writer = new BinaryWriter()) {
    if (message.definition !== "") {
      writer.uint32(10).string(message.definition);
    }
    if (message.globals.length !== 0) {
      writer.uint32(18).bytes(message.globals);
    }
    if (message.input !== void 0) {
      FunctionInput.encode(message.input, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBuildFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.definition = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.globals = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.input = FunctionInput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      definition: isSet3(object.definition) ? globalThis.String(object.definition) : "",
      globals: isSet3(object.globals) ? bytesFromBase64(object.globals) : new Uint8Array(0),
      input: isSet3(object.input) ? FunctionInput.fromJSON(object.input) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.definition !== "") {
      obj.definition = message.definition;
    }
    if (message.globals.length !== 0) {
      obj.globals = base64FromBytes(message.globals);
    }
    if (message.input !== void 0) {
      obj.input = FunctionInput.toJSON(message.input);
    }
    return obj;
  },
  create(base) {
    return BuildFunction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseBuildFunction();
    message.definition = object.definition ?? "";
    message.globals = object.globals ?? new Uint8Array(0);
    message.input = object.input !== void 0 && object.input !== null ? FunctionInput.fromPartial(object.input) : void 0;
    return message;
  }
};
function createBaseCancelInputEvent() {
  return { inputIds: [], terminateContainers: false };
}
var CancelInputEvent = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.inputIds) {
      writer.uint32(10).string(v);
    }
    if (message.terminateContainers !== false) {
      writer.uint32(16).bool(message.terminateContainers);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCancelInputEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.terminateContainers = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputIds: globalThis.Array.isArray(object?.inputIds) ? object.inputIds.map((e) => globalThis.String(e)) : [],
      terminateContainers: isSet3(object.terminateContainers) ? globalThis.Boolean(object.terminateContainers) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputIds?.length) {
      obj.inputIds = message.inputIds;
    }
    if (message.terminateContainers !== false) {
      obj.terminateContainers = message.terminateContainers;
    }
    return obj;
  },
  create(base) {
    return CancelInputEvent.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCancelInputEvent();
    message.inputIds = object.inputIds?.map((e) => e) || [];
    message.terminateContainers = object.terminateContainers ?? false;
    return message;
  }
};
function createBaseCheckpointInfo() {
  return {
    checksum: "",
    status: 0,
    checkpointId: "",
    runtimeFingerprint: "",
    size: 0,
    checksumIsFileIndex: false,
    originalTaskId: "",
    runscRuntimeVersion: ""
  };
}
var CheckpointInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.checksum !== "") {
      writer.uint32(10).string(message.checksum);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.checkpointId !== "") {
      writer.uint32(26).string(message.checkpointId);
    }
    if (message.runtimeFingerprint !== "") {
      writer.uint32(34).string(message.runtimeFingerprint);
    }
    if (message.size !== 0) {
      writer.uint32(40).int64(message.size);
    }
    if (message.checksumIsFileIndex !== false) {
      writer.uint32(48).bool(message.checksumIsFileIndex);
    }
    if (message.originalTaskId !== "") {
      writer.uint32(58).string(message.originalTaskId);
    }
    if (message.runscRuntimeVersion !== "") {
      writer.uint32(74).string(message.runscRuntimeVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCheckpointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.checksum = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.status = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.checkpointId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.runtimeFingerprint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.size = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.checksumIsFileIndex = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.originalTaskId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.runscRuntimeVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      checksum: isSet3(object.checksum) ? globalThis.String(object.checksum) : "",
      status: isSet3(object.status) ? checkpointStatusFromJSON(object.status) : 0,
      checkpointId: isSet3(object.checkpointId) ? globalThis.String(object.checkpointId) : "",
      runtimeFingerprint: isSet3(object.runtimeFingerprint) ? globalThis.String(object.runtimeFingerprint) : "",
      size: isSet3(object.size) ? globalThis.Number(object.size) : 0,
      checksumIsFileIndex: isSet3(object.checksumIsFileIndex) ? globalThis.Boolean(object.checksumIsFileIndex) : false,
      originalTaskId: isSet3(object.originalTaskId) ? globalThis.String(object.originalTaskId) : "",
      runscRuntimeVersion: isSet3(object.runscRuntimeVersion) ? globalThis.String(object.runscRuntimeVersion) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.status !== 0) {
      obj.status = checkpointStatusToJSON(message.status);
    }
    if (message.checkpointId !== "") {
      obj.checkpointId = message.checkpointId;
    }
    if (message.runtimeFingerprint !== "") {
      obj.runtimeFingerprint = message.runtimeFingerprint;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.checksumIsFileIndex !== false) {
      obj.checksumIsFileIndex = message.checksumIsFileIndex;
    }
    if (message.originalTaskId !== "") {
      obj.originalTaskId = message.originalTaskId;
    }
    if (message.runscRuntimeVersion !== "") {
      obj.runscRuntimeVersion = message.runscRuntimeVersion;
    }
    return obj;
  },
  create(base) {
    return CheckpointInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCheckpointInfo();
    message.checksum = object.checksum ?? "";
    message.status = object.status ?? 0;
    message.checkpointId = object.checkpointId ?? "";
    message.runtimeFingerprint = object.runtimeFingerprint ?? "";
    message.size = object.size ?? 0;
    message.checksumIsFileIndex = object.checksumIsFileIndex ?? false;
    message.originalTaskId = object.originalTaskId ?? "";
    message.runscRuntimeVersion = object.runscRuntimeVersion ?? "";
    return message;
  }
};
function createBaseClassCreateRequest() {
  return { appId: "", existingClassId: "", methods: [], onlyClassFunction: false };
}
var ClassCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.existingClassId !== "") {
      writer.uint32(18).string(message.existingClassId);
    }
    for (const v of message.methods) {
      ClassMethod.encode(v, writer.uint32(26).fork()).join();
    }
    if (message.onlyClassFunction !== false) {
      writer.uint32(40).bool(message.onlyClassFunction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.existingClassId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.methods.push(ClassMethod.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.onlyClassFunction = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      existingClassId: isSet3(object.existingClassId) ? globalThis.String(object.existingClassId) : "",
      methods: globalThis.Array.isArray(object?.methods) ? object.methods.map((e) => ClassMethod.fromJSON(e)) : [],
      onlyClassFunction: isSet3(object.onlyClassFunction) ? globalThis.Boolean(object.onlyClassFunction) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.existingClassId !== "") {
      obj.existingClassId = message.existingClassId;
    }
    if (message.methods?.length) {
      obj.methods = message.methods.map((e) => ClassMethod.toJSON(e));
    }
    if (message.onlyClassFunction !== false) {
      obj.onlyClassFunction = message.onlyClassFunction;
    }
    return obj;
  },
  create(base) {
    return ClassCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassCreateRequest();
    message.appId = object.appId ?? "";
    message.existingClassId = object.existingClassId ?? "";
    message.methods = object.methods?.map((e) => ClassMethod.fromPartial(e)) || [];
    message.onlyClassFunction = object.onlyClassFunction ?? false;
    return message;
  }
};
function createBaseClassCreateResponse() {
  return { classId: "", handleMetadata: void 0 };
}
var ClassCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.classId !== "") {
      writer.uint32(10).string(message.classId);
    }
    if (message.handleMetadata !== void 0) {
      ClassHandleMetadata.encode(message.handleMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.classId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.handleMetadata = ClassHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      classId: isSet3(object.classId) ? globalThis.String(object.classId) : "",
      handleMetadata: isSet3(object.handleMetadata) ? ClassHandleMetadata.fromJSON(object.handleMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.classId !== "") {
      obj.classId = message.classId;
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = ClassHandleMetadata.toJSON(message.handleMetadata);
    }
    return obj;
  },
  create(base) {
    return ClassCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassCreateResponse();
    message.classId = object.classId ?? "";
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? ClassHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    return message;
  }
};
function createBaseClassGetRequest() {
  return { appName: "", objectTag: "", environmentName: "", onlyClassFunction: false };
}
var ClassGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appName !== "") {
      writer.uint32(10).string(message.appName);
    }
    if (message.objectTag !== "") {
      writer.uint32(18).string(message.objectTag);
    }
    if (message.environmentName !== "") {
      writer.uint32(34).string(message.environmentName);
    }
    if (message.onlyClassFunction !== false) {
      writer.uint32(80).bool(message.onlyClassFunction);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.objectTag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.onlyClassFunction = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appName: isSet3(object.appName) ? globalThis.String(object.appName) : "",
      objectTag: isSet3(object.objectTag) ? globalThis.String(object.objectTag) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      onlyClassFunction: isSet3(object.onlyClassFunction) ? globalThis.Boolean(object.onlyClassFunction) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.objectTag !== "") {
      obj.objectTag = message.objectTag;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.onlyClassFunction !== false) {
      obj.onlyClassFunction = message.onlyClassFunction;
    }
    return obj;
  },
  create(base) {
    return ClassGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassGetRequest();
    message.appName = object.appName ?? "";
    message.objectTag = object.objectTag ?? "";
    message.environmentName = object.environmentName ?? "";
    message.onlyClassFunction = object.onlyClassFunction ?? false;
    return message;
  }
};
function createBaseClassGetResponse() {
  return { classId: "", handleMetadata: void 0, serverWarnings: [] };
}
var ClassGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.classId !== "") {
      writer.uint32(10).string(message.classId);
    }
    if (message.handleMetadata !== void 0) {
      ClassHandleMetadata.encode(message.handleMetadata, writer.uint32(18).fork()).join();
    }
    for (const v of message.serverWarnings) {
      Warning.encode(v, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.classId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.handleMetadata = ClassHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.serverWarnings.push(Warning.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      classId: isSet3(object.classId) ? globalThis.String(object.classId) : "",
      handleMetadata: isSet3(object.handleMetadata) ? ClassHandleMetadata.fromJSON(object.handleMetadata) : void 0,
      serverWarnings: globalThis.Array.isArray(object?.serverWarnings) ? object.serverWarnings.map((e) => Warning.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.classId !== "") {
      obj.classId = message.classId;
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = ClassHandleMetadata.toJSON(message.handleMetadata);
    }
    if (message.serverWarnings?.length) {
      obj.serverWarnings = message.serverWarnings.map((e) => Warning.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ClassGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassGetResponse();
    message.classId = object.classId ?? "";
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? ClassHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    message.serverWarnings = object.serverWarnings?.map((e) => Warning.fromPartial(e)) || [];
    return message;
  }
};
function createBaseClassHandleMetadata() {
  return { methods: [], classFunctionId: "", classFunctionMetadata: void 0 };
}
var ClassHandleMetadata = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.methods) {
      ClassMethod.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.classFunctionId !== "") {
      writer.uint32(18).string(message.classFunctionId);
    }
    if (message.classFunctionMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.classFunctionMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassHandleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.methods.push(ClassMethod.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.classFunctionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.classFunctionMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      methods: globalThis.Array.isArray(object?.methods) ? object.methods.map((e) => ClassMethod.fromJSON(e)) : [],
      classFunctionId: isSet3(object.classFunctionId) ? globalThis.String(object.classFunctionId) : "",
      classFunctionMetadata: isSet3(object.classFunctionMetadata) ? FunctionHandleMetadata.fromJSON(object.classFunctionMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.methods?.length) {
      obj.methods = message.methods.map((e) => ClassMethod.toJSON(e));
    }
    if (message.classFunctionId !== "") {
      obj.classFunctionId = message.classFunctionId;
    }
    if (message.classFunctionMetadata !== void 0) {
      obj.classFunctionMetadata = FunctionHandleMetadata.toJSON(message.classFunctionMetadata);
    }
    return obj;
  },
  create(base) {
    return ClassHandleMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassHandleMetadata();
    message.methods = object.methods?.map((e) => ClassMethod.fromPartial(e)) || [];
    message.classFunctionId = object.classFunctionId ?? "";
    message.classFunctionMetadata = object.classFunctionMetadata !== void 0 && object.classFunctionMetadata !== null ? FunctionHandleMetadata.fromPartial(object.classFunctionMetadata) : void 0;
    return message;
  }
};
function createBaseClassMethod() {
  return { functionName: "", functionId: "", functionHandleMetadata: void 0 };
}
var ClassMethod = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionName !== "") {
      writer.uint32(10).string(message.functionName);
    }
    if (message.functionId !== "") {
      writer.uint32(18).string(message.functionId);
    }
    if (message.functionHandleMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.functionHandleMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassMethod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionHandleMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      functionHandleMetadata: isSet3(object.functionHandleMetadata) ? FunctionHandleMetadata.fromJSON(object.functionHandleMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.functionHandleMetadata !== void 0) {
      obj.functionHandleMetadata = FunctionHandleMetadata.toJSON(message.functionHandleMetadata);
    }
    return obj;
  },
  create(base) {
    return ClassMethod.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassMethod();
    message.functionName = object.functionName ?? "";
    message.functionId = object.functionId ?? "";
    message.functionHandleMetadata = object.functionHandleMetadata !== void 0 && object.functionHandleMetadata !== null ? FunctionHandleMetadata.fromPartial(object.functionHandleMetadata) : void 0;
    return message;
  }
};
function createBaseClassParameterInfo() {
  return { format: 0, schema: [] };
}
var ClassParameterInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    for (const v of message.schema) {
      ClassParameterSpec.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassParameterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.format = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.schema.push(ClassParameterSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      format: isSet3(object.format) ? classParameterInfo_ParameterSerializationFormatFromJSON(object.format) : 0,
      schema: globalThis.Array.isArray(object?.schema) ? object.schema.map((e) => ClassParameterSpec.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.format !== 0) {
      obj.format = classParameterInfo_ParameterSerializationFormatToJSON(message.format);
    }
    if (message.schema?.length) {
      obj.schema = message.schema.map((e) => ClassParameterSpec.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ClassParameterInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassParameterInfo();
    message.format = object.format ?? 0;
    message.schema = object.schema?.map((e) => ClassParameterSpec.fromPartial(e)) || [];
    return message;
  }
};
function createBaseClassParameterSet() {
  return { parameters: [] };
}
var ClassParameterSet = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.parameters) {
      ClassParameterValue.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassParameterSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.parameters.push(ClassParameterValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      parameters: globalThis.Array.isArray(object?.parameters) ? object.parameters.map((e) => ClassParameterValue.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => ClassParameterValue.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ClassParameterSet.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassParameterSet();
    message.parameters = object.parameters?.map((e) => ClassParameterValue.fromPartial(e)) || [];
    return message;
  }
};
function createBaseClassParameterSpec() {
  return {
    name: "",
    type: 0,
    hasDefault: false,
    stringDefault: void 0,
    intDefault: void 0,
    pickleDefault: void 0,
    bytesDefault: void 0,
    boolDefault: void 0,
    fullType: void 0
  };
}
var ClassParameterSpec = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.hasDefault !== false) {
      writer.uint32(24).bool(message.hasDefault);
    }
    if (message.stringDefault !== void 0) {
      writer.uint32(34).string(message.stringDefault);
    }
    if (message.intDefault !== void 0) {
      writer.uint32(40).int64(message.intDefault);
    }
    if (message.pickleDefault !== void 0) {
      writer.uint32(50).bytes(message.pickleDefault);
    }
    if (message.bytesDefault !== void 0) {
      writer.uint32(58).bytes(message.bytesDefault);
    }
    if (message.boolDefault !== void 0) {
      writer.uint32(72).bool(message.boolDefault);
    }
    if (message.fullType !== void 0) {
      GenericPayloadType.encode(message.fullType, writer.uint32(66).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassParameterSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.hasDefault = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.stringDefault = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.intDefault = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.pickleDefault = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.bytesDefault = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.boolDefault = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.fullType = GenericPayloadType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      type: isSet3(object.type) ? parameterTypeFromJSON(object.type) : 0,
      hasDefault: isSet3(object.hasDefault) ? globalThis.Boolean(object.hasDefault) : false,
      stringDefault: isSet3(object.stringDefault) ? globalThis.String(object.stringDefault) : void 0,
      intDefault: isSet3(object.intDefault) ? globalThis.Number(object.intDefault) : void 0,
      pickleDefault: isSet3(object.pickleDefault) ? bytesFromBase64(object.pickleDefault) : void 0,
      bytesDefault: isSet3(object.bytesDefault) ? bytesFromBase64(object.bytesDefault) : void 0,
      boolDefault: isSet3(object.boolDefault) ? globalThis.Boolean(object.boolDefault) : void 0,
      fullType: isSet3(object.fullType) ? GenericPayloadType.fromJSON(object.fullType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = parameterTypeToJSON(message.type);
    }
    if (message.hasDefault !== false) {
      obj.hasDefault = message.hasDefault;
    }
    if (message.stringDefault !== void 0) {
      obj.stringDefault = message.stringDefault;
    }
    if (message.intDefault !== void 0) {
      obj.intDefault = Math.round(message.intDefault);
    }
    if (message.pickleDefault !== void 0) {
      obj.pickleDefault = base64FromBytes(message.pickleDefault);
    }
    if (message.bytesDefault !== void 0) {
      obj.bytesDefault = base64FromBytes(message.bytesDefault);
    }
    if (message.boolDefault !== void 0) {
      obj.boolDefault = message.boolDefault;
    }
    if (message.fullType !== void 0) {
      obj.fullType = GenericPayloadType.toJSON(message.fullType);
    }
    return obj;
  },
  create(base) {
    return ClassParameterSpec.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassParameterSpec();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.hasDefault = object.hasDefault ?? false;
    message.stringDefault = object.stringDefault ?? void 0;
    message.intDefault = object.intDefault ?? void 0;
    message.pickleDefault = object.pickleDefault ?? void 0;
    message.bytesDefault = object.bytesDefault ?? void 0;
    message.boolDefault = object.boolDefault ?? void 0;
    message.fullType = object.fullType !== void 0 && object.fullType !== null ? GenericPayloadType.fromPartial(object.fullType) : void 0;
    return message;
  }
};
function createBaseClassParameterValue() {
  return {
    name: "",
    type: 0,
    stringValue: void 0,
    intValue: void 0,
    pickleValue: void 0,
    bytesValue: void 0,
    boolValue: void 0
  };
}
var ClassParameterValue = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.intValue !== void 0) {
      writer.uint32(32).int64(message.intValue);
    }
    if (message.pickleValue !== void 0) {
      writer.uint32(42).bytes(message.pickleValue);
    }
    if (message.bytesValue !== void 0) {
      writer.uint32(50).bytes(message.bytesValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(56).bool(message.boolValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClassParameterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.intValue = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.pickleValue = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.bytesValue = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      type: isSet3(object.type) ? parameterTypeFromJSON(object.type) : 0,
      stringValue: isSet3(object.stringValue) ? globalThis.String(object.stringValue) : void 0,
      intValue: isSet3(object.intValue) ? globalThis.Number(object.intValue) : void 0,
      pickleValue: isSet3(object.pickleValue) ? bytesFromBase64(object.pickleValue) : void 0,
      bytesValue: isSet3(object.bytesValue) ? bytesFromBase64(object.bytesValue) : void 0,
      boolValue: isSet3(object.boolValue) ? globalThis.Boolean(object.boolValue) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = parameterTypeToJSON(message.type);
    }
    if (message.stringValue !== void 0) {
      obj.stringValue = message.stringValue;
    }
    if (message.intValue !== void 0) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.pickleValue !== void 0) {
      obj.pickleValue = base64FromBytes(message.pickleValue);
    }
    if (message.bytesValue !== void 0) {
      obj.bytesValue = base64FromBytes(message.bytesValue);
    }
    if (message.boolValue !== void 0) {
      obj.boolValue = message.boolValue;
    }
    return obj;
  },
  create(base) {
    return ClassParameterValue.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClassParameterValue();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.stringValue = object.stringValue ?? void 0;
    message.intValue = object.intValue ?? void 0;
    message.pickleValue = object.pickleValue ?? void 0;
    message.bytesValue = object.bytesValue ?? void 0;
    message.boolValue = object.boolValue ?? void 0;
    return message;
  }
};
function createBaseClientHelloResponse() {
  return { warning: "", imageBuilderVersion: "", serverWarnings: [] };
}
var ClientHelloResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.warning !== "") {
      writer.uint32(10).string(message.warning);
    }
    if (message.imageBuilderVersion !== "") {
      writer.uint32(18).string(message.imageBuilderVersion);
    }
    for (const v of message.serverWarnings) {
      Warning.encode(v, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientHelloResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.warning = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.imageBuilderVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.serverWarnings.push(Warning.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      warning: isSet3(object.warning) ? globalThis.String(object.warning) : "",
      imageBuilderVersion: isSet3(object.imageBuilderVersion) ? globalThis.String(object.imageBuilderVersion) : "",
      serverWarnings: globalThis.Array.isArray(object?.serverWarnings) ? object.serverWarnings.map((e) => Warning.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.warning !== "") {
      obj.warning = message.warning;
    }
    if (message.imageBuilderVersion !== "") {
      obj.imageBuilderVersion = message.imageBuilderVersion;
    }
    if (message.serverWarnings?.length) {
      obj.serverWarnings = message.serverWarnings.map((e) => Warning.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ClientHelloResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClientHelloResponse();
    message.warning = object.warning ?? "";
    message.imageBuilderVersion = object.imageBuilderVersion ?? "";
    message.serverWarnings = object.serverWarnings?.map((e) => Warning.fromPartial(e)) || [];
    return message;
  }
};
function createBaseCloudBucketMount() {
  return {
    bucketName: "",
    mountPath: "",
    credentialsSecretId: "",
    readOnly: false,
    bucketType: 0,
    requesterPays: false,
    bucketEndpointUrl: void 0,
    keyPrefix: void 0,
    oidcAuthRoleArn: void 0
  };
}
var CloudBucketMount = {
  encode(message, writer = new BinaryWriter()) {
    if (message.bucketName !== "") {
      writer.uint32(10).string(message.bucketName);
    }
    if (message.mountPath !== "") {
      writer.uint32(18).string(message.mountPath);
    }
    if (message.credentialsSecretId !== "") {
      writer.uint32(26).string(message.credentialsSecretId);
    }
    if (message.readOnly !== false) {
      writer.uint32(32).bool(message.readOnly);
    }
    if (message.bucketType !== 0) {
      writer.uint32(40).int32(message.bucketType);
    }
    if (message.requesterPays !== false) {
      writer.uint32(48).bool(message.requesterPays);
    }
    if (message.bucketEndpointUrl !== void 0) {
      writer.uint32(58).string(message.bucketEndpointUrl);
    }
    if (message.keyPrefix !== void 0) {
      writer.uint32(66).string(message.keyPrefix);
    }
    if (message.oidcAuthRoleArn !== void 0) {
      writer.uint32(74).string(message.oidcAuthRoleArn);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCloudBucketMount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.bucketName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mountPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.credentialsSecretId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.readOnly = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.bucketType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.requesterPays = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.bucketEndpointUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.keyPrefix = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.oidcAuthRoleArn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bucketName: isSet3(object.bucketName) ? globalThis.String(object.bucketName) : "",
      mountPath: isSet3(object.mountPath) ? globalThis.String(object.mountPath) : "",
      credentialsSecretId: isSet3(object.credentialsSecretId) ? globalThis.String(object.credentialsSecretId) : "",
      readOnly: isSet3(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
      bucketType: isSet3(object.bucketType) ? cloudBucketMount_BucketTypeFromJSON(object.bucketType) : 0,
      requesterPays: isSet3(object.requesterPays) ? globalThis.Boolean(object.requesterPays) : false,
      bucketEndpointUrl: isSet3(object.bucketEndpointUrl) ? globalThis.String(object.bucketEndpointUrl) : void 0,
      keyPrefix: isSet3(object.keyPrefix) ? globalThis.String(object.keyPrefix) : void 0,
      oidcAuthRoleArn: isSet3(object.oidcAuthRoleArn) ? globalThis.String(object.oidcAuthRoleArn) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    if (message.credentialsSecretId !== "") {
      obj.credentialsSecretId = message.credentialsSecretId;
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    if (message.bucketType !== 0) {
      obj.bucketType = cloudBucketMount_BucketTypeToJSON(message.bucketType);
    }
    if (message.requesterPays !== false) {
      obj.requesterPays = message.requesterPays;
    }
    if (message.bucketEndpointUrl !== void 0) {
      obj.bucketEndpointUrl = message.bucketEndpointUrl;
    }
    if (message.keyPrefix !== void 0) {
      obj.keyPrefix = message.keyPrefix;
    }
    if (message.oidcAuthRoleArn !== void 0) {
      obj.oidcAuthRoleArn = message.oidcAuthRoleArn;
    }
    return obj;
  },
  create(base) {
    return CloudBucketMount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCloudBucketMount();
    message.bucketName = object.bucketName ?? "";
    message.mountPath = object.mountPath ?? "";
    message.credentialsSecretId = object.credentialsSecretId ?? "";
    message.readOnly = object.readOnly ?? false;
    message.bucketType = object.bucketType ?? 0;
    message.requesterPays = object.requesterPays ?? false;
    message.bucketEndpointUrl = object.bucketEndpointUrl ?? void 0;
    message.keyPrefix = object.keyPrefix ?? void 0;
    message.oidcAuthRoleArn = object.oidcAuthRoleArn ?? void 0;
    return message;
  }
};
function createBaseClusterGetRequest() {
  return { clusterId: "" };
}
var ClusterGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClusterGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.clusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { clusterId: isSet3(object.clusterId) ? globalThis.String(object.clusterId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    return obj;
  },
  create(base) {
    return ClusterGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClusterGetRequest();
    message.clusterId = object.clusterId ?? "";
    return message;
  }
};
function createBaseClusterGetResponse() {
  return { cluster: void 0 };
}
var ClusterGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cluster !== void 0) {
      ClusterStats.encode(message.cluster, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClusterGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cluster = ClusterStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { cluster: isSet3(object.cluster) ? ClusterStats.fromJSON(object.cluster) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.cluster !== void 0) {
      obj.cluster = ClusterStats.toJSON(message.cluster);
    }
    return obj;
  },
  create(base) {
    return ClusterGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClusterGetResponse();
    message.cluster = object.cluster !== void 0 && object.cluster !== null ? ClusterStats.fromPartial(object.cluster) : void 0;
    return message;
  }
};
function createBaseClusterListRequest() {
  return { environmentName: "" };
}
var ClusterListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClusterListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return ClusterListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClusterListRequest();
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseClusterListResponse() {
  return { clusters: [] };
}
var ClusterListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.clusters) {
      ClusterStats.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClusterListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.clusters.push(ClusterStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      clusters: globalThis.Array.isArray(object?.clusters) ? object.clusters.map((e) => ClusterStats.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => ClusterStats.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ClusterListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClusterListResponse();
    message.clusters = object.clusters?.map((e) => ClusterStats.fromPartial(e)) || [];
    return message;
  }
};
function createBaseClusterStats() {
  return { appId: "", taskIds: [], clusterId: "", startedAt: 0 };
}
var ClusterStats = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    for (const v of message.taskIds) {
      writer.uint32(18).string(v);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.startedAt !== 0) {
      writer.uint32(33).double(message.startedAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClusterStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.taskIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.clusterId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }
          message.startedAt = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      taskIds: globalThis.Array.isArray(object?.taskIds) ? object.taskIds.map((e) => globalThis.String(e)) : [],
      clusterId: isSet3(object.clusterId) ? globalThis.String(object.clusterId) : "",
      startedAt: isSet3(object.startedAt) ? globalThis.Number(object.startedAt) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.taskIds?.length) {
      obj.taskIds = message.taskIds;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.startedAt !== 0) {
      obj.startedAt = message.startedAt;
    }
    return obj;
  },
  create(base) {
    return ClusterStats.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseClusterStats();
    message.appId = object.appId ?? "";
    message.taskIds = object.taskIds?.map((e) => e) || [];
    message.clusterId = object.clusterId ?? "";
    message.startedAt = object.startedAt ?? 0;
    return message;
  }
};
function createBaseCommitInfo() {
  return {
    vcs: "",
    branch: "",
    commitHash: "",
    commitTimestamp: 0,
    dirty: false,
    authorName: "",
    authorEmail: "",
    repoUrl: ""
  };
}
var CommitInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.vcs !== "") {
      writer.uint32(10).string(message.vcs);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.commitHash !== "") {
      writer.uint32(26).string(message.commitHash);
    }
    if (message.commitTimestamp !== 0) {
      writer.uint32(32).int64(message.commitTimestamp);
    }
    if (message.dirty !== false) {
      writer.uint32(40).bool(message.dirty);
    }
    if (message.authorName !== "") {
      writer.uint32(50).string(message.authorName);
    }
    if (message.authorEmail !== "") {
      writer.uint32(58).string(message.authorEmail);
    }
    if (message.repoUrl !== "") {
      writer.uint32(66).string(message.repoUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCommitInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.vcs = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.branch = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.commitHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.commitTimestamp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.dirty = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.authorName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.authorEmail = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.repoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      vcs: isSet3(object.vcs) ? globalThis.String(object.vcs) : "",
      branch: isSet3(object.branch) ? globalThis.String(object.branch) : "",
      commitHash: isSet3(object.commitHash) ? globalThis.String(object.commitHash) : "",
      commitTimestamp: isSet3(object.commitTimestamp) ? globalThis.Number(object.commitTimestamp) : 0,
      dirty: isSet3(object.dirty) ? globalThis.Boolean(object.dirty) : false,
      authorName: isSet3(object.authorName) ? globalThis.String(object.authorName) : "",
      authorEmail: isSet3(object.authorEmail) ? globalThis.String(object.authorEmail) : "",
      repoUrl: isSet3(object.repoUrl) ? globalThis.String(object.repoUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.vcs !== "") {
      obj.vcs = message.vcs;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.commitHash !== "") {
      obj.commitHash = message.commitHash;
    }
    if (message.commitTimestamp !== 0) {
      obj.commitTimestamp = Math.round(message.commitTimestamp);
    }
    if (message.dirty !== false) {
      obj.dirty = message.dirty;
    }
    if (message.authorName !== "") {
      obj.authorName = message.authorName;
    }
    if (message.authorEmail !== "") {
      obj.authorEmail = message.authorEmail;
    }
    if (message.repoUrl !== "") {
      obj.repoUrl = message.repoUrl;
    }
    return obj;
  },
  create(base) {
    return CommitInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCommitInfo();
    message.vcs = object.vcs ?? "";
    message.branch = object.branch ?? "";
    message.commitHash = object.commitHash ?? "";
    message.commitTimestamp = object.commitTimestamp ?? 0;
    message.dirty = object.dirty ?? false;
    message.authorName = object.authorName ?? "";
    message.authorEmail = object.authorEmail ?? "";
    message.repoUrl = object.repoUrl ?? "";
    return message;
  }
};
function createBaseContainerCheckpointRequest() {
  return { checkpointId: "" };
}
var ContainerCheckpointRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.checkpointId !== "") {
      writer.uint32(10).string(message.checkpointId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.checkpointId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { checkpointId: isSet3(object.checkpointId) ? globalThis.String(object.checkpointId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.checkpointId !== "") {
      obj.checkpointId = message.checkpointId;
    }
    return obj;
  },
  create(base) {
    return ContainerCheckpointRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerCheckpointRequest();
    message.checkpointId = object.checkpointId ?? "";
    return message;
  }
};
function createBaseContainerExecGetOutputRequest() {
  return { execId: "", timeout: 0, lastBatchIndex: 0, fileDescriptor: 0, getRawBytes: false };
}
var ContainerExecGetOutputRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    if (message.lastBatchIndex !== 0) {
      writer.uint32(24).uint64(message.lastBatchIndex);
    }
    if (message.fileDescriptor !== 0) {
      writer.uint32(32).int32(message.fileDescriptor);
    }
    if (message.getRawBytes !== false) {
      writer.uint32(40).bool(message.getRawBytes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerExecGetOutputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.lastBatchIndex = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.fileDescriptor = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.getRawBytes = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      execId: isSet3(object.execId) ? globalThis.String(object.execId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      lastBatchIndex: isSet3(object.lastBatchIndex) ? globalThis.Number(object.lastBatchIndex) : 0,
      fileDescriptor: isSet3(object.fileDescriptor) ? fileDescriptorFromJSON(object.fileDescriptor) : 0,
      getRawBytes: isSet3(object.getRawBytes) ? globalThis.Boolean(object.getRawBytes) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.lastBatchIndex !== 0) {
      obj.lastBatchIndex = Math.round(message.lastBatchIndex);
    }
    if (message.fileDescriptor !== 0) {
      obj.fileDescriptor = fileDescriptorToJSON(message.fileDescriptor);
    }
    if (message.getRawBytes !== false) {
      obj.getRawBytes = message.getRawBytes;
    }
    return obj;
  },
  create(base) {
    return ContainerExecGetOutputRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerExecGetOutputRequest();
    message.execId = object.execId ?? "";
    message.timeout = object.timeout ?? 0;
    message.lastBatchIndex = object.lastBatchIndex ?? 0;
    message.fileDescriptor = object.fileDescriptor ?? 0;
    message.getRawBytes = object.getRawBytes ?? false;
    return message;
  }
};
function createBaseContainerExecPutInputRequest() {
  return { execId: "", input: void 0 };
}
var ContainerExecPutInputRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.input !== void 0) {
      RuntimeInputMessage.encode(message.input, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerExecPutInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.input = RuntimeInputMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      execId: isSet3(object.execId) ? globalThis.String(object.execId) : "",
      input: isSet3(object.input) ? RuntimeInputMessage.fromJSON(object.input) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.input !== void 0) {
      obj.input = RuntimeInputMessage.toJSON(message.input);
    }
    return obj;
  },
  create(base) {
    return ContainerExecPutInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerExecPutInputRequest();
    message.execId = object.execId ?? "";
    message.input = object.input !== void 0 && object.input !== null ? RuntimeInputMessage.fromPartial(object.input) : void 0;
    return message;
  }
};
function createBaseContainerExecRequest() {
  return {
    taskId: "",
    command: [],
    ptyInfo: void 0,
    terminateContainerOnExit: false,
    runtimeDebug: false,
    stdoutOutput: 0,
    stderrOutput: 0,
    timeoutSecs: 0,
    workdir: void 0,
    secretIds: []
  };
}
var ContainerExecRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    for (const v of message.command) {
      writer.uint32(18).string(v);
    }
    if (message.ptyInfo !== void 0) {
      PTYInfo.encode(message.ptyInfo, writer.uint32(26).fork()).join();
    }
    if (message.terminateContainerOnExit !== false) {
      writer.uint32(32).bool(message.terminateContainerOnExit);
    }
    if (message.runtimeDebug !== false) {
      writer.uint32(40).bool(message.runtimeDebug);
    }
    if (message.stdoutOutput !== 0) {
      writer.uint32(48).int32(message.stdoutOutput);
    }
    if (message.stderrOutput !== 0) {
      writer.uint32(56).int32(message.stderrOutput);
    }
    if (message.timeoutSecs !== 0) {
      writer.uint32(64).uint32(message.timeoutSecs);
    }
    if (message.workdir !== void 0) {
      writer.uint32(74).string(message.workdir);
    }
    for (const v of message.secretIds) {
      writer.uint32(82).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.command.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.ptyInfo = PTYInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.terminateContainerOnExit = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.runtimeDebug = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.stdoutOutput = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.stderrOutput = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.timeoutSecs = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.workdir = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.secretIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      command: globalThis.Array.isArray(object?.command) ? object.command.map((e) => globalThis.String(e)) : [],
      ptyInfo: isSet3(object.ptyInfo) ? PTYInfo.fromJSON(object.ptyInfo) : void 0,
      terminateContainerOnExit: isSet3(object.terminateContainerOnExit) ? globalThis.Boolean(object.terminateContainerOnExit) : false,
      runtimeDebug: isSet3(object.runtimeDebug) ? globalThis.Boolean(object.runtimeDebug) : false,
      stdoutOutput: isSet3(object.stdoutOutput) ? execOutputOptionFromJSON(object.stdoutOutput) : 0,
      stderrOutput: isSet3(object.stderrOutput) ? execOutputOptionFromJSON(object.stderrOutput) : 0,
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : 0,
      workdir: isSet3(object.workdir) ? globalThis.String(object.workdir) : void 0,
      secretIds: globalThis.Array.isArray(object?.secretIds) ? object.secretIds.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    if (message.ptyInfo !== void 0) {
      obj.ptyInfo = PTYInfo.toJSON(message.ptyInfo);
    }
    if (message.terminateContainerOnExit !== false) {
      obj.terminateContainerOnExit = message.terminateContainerOnExit;
    }
    if (message.runtimeDebug !== false) {
      obj.runtimeDebug = message.runtimeDebug;
    }
    if (message.stdoutOutput !== 0) {
      obj.stdoutOutput = execOutputOptionToJSON(message.stdoutOutput);
    }
    if (message.stderrOutput !== 0) {
      obj.stderrOutput = execOutputOptionToJSON(message.stderrOutput);
    }
    if (message.timeoutSecs !== 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    if (message.workdir !== void 0) {
      obj.workdir = message.workdir;
    }
    if (message.secretIds?.length) {
      obj.secretIds = message.secretIds;
    }
    return obj;
  },
  create(base) {
    return ContainerExecRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerExecRequest();
    message.taskId = object.taskId ?? "";
    message.command = object.command?.map((e) => e) || [];
    message.ptyInfo = object.ptyInfo !== void 0 && object.ptyInfo !== null ? PTYInfo.fromPartial(object.ptyInfo) : void 0;
    message.terminateContainerOnExit = object.terminateContainerOnExit ?? false;
    message.runtimeDebug = object.runtimeDebug ?? false;
    message.stdoutOutput = object.stdoutOutput ?? 0;
    message.stderrOutput = object.stderrOutput ?? 0;
    message.timeoutSecs = object.timeoutSecs ?? 0;
    message.workdir = object.workdir ?? void 0;
    message.secretIds = object.secretIds?.map((e) => e) || [];
    return message;
  }
};
function createBaseContainerExecResponse() {
  return { execId: "" };
}
var ContainerExecResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerExecResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.execId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { execId: isSet3(object.execId) ? globalThis.String(object.execId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    return obj;
  },
  create(base) {
    return ContainerExecResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerExecResponse();
    message.execId = object.execId ?? "";
    return message;
  }
};
function createBaseContainerExecWaitRequest() {
  return { execId: "", timeout: 0 };
}
var ContainerExecWaitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerExecWaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      execId: isSet3(object.execId) ? globalThis.String(object.execId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return ContainerExecWaitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerExecWaitRequest();
    message.execId = object.execId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseContainerExecWaitResponse() {
  return { exitCode: void 0, completed: false };
}
var ContainerExecWaitResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.exitCode !== void 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.completed !== false) {
      writer.uint32(16).bool(message.completed);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerExecWaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.exitCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.completed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      exitCode: isSet3(object.exitCode) ? globalThis.Number(object.exitCode) : void 0,
      completed: isSet3(object.completed) ? globalThis.Boolean(object.completed) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.exitCode !== void 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    return obj;
  },
  create(base) {
    return ContainerExecWaitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerExecWaitResponse();
    message.exitCode = object.exitCode ?? void 0;
    message.completed = object.completed ?? false;
    return message;
  }
};
function createBaseContainerFileCloseRequest() {
  return { fileDescriptor: "" };
}
var ContainerFileCloseRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    return obj;
  },
  create(base) {
    return ContainerFileCloseRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileCloseRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    return message;
  }
};
function createBaseContainerFileDeleteBytesRequest() {
  return { fileDescriptor: "", startInclusive: void 0, endExclusive: void 0 };
}
var ContainerFileDeleteBytesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    if (message.startInclusive !== void 0) {
      writer.uint32(16).uint32(message.startInclusive);
    }
    if (message.endExclusive !== void 0) {
      writer.uint32(24).uint32(message.endExclusive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileDeleteBytesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.startInclusive = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.endExclusive = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "",
      startInclusive: isSet3(object.startInclusive) ? globalThis.Number(object.startInclusive) : void 0,
      endExclusive: isSet3(object.endExclusive) ? globalThis.Number(object.endExclusive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    if (message.startInclusive !== void 0) {
      obj.startInclusive = Math.round(message.startInclusive);
    }
    if (message.endExclusive !== void 0) {
      obj.endExclusive = Math.round(message.endExclusive);
    }
    return obj;
  },
  create(base) {
    return ContainerFileDeleteBytesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileDeleteBytesRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    message.startInclusive = object.startInclusive ?? void 0;
    message.endExclusive = object.endExclusive ?? void 0;
    return message;
  }
};
function createBaseContainerFileFlushRequest() {
  return { fileDescriptor: "" };
}
var ContainerFileFlushRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileFlushRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    return obj;
  },
  create(base) {
    return ContainerFileFlushRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileFlushRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    return message;
  }
};
function createBaseContainerFileLsRequest() {
  return { path: "" };
}
var ContainerFileLsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileLsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { path: isSet3(object.path) ? globalThis.String(object.path) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },
  create(base) {
    return ContainerFileLsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileLsRequest();
    message.path = object.path ?? "";
    return message;
  }
};
function createBaseContainerFileMkdirRequest() {
  return { path: "", makeParents: false };
}
var ContainerFileMkdirRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.makeParents !== false) {
      writer.uint32(16).bool(message.makeParents);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileMkdirRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.makeParents = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      makeParents: isSet3(object.makeParents) ? globalThis.Boolean(object.makeParents) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.makeParents !== false) {
      obj.makeParents = message.makeParents;
    }
    return obj;
  },
  create(base) {
    return ContainerFileMkdirRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileMkdirRequest();
    message.path = object.path ?? "";
    message.makeParents = object.makeParents ?? false;
    return message;
  }
};
function createBaseContainerFileOpenRequest() {
  return { fileDescriptor: void 0, path: "", mode: "" };
}
var ContainerFileOpenRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== void 0) {
      writer.uint32(10).string(message.fileDescriptor);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.mode !== "") {
      writer.uint32(26).string(message.mode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileOpenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.mode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : void 0,
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      mode: isSet3(object.mode) ? globalThis.String(object.mode) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== void 0) {
      obj.fileDescriptor = message.fileDescriptor;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    return obj;
  },
  create(base) {
    return ContainerFileOpenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileOpenRequest();
    message.fileDescriptor = object.fileDescriptor ?? void 0;
    message.path = object.path ?? "";
    message.mode = object.mode ?? "";
    return message;
  }
};
function createBaseContainerFileReadLineRequest() {
  return { fileDescriptor: "" };
}
var ContainerFileReadLineRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileReadLineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    return obj;
  },
  create(base) {
    return ContainerFileReadLineRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileReadLineRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    return message;
  }
};
function createBaseContainerFileReadRequest() {
  return { fileDescriptor: "", n: void 0 };
}
var ContainerFileReadRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    if (message.n !== void 0) {
      writer.uint32(16).uint32(message.n);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.n = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "",
      n: isSet3(object.n) ? globalThis.Number(object.n) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    if (message.n !== void 0) {
      obj.n = Math.round(message.n);
    }
    return obj;
  },
  create(base) {
    return ContainerFileReadRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileReadRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    message.n = object.n ?? void 0;
    return message;
  }
};
function createBaseContainerFileRmRequest() {
  return { path: "", recursive: false };
}
var ContainerFileRmRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(16).bool(message.recursive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileRmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },
  create(base) {
    return ContainerFileRmRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileRmRequest();
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  }
};
function createBaseContainerFileSeekRequest() {
  return { fileDescriptor: "", offset: 0, whence: 0 };
}
var ContainerFileSeekRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.whence !== 0) {
      writer.uint32(24).int32(message.whence);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileSeekRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.whence = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "",
      offset: isSet3(object.offset) ? globalThis.Number(object.offset) : 0,
      whence: isSet3(object.whence) ? seekWhenceFromJSON(object.whence) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.whence !== 0) {
      obj.whence = seekWhenceToJSON(message.whence);
    }
    return obj;
  },
  create(base) {
    return ContainerFileSeekRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileSeekRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    message.offset = object.offset ?? 0;
    message.whence = object.whence ?? 0;
    return message;
  }
};
function createBaseContainerFileWatchRequest() {
  return { path: "", recursive: false, timeoutSecs: void 0 };
}
var ContainerFileWatchRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(16).bool(message.recursive);
    }
    if (message.timeoutSecs !== void 0) {
      writer.uint32(24).uint64(message.timeoutSecs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileWatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.timeoutSecs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false,
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    if (message.timeoutSecs !== void 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    return obj;
  },
  create(base) {
    return ContainerFileWatchRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileWatchRequest();
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    message.timeoutSecs = object.timeoutSecs ?? void 0;
    return message;
  }
};
function createBaseContainerFileWriteReplaceBytesRequest() {
  return { fileDescriptor: "", data: new Uint8Array(0), startInclusive: void 0, endExclusive: void 0 };
}
var ContainerFileWriteReplaceBytesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.startInclusive !== void 0) {
      writer.uint32(24).uint32(message.startInclusive);
    }
    if (message.endExclusive !== void 0) {
      writer.uint32(32).uint32(message.endExclusive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileWriteReplaceBytesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.startInclusive = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.endExclusive = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "",
      data: isSet3(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      startInclusive: isSet3(object.startInclusive) ? globalThis.Number(object.startInclusive) : void 0,
      endExclusive: isSet3(object.endExclusive) ? globalThis.Number(object.endExclusive) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.startInclusive !== void 0) {
      obj.startInclusive = Math.round(message.startInclusive);
    }
    if (message.endExclusive !== void 0) {
      obj.endExclusive = Math.round(message.endExclusive);
    }
    return obj;
  },
  create(base) {
    return ContainerFileWriteReplaceBytesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileWriteReplaceBytesRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.startInclusive = object.startInclusive ?? void 0;
    message.endExclusive = object.endExclusive ?? void 0;
    return message;
  }
};
function createBaseContainerFileWriteRequest() {
  return { fileDescriptor: "", data: new Uint8Array(0) };
}
var ContainerFileWriteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== "") {
      writer.uint32(10).string(message.fileDescriptor);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFileWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : "",
      data: isSet3(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== "") {
      obj.fileDescriptor = message.fileDescriptor;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },
  create(base) {
    return ContainerFileWriteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFileWriteRequest();
    message.fileDescriptor = object.fileDescriptor ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  }
};
function createBaseContainerFilesystemExecGetOutputRequest() {
  return { execId: "", timeout: 0 };
}
var ContainerFilesystemExecGetOutputRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFilesystemExecGetOutputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      execId: isSet3(object.execId) ? globalThis.String(object.execId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return ContainerFilesystemExecGetOutputRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFilesystemExecGetOutputRequest();
    message.execId = object.execId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseContainerFilesystemExecRequest() {
  return {
    fileOpenRequest: void 0,
    fileWriteRequest: void 0,
    fileReadRequest: void 0,
    fileFlushRequest: void 0,
    fileReadLineRequest: void 0,
    fileSeekRequest: void 0,
    fileDeleteBytesRequest: void 0,
    fileWriteReplaceBytesRequest: void 0,
    fileCloseRequest: void 0,
    fileLsRequest: void 0,
    fileMkdirRequest: void 0,
    fileRmRequest: void 0,
    fileWatchRequest: void 0,
    taskId: ""
  };
}
var ContainerFilesystemExecRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileOpenRequest !== void 0) {
      ContainerFileOpenRequest.encode(message.fileOpenRequest, writer.uint32(10).fork()).join();
    }
    if (message.fileWriteRequest !== void 0) {
      ContainerFileWriteRequest.encode(message.fileWriteRequest, writer.uint32(18).fork()).join();
    }
    if (message.fileReadRequest !== void 0) {
      ContainerFileReadRequest.encode(message.fileReadRequest, writer.uint32(26).fork()).join();
    }
    if (message.fileFlushRequest !== void 0) {
      ContainerFileFlushRequest.encode(message.fileFlushRequest, writer.uint32(34).fork()).join();
    }
    if (message.fileReadLineRequest !== void 0) {
      ContainerFileReadLineRequest.encode(message.fileReadLineRequest, writer.uint32(42).fork()).join();
    }
    if (message.fileSeekRequest !== void 0) {
      ContainerFileSeekRequest.encode(message.fileSeekRequest, writer.uint32(50).fork()).join();
    }
    if (message.fileDeleteBytesRequest !== void 0) {
      ContainerFileDeleteBytesRequest.encode(message.fileDeleteBytesRequest, writer.uint32(58).fork()).join();
    }
    if (message.fileWriteReplaceBytesRequest !== void 0) {
      ContainerFileWriteReplaceBytesRequest.encode(message.fileWriteReplaceBytesRequest, writer.uint32(66).fork()).join();
    }
    if (message.fileCloseRequest !== void 0) {
      ContainerFileCloseRequest.encode(message.fileCloseRequest, writer.uint32(74).fork()).join();
    }
    if (message.fileLsRequest !== void 0) {
      ContainerFileLsRequest.encode(message.fileLsRequest, writer.uint32(90).fork()).join();
    }
    if (message.fileMkdirRequest !== void 0) {
      ContainerFileMkdirRequest.encode(message.fileMkdirRequest, writer.uint32(98).fork()).join();
    }
    if (message.fileRmRequest !== void 0) {
      ContainerFileRmRequest.encode(message.fileRmRequest, writer.uint32(106).fork()).join();
    }
    if (message.fileWatchRequest !== void 0) {
      ContainerFileWatchRequest.encode(message.fileWatchRequest, writer.uint32(114).fork()).join();
    }
    if (message.taskId !== "") {
      writer.uint32(82).string(message.taskId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFilesystemExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.fileOpenRequest = ContainerFileOpenRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.fileWriteRequest = ContainerFileWriteRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.fileReadRequest = ContainerFileReadRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.fileFlushRequest = ContainerFileFlushRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.fileReadLineRequest = ContainerFileReadLineRequest.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.fileSeekRequest = ContainerFileSeekRequest.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.fileDeleteBytesRequest = ContainerFileDeleteBytesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.fileWriteReplaceBytesRequest = ContainerFileWriteReplaceBytesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.fileCloseRequest = ContainerFileCloseRequest.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.fileLsRequest = ContainerFileLsRequest.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.fileMkdirRequest = ContainerFileMkdirRequest.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.fileRmRequest = ContainerFileRmRequest.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.fileWatchRequest = ContainerFileWatchRequest.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileOpenRequest: isSet3(object.fileOpenRequest) ? ContainerFileOpenRequest.fromJSON(object.fileOpenRequest) : void 0,
      fileWriteRequest: isSet3(object.fileWriteRequest) ? ContainerFileWriteRequest.fromJSON(object.fileWriteRequest) : void 0,
      fileReadRequest: isSet3(object.fileReadRequest) ? ContainerFileReadRequest.fromJSON(object.fileReadRequest) : void 0,
      fileFlushRequest: isSet3(object.fileFlushRequest) ? ContainerFileFlushRequest.fromJSON(object.fileFlushRequest) : void 0,
      fileReadLineRequest: isSet3(object.fileReadLineRequest) ? ContainerFileReadLineRequest.fromJSON(object.fileReadLineRequest) : void 0,
      fileSeekRequest: isSet3(object.fileSeekRequest) ? ContainerFileSeekRequest.fromJSON(object.fileSeekRequest) : void 0,
      fileDeleteBytesRequest: isSet3(object.fileDeleteBytesRequest) ? ContainerFileDeleteBytesRequest.fromJSON(object.fileDeleteBytesRequest) : void 0,
      fileWriteReplaceBytesRequest: isSet3(object.fileWriteReplaceBytesRequest) ? ContainerFileWriteReplaceBytesRequest.fromJSON(object.fileWriteReplaceBytesRequest) : void 0,
      fileCloseRequest: isSet3(object.fileCloseRequest) ? ContainerFileCloseRequest.fromJSON(object.fileCloseRequest) : void 0,
      fileLsRequest: isSet3(object.fileLsRequest) ? ContainerFileLsRequest.fromJSON(object.fileLsRequest) : void 0,
      fileMkdirRequest: isSet3(object.fileMkdirRequest) ? ContainerFileMkdirRequest.fromJSON(object.fileMkdirRequest) : void 0,
      fileRmRequest: isSet3(object.fileRmRequest) ? ContainerFileRmRequest.fromJSON(object.fileRmRequest) : void 0,
      fileWatchRequest: isSet3(object.fileWatchRequest) ? ContainerFileWatchRequest.fromJSON(object.fileWatchRequest) : void 0,
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileOpenRequest !== void 0) {
      obj.fileOpenRequest = ContainerFileOpenRequest.toJSON(message.fileOpenRequest);
    }
    if (message.fileWriteRequest !== void 0) {
      obj.fileWriteRequest = ContainerFileWriteRequest.toJSON(message.fileWriteRequest);
    }
    if (message.fileReadRequest !== void 0) {
      obj.fileReadRequest = ContainerFileReadRequest.toJSON(message.fileReadRequest);
    }
    if (message.fileFlushRequest !== void 0) {
      obj.fileFlushRequest = ContainerFileFlushRequest.toJSON(message.fileFlushRequest);
    }
    if (message.fileReadLineRequest !== void 0) {
      obj.fileReadLineRequest = ContainerFileReadLineRequest.toJSON(message.fileReadLineRequest);
    }
    if (message.fileSeekRequest !== void 0) {
      obj.fileSeekRequest = ContainerFileSeekRequest.toJSON(message.fileSeekRequest);
    }
    if (message.fileDeleteBytesRequest !== void 0) {
      obj.fileDeleteBytesRequest = ContainerFileDeleteBytesRequest.toJSON(message.fileDeleteBytesRequest);
    }
    if (message.fileWriteReplaceBytesRequest !== void 0) {
      obj.fileWriteReplaceBytesRequest = ContainerFileWriteReplaceBytesRequest.toJSON(
        message.fileWriteReplaceBytesRequest
      );
    }
    if (message.fileCloseRequest !== void 0) {
      obj.fileCloseRequest = ContainerFileCloseRequest.toJSON(message.fileCloseRequest);
    }
    if (message.fileLsRequest !== void 0) {
      obj.fileLsRequest = ContainerFileLsRequest.toJSON(message.fileLsRequest);
    }
    if (message.fileMkdirRequest !== void 0) {
      obj.fileMkdirRequest = ContainerFileMkdirRequest.toJSON(message.fileMkdirRequest);
    }
    if (message.fileRmRequest !== void 0) {
      obj.fileRmRequest = ContainerFileRmRequest.toJSON(message.fileRmRequest);
    }
    if (message.fileWatchRequest !== void 0) {
      obj.fileWatchRequest = ContainerFileWatchRequest.toJSON(message.fileWatchRequest);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },
  create(base) {
    return ContainerFilesystemExecRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFilesystemExecRequest();
    message.fileOpenRequest = object.fileOpenRequest !== void 0 && object.fileOpenRequest !== null ? ContainerFileOpenRequest.fromPartial(object.fileOpenRequest) : void 0;
    message.fileWriteRequest = object.fileWriteRequest !== void 0 && object.fileWriteRequest !== null ? ContainerFileWriteRequest.fromPartial(object.fileWriteRequest) : void 0;
    message.fileReadRequest = object.fileReadRequest !== void 0 && object.fileReadRequest !== null ? ContainerFileReadRequest.fromPartial(object.fileReadRequest) : void 0;
    message.fileFlushRequest = object.fileFlushRequest !== void 0 && object.fileFlushRequest !== null ? ContainerFileFlushRequest.fromPartial(object.fileFlushRequest) : void 0;
    message.fileReadLineRequest = object.fileReadLineRequest !== void 0 && object.fileReadLineRequest !== null ? ContainerFileReadLineRequest.fromPartial(object.fileReadLineRequest) : void 0;
    message.fileSeekRequest = object.fileSeekRequest !== void 0 && object.fileSeekRequest !== null ? ContainerFileSeekRequest.fromPartial(object.fileSeekRequest) : void 0;
    message.fileDeleteBytesRequest = object.fileDeleteBytesRequest !== void 0 && object.fileDeleteBytesRequest !== null ? ContainerFileDeleteBytesRequest.fromPartial(object.fileDeleteBytesRequest) : void 0;
    message.fileWriteReplaceBytesRequest = object.fileWriteReplaceBytesRequest !== void 0 && object.fileWriteReplaceBytesRequest !== null ? ContainerFileWriteReplaceBytesRequest.fromPartial(object.fileWriteReplaceBytesRequest) : void 0;
    message.fileCloseRequest = object.fileCloseRequest !== void 0 && object.fileCloseRequest !== null ? ContainerFileCloseRequest.fromPartial(object.fileCloseRequest) : void 0;
    message.fileLsRequest = object.fileLsRequest !== void 0 && object.fileLsRequest !== null ? ContainerFileLsRequest.fromPartial(object.fileLsRequest) : void 0;
    message.fileMkdirRequest = object.fileMkdirRequest !== void 0 && object.fileMkdirRequest !== null ? ContainerFileMkdirRequest.fromPartial(object.fileMkdirRequest) : void 0;
    message.fileRmRequest = object.fileRmRequest !== void 0 && object.fileRmRequest !== null ? ContainerFileRmRequest.fromPartial(object.fileRmRequest) : void 0;
    message.fileWatchRequest = object.fileWatchRequest !== void 0 && object.fileWatchRequest !== null ? ContainerFileWatchRequest.fromPartial(object.fileWatchRequest) : void 0;
    message.taskId = object.taskId ?? "";
    return message;
  }
};
function createBaseContainerFilesystemExecResponse() {
  return { execId: "", fileDescriptor: void 0 };
}
var ContainerFilesystemExecResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.fileDescriptor !== void 0) {
      writer.uint32(18).string(message.fileDescriptor);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerFilesystemExecResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.fileDescriptor = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      execId: isSet3(object.execId) ? globalThis.String(object.execId) : "",
      fileDescriptor: isSet3(object.fileDescriptor) ? globalThis.String(object.fileDescriptor) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.fileDescriptor !== void 0) {
      obj.fileDescriptor = message.fileDescriptor;
    }
    return obj;
  },
  create(base) {
    return ContainerFilesystemExecResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerFilesystemExecResponse();
    message.execId = object.execId ?? "";
    message.fileDescriptor = object.fileDescriptor ?? void 0;
    return message;
  }
};
function createBaseContainerHeartbeatRequest() {
  return { canceledInputsReturnOutputs: false, canceledInputsReturnOutputsV2: false };
}
var ContainerHeartbeatRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.canceledInputsReturnOutputs !== false) {
      writer.uint32(32).bool(message.canceledInputsReturnOutputs);
    }
    if (message.canceledInputsReturnOutputsV2 !== false) {
      writer.uint32(40).bool(message.canceledInputsReturnOutputsV2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.canceledInputsReturnOutputs = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.canceledInputsReturnOutputsV2 = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      canceledInputsReturnOutputs: isSet3(object.canceledInputsReturnOutputs) ? globalThis.Boolean(object.canceledInputsReturnOutputs) : false,
      canceledInputsReturnOutputsV2: isSet3(object.canceledInputsReturnOutputsV2) ? globalThis.Boolean(object.canceledInputsReturnOutputsV2) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.canceledInputsReturnOutputs !== false) {
      obj.canceledInputsReturnOutputs = message.canceledInputsReturnOutputs;
    }
    if (message.canceledInputsReturnOutputsV2 !== false) {
      obj.canceledInputsReturnOutputsV2 = message.canceledInputsReturnOutputsV2;
    }
    return obj;
  },
  create(base) {
    return ContainerHeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerHeartbeatRequest();
    message.canceledInputsReturnOutputs = object.canceledInputsReturnOutputs ?? false;
    message.canceledInputsReturnOutputsV2 = object.canceledInputsReturnOutputsV2 ?? false;
    return message;
  }
};
function createBaseContainerHeartbeatResponse() {
  return { cancelInputEvent: void 0 };
}
var ContainerHeartbeatResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cancelInputEvent !== void 0) {
      CancelInputEvent.encode(message.cancelInputEvent, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerHeartbeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cancelInputEvent = CancelInputEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cancelInputEvent: isSet3(object.cancelInputEvent) ? CancelInputEvent.fromJSON(object.cancelInputEvent) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cancelInputEvent !== void 0) {
      obj.cancelInputEvent = CancelInputEvent.toJSON(message.cancelInputEvent);
    }
    return obj;
  },
  create(base) {
    return ContainerHeartbeatResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerHeartbeatResponse();
    message.cancelInputEvent = object.cancelInputEvent !== void 0 && object.cancelInputEvent !== null ? CancelInputEvent.fromPartial(object.cancelInputEvent) : void 0;
    return message;
  }
};
function createBaseContainerLogRequest() {
  return { logs: [] };
}
var ContainerLogRequest = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.logs) {
      TaskLogs.encode(v, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.logs.push(TaskLogs.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e) => TaskLogs.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => TaskLogs.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ContainerLogRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerLogRequest();
    message.logs = object.logs?.map((e) => TaskLogs.fromPartial(e)) || [];
    return message;
  }
};
function createBaseContainerReloadVolumesRequest() {
  return { taskId: "" };
}
var ContainerReloadVolumesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerReloadVolumesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },
  create(base) {
    return ContainerReloadVolumesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerReloadVolumesRequest();
    message.taskId = object.taskId ?? "";
    return message;
  }
};
function createBaseContainerReloadVolumesResponse() {
  return {};
}
var ContainerReloadVolumesResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerReloadVolumesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ContainerReloadVolumesResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseContainerReloadVolumesResponse();
    return message;
  }
};
function createBaseContainerStopRequest() {
  return { taskId: "" };
}
var ContainerStopRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerStopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },
  create(base) {
    return ContainerStopRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseContainerStopRequest();
    message.taskId = object.taskId ?? "";
    return message;
  }
};
function createBaseContainerStopResponse() {
  return {};
}
var ContainerStopResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContainerStopResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return ContainerStopResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseContainerStopResponse();
    return message;
  }
};
function createBaseCreationInfo() {
  return { createdAt: 0, createdBy: "" };
}
var CreationInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.createdAt !== 0) {
      writer.uint32(9).double(message.createdAt);
    }
    if (message.createdBy !== "") {
      writer.uint32(18).string(message.createdBy);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.createdBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      createdBy: isSet3(object.createdBy) ? globalThis.String(object.createdBy) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    return obj;
  },
  create(base) {
    return CreationInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreationInfo();
    message.createdAt = object.createdAt ?? 0;
    message.createdBy = object.createdBy ?? "";
    return message;
  }
};
function createBaseCustomDomainConfig() {
  return { name: "" };
}
var CustomDomainConfig = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomDomainConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet3(object.name) ? globalThis.String(object.name) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return CustomDomainConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomDomainConfig();
    message.name = object.name ?? "";
    return message;
  }
};
function createBaseCustomDomainInfo() {
  return { url: "" };
}
var CustomDomainInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomDomainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { url: isSet3(object.url) ? globalThis.String(object.url) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return CustomDomainInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCustomDomainInfo();
    message.url = object.url ?? "";
    return message;
  }
};
function createBaseDNSRecord() {
  return { type: 0, name: "", value: "" };
}
var DNSRecord = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDNSRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet3(object.type) ? dNSRecordTypeFromJSON(object.type) : 0,
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = dNSRecordTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return DNSRecord.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDNSRecord();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseDataChunk() {
  return { dataFormat: 0, data: void 0, dataBlobId: void 0, index: 0 };
}
var DataChunk = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dataFormat !== 0) {
      writer.uint32(8).int32(message.dataFormat);
    }
    if (message.data !== void 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      writer.uint32(26).string(message.dataBlobId);
    }
    if (message.index !== 0) {
      writer.uint32(32).uint64(message.index);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDataChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.dataFormat = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.dataBlobId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.index = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dataFormat: isSet3(object.dataFormat) ? dataFormatFromJSON(object.dataFormat) : 0,
      data: isSet3(object.data) ? bytesFromBase64(object.data) : void 0,
      dataBlobId: isSet3(object.dataBlobId) ? globalThis.String(object.dataBlobId) : void 0,
      index: isSet3(object.index) ? globalThis.Number(object.index) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dataFormat !== 0) {
      obj.dataFormat = dataFormatToJSON(message.dataFormat);
    }
    if (message.data !== void 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      obj.dataBlobId = message.dataBlobId;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },
  create(base) {
    return DataChunk.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDataChunk();
    message.dataFormat = object.dataFormat ?? 0;
    message.data = object.data ?? void 0;
    message.dataBlobId = object.dataBlobId ?? void 0;
    message.index = object.index ?? 0;
    return message;
  }
};
function createBaseDictClearRequest() {
  return { dictId: "" };
}
var DictClearRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictClearRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    return obj;
  },
  create(base) {
    return DictClearRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictClearRequest();
    message.dictId = object.dictId ?? "";
    return message;
  }
};
function createBaseDictContainsRequest() {
  return { dictId: "", key: new Uint8Array(0) };
}
var DictContainsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictContainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      key: isSet3(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },
  create(base) {
    return DictContainsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictContainsRequest();
    message.dictId = object.dictId ?? "";
    message.key = object.key ?? new Uint8Array(0);
    return message;
  }
};
function createBaseDictContainsResponse() {
  return { found: false };
}
var DictContainsResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictContainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { found: isSet3(object.found) ? globalThis.Boolean(object.found) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  create(base) {
    return DictContainsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictContainsResponse();
    message.found = object.found ?? false;
    return message;
  }
};
function createBaseDictContentsRequest() {
  return { dictId: "", keys: false, values: false };
}
var DictContentsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    if (message.keys !== false) {
      writer.uint32(16).bool(message.keys);
    }
    if (message.values !== false) {
      writer.uint32(24).bool(message.values);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictContentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.keys = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.values = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      keys: isSet3(object.keys) ? globalThis.Boolean(object.keys) : false,
      values: isSet3(object.values) ? globalThis.Boolean(object.values) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.keys !== false) {
      obj.keys = message.keys;
    }
    if (message.values !== false) {
      obj.values = message.values;
    }
    return obj;
  },
  create(base) {
    return DictContentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictContentsRequest();
    message.dictId = object.dictId ?? "";
    message.keys = object.keys ?? false;
    message.values = object.values ?? false;
    return message;
  }
};
function createBaseDictDeleteRequest() {
  return { dictId: "" };
}
var DictDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    return obj;
  },
  create(base) {
    return DictDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictDeleteRequest();
    message.dictId = object.dictId ?? "";
    return message;
  }
};
function createBaseDictEntry() {
  return { key: new Uint8Array(0), value: new Uint8Array(0) };
}
var DictEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      value: isSet3(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },
  create(base) {
    return DictEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictEntry();
    message.key = object.key ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  }
};
function createBaseDictGetOrCreateRequest() {
  return { deploymentName: "", environmentName: "", objectCreationType: 0, data: [] };
}
var DictGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    for (const v of message.data) {
      DictEntry.encode(v, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.data.push(DictEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e) => DictEntry.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => DictEntry.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return DictGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    message.data = object.data?.map((e) => DictEntry.fromPartial(e)) || [];
    return message;
  }
};
function createBaseDictGetOrCreateResponse() {
  return { dictId: "", metadata: void 0 };
}
var DictGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    if (message.metadata !== void 0) {
      DictMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = DictMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      metadata: isSet3(object.metadata) ? DictMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = DictMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return DictGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictGetOrCreateResponse();
    message.dictId = object.dictId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? DictMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseDictGetRequest() {
  return { dictId: "", key: new Uint8Array(0) };
}
var DictGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      key: isSet3(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },
  create(base) {
    return DictGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictGetRequest();
    message.dictId = object.dictId ?? "";
    message.key = object.key ?? new Uint8Array(0);
    return message;
  }
};
function createBaseDictGetResponse() {
  return { found: false, value: void 0 };
}
var DictGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.value !== void 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.found = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      found: isSet3(object.found) ? globalThis.Boolean(object.found) : false,
      value: isSet3(object.value) ? bytesFromBase64(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.value !== void 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },
  create(base) {
    return DictGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictGetResponse();
    message.found = object.found ?? false;
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseDictHeartbeatRequest() {
  return { dictId: "" };
}
var DictHeartbeatRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    return obj;
  },
  create(base) {
    return DictHeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictHeartbeatRequest();
    message.dictId = object.dictId ?? "";
    return message;
  }
};
function createBaseDictLenRequest() {
  return { dictId: "" };
}
var DictLenRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictLenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    return obj;
  },
  create(base) {
    return DictLenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictLenRequest();
    message.dictId = object.dictId ?? "";
    return message;
  }
};
function createBaseDictLenResponse() {
  return { len: 0 };
}
var DictLenResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.len !== 0) {
      writer.uint32(8).int32(message.len);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictLenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.len = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { len: isSet3(object.len) ? globalThis.Number(object.len) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },
  create(base) {
    return DictLenResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictLenResponse();
    message.len = object.len ?? 0;
    return message;
  }
};
function createBaseDictListRequest() {
  return { environmentName: "", pagination: void 0 };
}
var DictListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    if (message.pagination !== void 0) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      pagination: isSet3(object.pagination) ? ListPagination.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.pagination !== void 0) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },
  create(base) {
    return DictListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictListRequest();
    message.environmentName = object.environmentName ?? "";
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? ListPagination.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseDictListResponse() {
  return { dicts: [], environmentName: "" };
}
var DictListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.dicts) {
      DictListResponse_DictInfo.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dicts.push(DictListResponse_DictInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dicts: globalThis.Array.isArray(object?.dicts) ? object.dicts.map((e) => DictListResponse_DictInfo.fromJSON(e)) : [],
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dicts?.length) {
      obj.dicts = message.dicts.map((e) => DictListResponse_DictInfo.toJSON(e));
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return DictListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictListResponse();
    message.dicts = object.dicts?.map((e) => DictListResponse_DictInfo.fromPartial(e)) || [];
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseDictListResponse_DictInfo() {
  return { name: "", createdAt: 0, dictId: "", metadata: void 0 };
}
var DictListResponse_DictInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createdAt !== 0) {
      writer.uint32(17).double(message.createdAt);
    }
    if (message.dictId !== "") {
      writer.uint32(26).string(message.dictId);
    }
    if (message.metadata !== void 0) {
      DictMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictListResponse_DictInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.metadata = DictMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      metadata: isSet3(object.metadata) ? DictMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = DictMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return DictListResponse_DictInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictListResponse_DictInfo();
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.dictId = object.dictId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? DictMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseDictMetadata() {
  return { name: "", creationInfo: void 0 };
}
var DictMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creationInfo !== void 0) {
      CreationInfo.encode(message.creationInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.creationInfo = CreationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      creationInfo: isSet3(object.creationInfo) ? CreationInfo.fromJSON(object.creationInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creationInfo !== void 0) {
      obj.creationInfo = CreationInfo.toJSON(message.creationInfo);
    }
    return obj;
  },
  create(base) {
    return DictMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictMetadata();
    message.name = object.name ?? "";
    message.creationInfo = object.creationInfo !== void 0 && object.creationInfo !== null ? CreationInfo.fromPartial(object.creationInfo) : void 0;
    return message;
  }
};
function createBaseDictPopRequest() {
  return { dictId: "", key: new Uint8Array(0) };
}
var DictPopRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictPopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.key = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      key: isSet3(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },
  create(base) {
    return DictPopRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictPopRequest();
    message.dictId = object.dictId ?? "";
    message.key = object.key ?? new Uint8Array(0);
    return message;
  }
};
function createBaseDictPopResponse() {
  return { found: false, value: void 0 };
}
var DictPopResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.value !== void 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictPopResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.found = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      found: isSet3(object.found) ? globalThis.Boolean(object.found) : false,
      value: isSet3(object.value) ? bytesFromBase64(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.value !== void 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },
  create(base) {
    return DictPopResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictPopResponse();
    message.found = object.found ?? false;
    message.value = object.value ?? void 0;
    return message;
  }
};
function createBaseDictUpdateRequest() {
  return { dictId: "", updates: [], ifNotExists: false };
}
var DictUpdateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.dictId !== "") {
      writer.uint32(10).string(message.dictId);
    }
    for (const v of message.updates) {
      DictEntry.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.ifNotExists !== false) {
      writer.uint32(24).bool(message.ifNotExists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.dictId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.updates.push(DictEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.ifNotExists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      dictId: isSet3(object.dictId) ? globalThis.String(object.dictId) : "",
      updates: globalThis.Array.isArray(object?.updates) ? object.updates.map((e) => DictEntry.fromJSON(e)) : [],
      ifNotExists: isSet3(object.ifNotExists) ? globalThis.Boolean(object.ifNotExists) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.dictId !== "") {
      obj.dictId = message.dictId;
    }
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => DictEntry.toJSON(e));
    }
    if (message.ifNotExists !== false) {
      obj.ifNotExists = message.ifNotExists;
    }
    return obj;
  },
  create(base) {
    return DictUpdateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictUpdateRequest();
    message.dictId = object.dictId ?? "";
    message.updates = object.updates?.map((e) => DictEntry.fromPartial(e)) || [];
    message.ifNotExists = object.ifNotExists ?? false;
    return message;
  }
};
function createBaseDictUpdateResponse() {
  return { created: false };
}
var DictUpdateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.created !== false) {
      writer.uint32(8).bool(message.created);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDictUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.created = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { created: isSet3(object.created) ? globalThis.Boolean(object.created) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.created !== false) {
      obj.created = message.created;
    }
    return obj;
  },
  create(base) {
    return DictUpdateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDictUpdateResponse();
    message.created = object.created ?? false;
    return message;
  }
};
function createBaseDomain() {
  return { domainId: "", domainName: "", createdAt: 0, certificateStatus: 0, dnsRecords: [] };
}
var Domain = {
  encode(message, writer = new BinaryWriter()) {
    if (message.domainId !== "") {
      writer.uint32(10).string(message.domainId);
    }
    if (message.domainName !== "") {
      writer.uint32(18).string(message.domainName);
    }
    if (message.createdAt !== 0) {
      writer.uint32(25).double(message.createdAt);
    }
    if (message.certificateStatus !== 0) {
      writer.uint32(32).int32(message.certificateStatus);
    }
    for (const v of message.dnsRecords) {
      DNSRecord.encode(v, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.domainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.domainName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.certificateStatus = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.dnsRecords.push(DNSRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      domainId: isSet3(object.domainId) ? globalThis.String(object.domainId) : "",
      domainName: isSet3(object.domainName) ? globalThis.String(object.domainName) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      certificateStatus: isSet3(object.certificateStatus) ? certificateStatusFromJSON(object.certificateStatus) : 0,
      dnsRecords: globalThis.Array.isArray(object?.dnsRecords) ? object.dnsRecords.map((e) => DNSRecord.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.domainId !== "") {
      obj.domainId = message.domainId;
    }
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.certificateStatus !== 0) {
      obj.certificateStatus = certificateStatusToJSON(message.certificateStatus);
    }
    if (message.dnsRecords?.length) {
      obj.dnsRecords = message.dnsRecords.map((e) => DNSRecord.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Domain.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDomain();
    message.domainId = object.domainId ?? "";
    message.domainName = object.domainName ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.certificateStatus = object.certificateStatus ?? 0;
    message.dnsRecords = object.dnsRecords?.map((e) => DNSRecord.fromPartial(e)) || [];
    return message;
  }
};
function createBaseDomainCertificateVerifyRequest() {
  return { domainId: "" };
}
var DomainCertificateVerifyRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.domainId !== "") {
      writer.uint32(10).string(message.domainId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomainCertificateVerifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.domainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { domainId: isSet3(object.domainId) ? globalThis.String(object.domainId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.domainId !== "") {
      obj.domainId = message.domainId;
    }
    return obj;
  },
  create(base) {
    return DomainCertificateVerifyRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDomainCertificateVerifyRequest();
    message.domainId = object.domainId ?? "";
    return message;
  }
};
function createBaseDomainCertificateVerifyResponse() {
  return { domain: void 0 };
}
var DomainCertificateVerifyResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.domain !== void 0) {
      Domain.encode(message.domain, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomainCertificateVerifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.domain = Domain.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { domain: isSet3(object.domain) ? Domain.fromJSON(object.domain) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.domain !== void 0) {
      obj.domain = Domain.toJSON(message.domain);
    }
    return obj;
  },
  create(base) {
    return DomainCertificateVerifyResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDomainCertificateVerifyResponse();
    message.domain = object.domain !== void 0 && object.domain !== null ? Domain.fromPartial(object.domain) : void 0;
    return message;
  }
};
function createBaseDomainCreateRequest() {
  return { domainName: "" };
}
var DomainCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.domainName !== "") {
      writer.uint32(10).string(message.domainName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomainCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.domainName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { domainName: isSet3(object.domainName) ? globalThis.String(object.domainName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    return obj;
  },
  create(base) {
    return DomainCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDomainCreateRequest();
    message.domainName = object.domainName ?? "";
    return message;
  }
};
function createBaseDomainCreateResponse() {
  return { domainId: "", dnsRecords: [] };
}
var DomainCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.domainId !== "") {
      writer.uint32(10).string(message.domainId);
    }
    for (const v of message.dnsRecords) {
      DNSRecord.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomainCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.domainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dnsRecords.push(DNSRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      domainId: isSet3(object.domainId) ? globalThis.String(object.domainId) : "",
      dnsRecords: globalThis.Array.isArray(object?.dnsRecords) ? object.dnsRecords.map((e) => DNSRecord.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.domainId !== "") {
      obj.domainId = message.domainId;
    }
    if (message.dnsRecords?.length) {
      obj.dnsRecords = message.dnsRecords.map((e) => DNSRecord.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return DomainCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDomainCreateResponse();
    message.domainId = object.domainId ?? "";
    message.dnsRecords = object.dnsRecords?.map((e) => DNSRecord.fromPartial(e)) || [];
    return message;
  }
};
function createBaseDomainListRequest() {
  return {};
}
var DomainListRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomainListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return DomainListRequest.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseDomainListRequest();
    return message;
  }
};
function createBaseDomainListResponse() {
  return { domains: [] };
}
var DomainListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.domains) {
      Domain.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDomainListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.domains.push(Domain.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      domains: globalThis.Array.isArray(object?.domains) ? object.domains.map((e) => Domain.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.domains?.length) {
      obj.domains = message.domains.map((e) => Domain.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return DomainListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseDomainListResponse();
    message.domains = object.domains?.map((e) => Domain.fromPartial(e)) || [];
    return message;
  }
};
function createBaseEnvironmentCreateRequest() {
  return { name: "" };
}
var EnvironmentCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet3(object.name) ? globalThis.String(object.name) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return EnvironmentCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentCreateRequest();
    message.name = object.name ?? "";
    return message;
  }
};
function createBaseEnvironmentDeleteRequest() {
  return { name: "" };
}
var EnvironmentDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { name: isSet3(object.name) ? globalThis.String(object.name) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return EnvironmentDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentDeleteRequest();
    message.name = object.name ?? "";
    return message;
  }
};
function createBaseEnvironmentGetOrCreateRequest() {
  return { deploymentName: "", objectCreationType: 0 };
}
var EnvironmentGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(16).int32(message.objectCreationType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    return obj;
  },
  create(base) {
    return EnvironmentGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    return message;
  }
};
function createBaseEnvironmentGetOrCreateResponse() {
  return { environmentId: "", metadata: void 0 };
}
var EnvironmentGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentId !== "") {
      writer.uint32(10).string(message.environmentId);
    }
    if (message.metadata !== void 0) {
      EnvironmentMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = EnvironmentMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      environmentId: isSet3(object.environmentId) ? globalThis.String(object.environmentId) : "",
      metadata: isSet3(object.metadata) ? EnvironmentMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = EnvironmentMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return EnvironmentGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentGetOrCreateResponse();
    message.environmentId = object.environmentId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? EnvironmentMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseEnvironmentListItem() {
  return { name: "", webhookSuffix: "", createdAt: 0, default: false, isManaged: false, environmentId: "" };
}
var EnvironmentListItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.webhookSuffix !== "") {
      writer.uint32(18).string(message.webhookSuffix);
    }
    if (message.createdAt !== 0) {
      writer.uint32(25).double(message.createdAt);
    }
    if (message.default !== false) {
      writer.uint32(32).bool(message.default);
    }
    if (message.isManaged !== false) {
      writer.uint32(40).bool(message.isManaged);
    }
    if (message.environmentId !== "") {
      writer.uint32(50).string(message.environmentId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.webhookSuffix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.default = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.isManaged = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.environmentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      webhookSuffix: isSet3(object.webhookSuffix) ? globalThis.String(object.webhookSuffix) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      default: isSet3(object.default) ? globalThis.Boolean(object.default) : false,
      isManaged: isSet3(object.isManaged) ? globalThis.Boolean(object.isManaged) : false,
      environmentId: isSet3(object.environmentId) ? globalThis.String(object.environmentId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.webhookSuffix !== "") {
      obj.webhookSuffix = message.webhookSuffix;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.default !== false) {
      obj.default = message.default;
    }
    if (message.isManaged !== false) {
      obj.isManaged = message.isManaged;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    return obj;
  },
  create(base) {
    return EnvironmentListItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentListItem();
    message.name = object.name ?? "";
    message.webhookSuffix = object.webhookSuffix ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.default = object.default ?? false;
    message.isManaged = object.isManaged ?? false;
    message.environmentId = object.environmentId ?? "";
    return message;
  }
};
function createBaseEnvironmentListResponse() {
  return { items: [] };
}
var EnvironmentListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      EnvironmentListItem.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.items.push(EnvironmentListItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => EnvironmentListItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => EnvironmentListItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return EnvironmentListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentListResponse();
    message.items = object.items?.map((e) => EnvironmentListItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseEnvironmentMetadata() {
  return { name: "", settings: void 0 };
}
var EnvironmentMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.settings !== void 0) {
      EnvironmentSettings.encode(message.settings, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.settings = EnvironmentSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      settings: isSet3(object.settings) ? EnvironmentSettings.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.settings !== void 0) {
      obj.settings = EnvironmentSettings.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return EnvironmentMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentMetadata();
    message.name = object.name ?? "";
    message.settings = object.settings !== void 0 && object.settings !== null ? EnvironmentSettings.fromPartial(object.settings) : void 0;
    return message;
  }
};
function createBaseEnvironmentSettings() {
  return { imageBuilderVersion: "", webhookSuffix: "" };
}
var EnvironmentSettings = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageBuilderVersion !== "") {
      writer.uint32(10).string(message.imageBuilderVersion);
    }
    if (message.webhookSuffix !== "") {
      writer.uint32(18).string(message.webhookSuffix);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageBuilderVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.webhookSuffix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageBuilderVersion: isSet3(object.imageBuilderVersion) ? globalThis.String(object.imageBuilderVersion) : "",
      webhookSuffix: isSet3(object.webhookSuffix) ? globalThis.String(object.webhookSuffix) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageBuilderVersion !== "") {
      obj.imageBuilderVersion = message.imageBuilderVersion;
    }
    if (message.webhookSuffix !== "") {
      obj.webhookSuffix = message.webhookSuffix;
    }
    return obj;
  },
  create(base) {
    return EnvironmentSettings.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentSettings();
    message.imageBuilderVersion = object.imageBuilderVersion ?? "";
    message.webhookSuffix = object.webhookSuffix ?? "";
    return message;
  }
};
function createBaseEnvironmentUpdateRequest() {
  return { currentName: "", name: void 0, webSuffix: void 0 };
}
var EnvironmentUpdateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.currentName !== "") {
      writer.uint32(10).string(message.currentName);
    }
    if (message.name !== void 0) {
      StringValue.encode({ value: message.name }, writer.uint32(18).fork()).join();
    }
    if (message.webSuffix !== void 0) {
      StringValue.encode({ value: message.webSuffix }, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.currentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.webSuffix = StringValue.decode(reader, reader.uint32()).value;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      currentName: isSet3(object.currentName) ? globalThis.String(object.currentName) : "",
      name: isSet3(object.name) ? String(object.name) : void 0,
      webSuffix: isSet3(object.webSuffix) ? String(object.webSuffix) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.currentName !== "") {
      obj.currentName = message.currentName;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.webSuffix !== void 0) {
      obj.webSuffix = message.webSuffix;
    }
    return obj;
  },
  create(base) {
    return EnvironmentUpdateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseEnvironmentUpdateRequest();
    message.currentName = object.currentName ?? "";
    message.name = object.name ?? void 0;
    message.webSuffix = object.webSuffix ?? void 0;
    return message;
  }
};
function createBaseFileEntry() {
  return { path: "", type: 0, mtime: 0, size: 0 };
}
var FileEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.mtime !== 0) {
      writer.uint32(24).uint64(message.mtime);
    }
    if (message.size !== 0) {
      writer.uint32(32).uint64(message.size);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFileEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.mtime = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.size = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      type: isSet3(object.type) ? fileEntry_FileTypeFromJSON(object.type) : 0,
      mtime: isSet3(object.mtime) ? globalThis.Number(object.mtime) : 0,
      size: isSet3(object.size) ? globalThis.Number(object.size) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== 0) {
      obj.type = fileEntry_FileTypeToJSON(message.type);
    }
    if (message.mtime !== 0) {
      obj.mtime = Math.round(message.mtime);
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },
  create(base) {
    return FileEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFileEntry();
    message.path = object.path ?? "";
    message.type = object.type ?? 0;
    message.mtime = object.mtime ?? 0;
    message.size = object.size ?? 0;
    return message;
  }
};
function createBaseFilesystemRuntimeOutputBatch() {
  return { output: [], error: void 0, batchIndex: 0, eof: false };
}
var FilesystemRuntimeOutputBatch = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.output) {
      writer.uint32(10).bytes(v);
    }
    if (message.error !== void 0) {
      SystemErrorMessage.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.batchIndex !== 0) {
      writer.uint32(24).uint64(message.batchIndex);
    }
    if (message.eof !== false) {
      writer.uint32(32).bool(message.eof);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFilesystemRuntimeOutputBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.output.push(reader.bytes());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.error = SystemErrorMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.batchIndex = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.eof = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      output: globalThis.Array.isArray(object?.output) ? object.output.map((e) => bytesFromBase64(e)) : [],
      error: isSet3(object.error) ? SystemErrorMessage.fromJSON(object.error) : void 0,
      batchIndex: isSet3(object.batchIndex) ? globalThis.Number(object.batchIndex) : 0,
      eof: isSet3(object.eof) ? globalThis.Boolean(object.eof) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.output?.length) {
      obj.output = message.output.map((e) => base64FromBytes(e));
    }
    if (message.error !== void 0) {
      obj.error = SystemErrorMessage.toJSON(message.error);
    }
    if (message.batchIndex !== 0) {
      obj.batchIndex = Math.round(message.batchIndex);
    }
    if (message.eof !== false) {
      obj.eof = message.eof;
    }
    return obj;
  },
  create(base) {
    return FilesystemRuntimeOutputBatch.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFilesystemRuntimeOutputBatch();
    message.output = object.output?.map((e) => e) || [];
    message.error = object.error !== void 0 && object.error !== null ? SystemErrorMessage.fromPartial(object.error) : void 0;
    message.batchIndex = object.batchIndex ?? 0;
    message.eof = object.eof ?? false;
    return message;
  }
};
function createBaseFlashContainerDeregisterRequest() {
  return { serviceName: "" };
}
var FlashContainerDeregisterRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlashContainerDeregisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.serviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { serviceName: isSet3(object.serviceName) ? globalThis.String(object.serviceName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },
  create(base) {
    return FlashContainerDeregisterRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlashContainerDeregisterRequest();
    message.serviceName = object.serviceName ?? "";
    return message;
  }
};
function createBaseFlashContainerListRequest() {
  return { functionId: "" };
}
var FlashContainerListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlashContainerListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    return obj;
  },
  create(base) {
    return FlashContainerListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlashContainerListRequest();
    message.functionId = object.functionId ?? "";
    return message;
  }
};
function createBaseFlashContainerListResponse() {
  return { containers: [] };
}
var FlashContainerListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.containers) {
      FlashContainerListResponse_Container.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlashContainerListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.containers.push(FlashContainerListResponse_Container.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      containers: globalThis.Array.isArray(object?.containers) ? object.containers.map((e) => FlashContainerListResponse_Container.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => FlashContainerListResponse_Container.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FlashContainerListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlashContainerListResponse();
    message.containers = object.containers?.map((e) => FlashContainerListResponse_Container.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFlashContainerListResponse_Container() {
  return { taskId: "", host: "", port: 0 };
}
var FlashContainerListResponse_Container = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlashContainerListResponse_Container();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      host: isSet3(object.host) ? globalThis.String(object.host) : "",
      port: isSet3(object.port) ? globalThis.Number(object.port) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },
  create(base) {
    return FlashContainerListResponse_Container.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlashContainerListResponse_Container();
    message.taskId = object.taskId ?? "";
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  }
};
function createBaseFlashContainerRegisterRequest() {
  return { serviceName: "", priority: 0, weight: 0, host: "", port: 0 };
}
var FlashContainerRegisterRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.priority !== 0) {
      writer.uint32(16).uint32(message.priority);
    }
    if (message.weight !== 0) {
      writer.uint32(24).uint32(message.weight);
    }
    if (message.host !== "") {
      writer.uint32(34).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(40).uint32(message.port);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlashContainerRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.priority = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.weight = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.host = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      serviceName: isSet3(object.serviceName) ? globalThis.String(object.serviceName) : "",
      priority: isSet3(object.priority) ? globalThis.Number(object.priority) : 0,
      weight: isSet3(object.weight) ? globalThis.Number(object.weight) : 0,
      host: isSet3(object.host) ? globalThis.String(object.host) : "",
      port: isSet3(object.port) ? globalThis.Number(object.port) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },
  create(base) {
    return FlashContainerRegisterRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlashContainerRegisterRequest();
    message.serviceName = object.serviceName ?? "";
    message.priority = object.priority ?? 0;
    message.weight = object.weight ?? 0;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  }
};
function createBaseFlashContainerRegisterResponse() {
  return { url: "" };
}
var FlashContainerRegisterResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFlashContainerRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { url: isSet3(object.url) ? globalThis.String(object.url) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },
  create(base) {
    return FlashContainerRegisterResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFlashContainerRegisterResponse();
    message.url = object.url ?? "";
    return message;
  }
};
function createBaseFunctionMessage() {
  return {
    moduleName: "",
    functionName: "",
    mountIds: [],
    imageId: "",
    functionSerialized: new Uint8Array(0),
    definitionType: 0,
    functionType: 0,
    resources: void 0,
    secretIds: [],
    rateLimit: void 0,
    webhookConfig: void 0,
    sharedVolumeMounts: [],
    proxyId: void 0,
    retryPolicy: void 0,
    concurrencyLimit: 0,
    timeoutSecs: 0,
    ptyInfo: void 0,
    classSerialized: new Uint8Array(0),
    taskIdleTimeoutSecs: 0,
    cloudProvider: void 0,
    warmPoolSize: 0,
    webUrl: "",
    webUrlInfo: void 0,
    runtime: "",
    appName: "",
    volumeMounts: [],
    maxConcurrentInputs: 0,
    customDomainInfo: [],
    workerId: "",
    runtimeDebug: false,
    isBuilderFunction: false,
    isAutoSnapshot: false,
    isMethod: false,
    isCheckpointingFunction: false,
    checkpointingEnabled: false,
    checkpoint: void 0,
    objectDependencies: [],
    blockNetwork: false,
    maxInputs: 0,
    s3Mounts: [],
    cloudBucketMounts: [],
    schedulerPlacement: void 0,
    isClass: false,
    useFunctionId: "",
    useMethodName: "",
    classParameterInfo: void 0,
    batchMaxSize: 0,
    batchLingerMs: 0,
    i6pnEnabled: false,
    ExperimentalConcurrentCancellations: false,
    targetConcurrentInputs: 0,
    ExperimentalTaskTemplatesEnabled: false,
    ExperimentalTaskTemplates: [],
    ExperimentalGroupSize: 0,
    untrusted: false,
    ExperimentalBufferContainers: 0,
    ExperimentalProxyIp: void 0,
    runtimePerfRecord: false,
    schedule: void 0,
    snapshotDebug: false,
    methodDefinitions: {},
    methodDefinitionsSet: false,
    ExperimentalCustomScaling: false,
    cloudProviderStr: "",
    ExperimentalEnableGpuSnapshot: false,
    autoscalerSettings: void 0,
    functionSchema: void 0,
    experimentalOptions: {},
    mountClientDependencies: false,
    flashServiceUrls: [],
    flashServiceLabel: "",
    enableGpuSnapshot: false,
    startupTimeoutSecs: 0,
    supportedInputFormats: [],
    supportedOutputFormats: []
  };
}
var FunctionMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.functionName !== "") {
      writer.uint32(18).string(message.functionName);
    }
    for (const v of message.mountIds) {
      writer.uint32(26).string(v);
    }
    if (message.imageId !== "") {
      writer.uint32(34).string(message.imageId);
    }
    if (message.functionSerialized.length !== 0) {
      writer.uint32(50).bytes(message.functionSerialized);
    }
    if (message.definitionType !== 0) {
      writer.uint32(56).int32(message.definitionType);
    }
    if (message.functionType !== 0) {
      writer.uint32(64).int32(message.functionType);
    }
    if (message.resources !== void 0) {
      Resources.encode(message.resources, writer.uint32(74).fork()).join();
    }
    for (const v of message.secretIds) {
      writer.uint32(82).string(v);
    }
    if (message.rateLimit !== void 0) {
      RateLimit.encode(message.rateLimit, writer.uint32(90).fork()).join();
    }
    if (message.webhookConfig !== void 0) {
      WebhookConfig.encode(message.webhookConfig, writer.uint32(122).fork()).join();
    }
    for (const v of message.sharedVolumeMounts) {
      SharedVolumeMount.encode(v, writer.uint32(130).fork()).join();
    }
    if (message.proxyId !== void 0) {
      writer.uint32(138).string(message.proxyId);
    }
    if (message.retryPolicy !== void 0) {
      FunctionRetryPolicy.encode(message.retryPolicy, writer.uint32(146).fork()).join();
    }
    if (message.concurrencyLimit !== 0) {
      writer.uint32(152).uint32(message.concurrencyLimit);
    }
    if (message.timeoutSecs !== 0) {
      writer.uint32(168).uint32(message.timeoutSecs);
    }
    if (message.ptyInfo !== void 0) {
      PTYInfo.encode(message.ptyInfo, writer.uint32(178).fork()).join();
    }
    if (message.classSerialized.length !== 0) {
      writer.uint32(186).bytes(message.classSerialized);
    }
    if (message.taskIdleTimeoutSecs !== 0) {
      writer.uint32(200).uint32(message.taskIdleTimeoutSecs);
    }
    if (message.cloudProvider !== void 0) {
      writer.uint32(208).int32(message.cloudProvider);
    }
    if (message.warmPoolSize !== 0) {
      writer.uint32(216).uint32(message.warmPoolSize);
    }
    if (message.webUrl !== "") {
      writer.uint32(226).string(message.webUrl);
    }
    if (message.webUrlInfo !== void 0) {
      WebUrlInfo.encode(message.webUrlInfo, writer.uint32(234).fork()).join();
    }
    if (message.runtime !== "") {
      writer.uint32(242).string(message.runtime);
    }
    if (message.appName !== "") {
      writer.uint32(250).string(message.appName);
    }
    for (const v of message.volumeMounts) {
      VolumeMount.encode(v, writer.uint32(266).fork()).join();
    }
    if (message.maxConcurrentInputs !== 0) {
      writer.uint32(272).uint32(message.maxConcurrentInputs);
    }
    for (const v of message.customDomainInfo) {
      CustomDomainInfo.encode(v, writer.uint32(282).fork()).join();
    }
    if (message.workerId !== "") {
      writer.uint32(290).string(message.workerId);
    }
    if (message.runtimeDebug !== false) {
      writer.uint32(296).bool(message.runtimeDebug);
    }
    if (message.isBuilderFunction !== false) {
      writer.uint32(256).bool(message.isBuilderFunction);
    }
    if (message.isAutoSnapshot !== false) {
      writer.uint32(304).bool(message.isAutoSnapshot);
    }
    if (message.isMethod !== false) {
      writer.uint32(312).bool(message.isMethod);
    }
    if (message.isCheckpointingFunction !== false) {
      writer.uint32(320).bool(message.isCheckpointingFunction);
    }
    if (message.checkpointingEnabled !== false) {
      writer.uint32(328).bool(message.checkpointingEnabled);
    }
    if (message.checkpoint !== void 0) {
      CheckpointInfo.encode(message.checkpoint, writer.uint32(338).fork()).join();
    }
    for (const v of message.objectDependencies) {
      ObjectDependency.encode(v, writer.uint32(346).fork()).join();
    }
    if (message.blockNetwork !== false) {
      writer.uint32(352).bool(message.blockNetwork);
    }
    if (message.maxInputs !== 0) {
      writer.uint32(368).uint32(message.maxInputs);
    }
    for (const v of message.s3Mounts) {
      S3Mount.encode(v, writer.uint32(378).fork()).join();
    }
    for (const v of message.cloudBucketMounts) {
      CloudBucketMount.encode(v, writer.uint32(410).fork()).join();
    }
    if (message.schedulerPlacement !== void 0) {
      SchedulerPlacement.encode(message.schedulerPlacement, writer.uint32(402).fork()).join();
    }
    if (message.isClass !== false) {
      writer.uint32(424).bool(message.isClass);
    }
    if (message.useFunctionId !== "") {
      writer.uint32(434).string(message.useFunctionId);
    }
    if (message.useMethodName !== "") {
      writer.uint32(442).string(message.useMethodName);
    }
    if (message.classParameterInfo !== void 0) {
      ClassParameterInfo.encode(message.classParameterInfo, writer.uint32(450).fork()).join();
    }
    if (message.batchMaxSize !== 0) {
      writer.uint32(480).uint32(message.batchMaxSize);
    }
    if (message.batchLingerMs !== 0) {
      writer.uint32(488).uint64(message.batchLingerMs);
    }
    if (message.i6pnEnabled !== false) {
      writer.uint32(496).bool(message.i6pnEnabled);
    }
    if (message.ExperimentalConcurrentCancellations !== false) {
      writer.uint32(504).bool(message.ExperimentalConcurrentCancellations);
    }
    if (message.targetConcurrentInputs !== 0) {
      writer.uint32(512).uint32(message.targetConcurrentInputs);
    }
    if (message.ExperimentalTaskTemplatesEnabled !== false) {
      writer.uint32(520).bool(message.ExperimentalTaskTemplatesEnabled);
    }
    for (const v of message.ExperimentalTaskTemplates) {
      TaskTemplate.encode(v, writer.uint32(530).fork()).join();
    }
    if (message.ExperimentalGroupSize !== 0) {
      writer.uint32(536).uint32(message.ExperimentalGroupSize);
    }
    if (message.untrusted !== false) {
      writer.uint32(544).bool(message.untrusted);
    }
    if (message.ExperimentalBufferContainers !== 0) {
      writer.uint32(552).uint32(message.ExperimentalBufferContainers);
    }
    if (message.ExperimentalProxyIp !== void 0) {
      writer.uint32(562).string(message.ExperimentalProxyIp);
    }
    if (message.runtimePerfRecord !== false) {
      writer.uint32(568).bool(message.runtimePerfRecord);
    }
    if (message.schedule !== void 0) {
      Schedule.encode(message.schedule, writer.uint32(578).fork()).join();
    }
    if (message.snapshotDebug !== false) {
      writer.uint32(584).bool(message.snapshotDebug);
    }
    Object.entries(message.methodDefinitions).forEach(([key, value]) => {
      Function_MethodDefinitionsEntry.encode({ key, value }, writer.uint32(594).fork()).join();
    });
    if (message.methodDefinitionsSet !== false) {
      writer.uint32(600).bool(message.methodDefinitionsSet);
    }
    if (message.ExperimentalCustomScaling !== false) {
      writer.uint32(608).bool(message.ExperimentalCustomScaling);
    }
    if (message.cloudProviderStr !== "") {
      writer.uint32(618).string(message.cloudProviderStr);
    }
    if (message.ExperimentalEnableGpuSnapshot !== false) {
      writer.uint32(624).bool(message.ExperimentalEnableGpuSnapshot);
    }
    if (message.autoscalerSettings !== void 0) {
      AutoscalerSettings.encode(message.autoscalerSettings, writer.uint32(634).fork()).join();
    }
    if (message.functionSchema !== void 0) {
      FunctionSchema.encode(message.functionSchema, writer.uint32(642).fork()).join();
    }
    Object.entries(message.experimentalOptions).forEach(([key, value]) => {
      Function_ExperimentalOptionsEntry.encode({ key, value }, writer.uint32(650).fork()).join();
    });
    if (message.mountClientDependencies !== false) {
      writer.uint32(656).bool(message.mountClientDependencies);
    }
    for (const v of message.flashServiceUrls) {
      writer.uint32(666).string(v);
    }
    if (message.flashServiceLabel !== "") {
      writer.uint32(674).string(message.flashServiceLabel);
    }
    if (message.enableGpuSnapshot !== false) {
      writer.uint32(680).bool(message.enableGpuSnapshot);
    }
    if (message.startupTimeoutSecs !== 0) {
      writer.uint32(688).uint32(message.startupTimeoutSecs);
    }
    writer.uint32(698).fork();
    for (const v of message.supportedInputFormats) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(706).fork();
    for (const v of message.supportedOutputFormats) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.mountIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.functionSerialized = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.definitionType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.functionType = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.resources = Resources.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.secretIds.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.rateLimit = RateLimit.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.webhookConfig = WebhookConfig.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.sharedVolumeMounts.push(SharedVolumeMount.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.proxyId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.retryPolicy = FunctionRetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }
          message.concurrencyLimit = reader.uint32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }
          message.timeoutSecs = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }
          message.ptyInfo = PTYInfo.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }
          message.classSerialized = reader.bytes();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }
          message.taskIdleTimeoutSecs = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }
          message.cloudProvider = reader.int32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }
          message.warmPoolSize = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }
          message.webUrl = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }
          message.webUrlInfo = WebUrlInfo.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }
          message.runtime = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }
          message.appName = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }
          message.volumeMounts.push(VolumeMount.decode(reader, reader.uint32()));
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }
          message.maxConcurrentInputs = reader.uint32();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }
          message.customDomainInfo.push(CustomDomainInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }
          message.workerId = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }
          message.runtimeDebug = reader.bool();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }
          message.isBuilderFunction = reader.bool();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }
          message.isAutoSnapshot = reader.bool();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }
          message.isMethod = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }
          message.isCheckpointingFunction = reader.bool();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }
          message.checkpointingEnabled = reader.bool();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }
          message.checkpoint = CheckpointInfo.decode(reader, reader.uint32());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }
          message.objectDependencies.push(ObjectDependency.decode(reader, reader.uint32()));
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }
          message.blockNetwork = reader.bool();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }
          message.maxInputs = reader.uint32();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }
          message.s3Mounts.push(S3Mount.decode(reader, reader.uint32()));
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }
          message.cloudBucketMounts.push(CloudBucketMount.decode(reader, reader.uint32()));
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }
          message.schedulerPlacement = SchedulerPlacement.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }
          message.isClass = reader.bool();
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }
          message.useFunctionId = reader.string();
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }
          message.useMethodName = reader.string();
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }
          message.classParameterInfo = ClassParameterInfo.decode(reader, reader.uint32());
          continue;
        }
        case 60: {
          if (tag !== 480) {
            break;
          }
          message.batchMaxSize = reader.uint32();
          continue;
        }
        case 61: {
          if (tag !== 488) {
            break;
          }
          message.batchLingerMs = longToNumber(reader.uint64());
          continue;
        }
        case 62: {
          if (tag !== 496) {
            break;
          }
          message.i6pnEnabled = reader.bool();
          continue;
        }
        case 63: {
          if (tag !== 504) {
            break;
          }
          message.ExperimentalConcurrentCancellations = reader.bool();
          continue;
        }
        case 64: {
          if (tag !== 512) {
            break;
          }
          message.targetConcurrentInputs = reader.uint32();
          continue;
        }
        case 65: {
          if (tag !== 520) {
            break;
          }
          message.ExperimentalTaskTemplatesEnabled = reader.bool();
          continue;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }
          message.ExperimentalTaskTemplates.push(TaskTemplate.decode(reader, reader.uint32()));
          continue;
        }
        case 67: {
          if (tag !== 536) {
            break;
          }
          message.ExperimentalGroupSize = reader.uint32();
          continue;
        }
        case 68: {
          if (tag !== 544) {
            break;
          }
          message.untrusted = reader.bool();
          continue;
        }
        case 69: {
          if (tag !== 552) {
            break;
          }
          message.ExperimentalBufferContainers = reader.uint32();
          continue;
        }
        case 70: {
          if (tag !== 562) {
            break;
          }
          message.ExperimentalProxyIp = reader.string();
          continue;
        }
        case 71: {
          if (tag !== 568) {
            break;
          }
          message.runtimePerfRecord = reader.bool();
          continue;
        }
        case 72: {
          if (tag !== 578) {
            break;
          }
          message.schedule = Schedule.decode(reader, reader.uint32());
          continue;
        }
        case 73: {
          if (tag !== 584) {
            break;
          }
          message.snapshotDebug = reader.bool();
          continue;
        }
        case 74: {
          if (tag !== 594) {
            break;
          }
          const entry74 = Function_MethodDefinitionsEntry.decode(reader, reader.uint32());
          if (entry74.value !== void 0) {
            message.methodDefinitions[entry74.key] = entry74.value;
          }
          continue;
        }
        case 75: {
          if (tag !== 600) {
            break;
          }
          message.methodDefinitionsSet = reader.bool();
          continue;
        }
        case 76: {
          if (tag !== 608) {
            break;
          }
          message.ExperimentalCustomScaling = reader.bool();
          continue;
        }
        case 77: {
          if (tag !== 618) {
            break;
          }
          message.cloudProviderStr = reader.string();
          continue;
        }
        case 78: {
          if (tag !== 624) {
            break;
          }
          message.ExperimentalEnableGpuSnapshot = reader.bool();
          continue;
        }
        case 79: {
          if (tag !== 634) {
            break;
          }
          message.autoscalerSettings = AutoscalerSettings.decode(reader, reader.uint32());
          continue;
        }
        case 80: {
          if (tag !== 642) {
            break;
          }
          message.functionSchema = FunctionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 81: {
          if (tag !== 650) {
            break;
          }
          const entry81 = Function_ExperimentalOptionsEntry.decode(reader, reader.uint32());
          if (entry81.value !== void 0) {
            message.experimentalOptions[entry81.key] = entry81.value;
          }
          continue;
        }
        case 82: {
          if (tag !== 656) {
            break;
          }
          message.mountClientDependencies = reader.bool();
          continue;
        }
        case 83: {
          if (tag !== 666) {
            break;
          }
          message.flashServiceUrls.push(reader.string());
          continue;
        }
        case 84: {
          if (tag !== 674) {
            break;
          }
          message.flashServiceLabel = reader.string();
          continue;
        }
        case 85: {
          if (tag !== 680) {
            break;
          }
          message.enableGpuSnapshot = reader.bool();
          continue;
        }
        case 86: {
          if (tag !== 688) {
            break;
          }
          message.startupTimeoutSecs = reader.uint32();
          continue;
        }
        case 87: {
          if (tag === 696) {
            message.supportedInputFormats.push(reader.int32());
            continue;
          }
          if (tag === 698) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedInputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 88: {
          if (tag === 704) {
            message.supportedOutputFormats.push(reader.int32());
            continue;
          }
          if (tag === 706) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedOutputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      moduleName: isSet3(object.moduleName) ? globalThis.String(object.moduleName) : "",
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      mountIds: globalThis.Array.isArray(object?.mountIds) ? object.mountIds.map((e) => globalThis.String(e)) : [],
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      functionSerialized: isSet3(object.functionSerialized) ? bytesFromBase64(object.functionSerialized) : new Uint8Array(0),
      definitionType: isSet3(object.definitionType) ? function_DefinitionTypeFromJSON(object.definitionType) : 0,
      functionType: isSet3(object.functionType) ? function_FunctionTypeFromJSON(object.functionType) : 0,
      resources: isSet3(object.resources) ? Resources.fromJSON(object.resources) : void 0,
      secretIds: globalThis.Array.isArray(object?.secretIds) ? object.secretIds.map((e) => globalThis.String(e)) : [],
      rateLimit: isSet3(object.rateLimit) ? RateLimit.fromJSON(object.rateLimit) : void 0,
      webhookConfig: isSet3(object.webhookConfig) ? WebhookConfig.fromJSON(object.webhookConfig) : void 0,
      sharedVolumeMounts: globalThis.Array.isArray(object?.sharedVolumeMounts) ? object.sharedVolumeMounts.map((e) => SharedVolumeMount.fromJSON(e)) : [],
      proxyId: isSet3(object.proxyId) ? globalThis.String(object.proxyId) : void 0,
      retryPolicy: isSet3(object.retryPolicy) ? FunctionRetryPolicy.fromJSON(object.retryPolicy) : void 0,
      concurrencyLimit: isSet3(object.concurrencyLimit) ? globalThis.Number(object.concurrencyLimit) : 0,
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : 0,
      ptyInfo: isSet3(object.ptyInfo) ? PTYInfo.fromJSON(object.ptyInfo) : void 0,
      classSerialized: isSet3(object.classSerialized) ? bytesFromBase64(object.classSerialized) : new Uint8Array(0),
      taskIdleTimeoutSecs: isSet3(object.taskIdleTimeoutSecs) ? globalThis.Number(object.taskIdleTimeoutSecs) : 0,
      cloudProvider: isSet3(object.cloudProvider) ? cloudProviderFromJSON(object.cloudProvider) : void 0,
      warmPoolSize: isSet3(object.warmPoolSize) ? globalThis.Number(object.warmPoolSize) : 0,
      webUrl: isSet3(object.webUrl) ? globalThis.String(object.webUrl) : "",
      webUrlInfo: isSet3(object.webUrlInfo) ? WebUrlInfo.fromJSON(object.webUrlInfo) : void 0,
      runtime: isSet3(object.runtime) ? globalThis.String(object.runtime) : "",
      appName: isSet3(object.appName) ? globalThis.String(object.appName) : "",
      volumeMounts: globalThis.Array.isArray(object?.volumeMounts) ? object.volumeMounts.map((e) => VolumeMount.fromJSON(e)) : [],
      maxConcurrentInputs: isSet3(object.maxConcurrentInputs) ? globalThis.Number(object.maxConcurrentInputs) : 0,
      customDomainInfo: globalThis.Array.isArray(object?.customDomainInfo) ? object.customDomainInfo.map((e) => CustomDomainInfo.fromJSON(e)) : [],
      workerId: isSet3(object.workerId) ? globalThis.String(object.workerId) : "",
      runtimeDebug: isSet3(object.runtimeDebug) ? globalThis.Boolean(object.runtimeDebug) : false,
      isBuilderFunction: isSet3(object.isBuilderFunction) ? globalThis.Boolean(object.isBuilderFunction) : false,
      isAutoSnapshot: isSet3(object.isAutoSnapshot) ? globalThis.Boolean(object.isAutoSnapshot) : false,
      isMethod: isSet3(object.isMethod) ? globalThis.Boolean(object.isMethod) : false,
      isCheckpointingFunction: isSet3(object.isCheckpointingFunction) ? globalThis.Boolean(object.isCheckpointingFunction) : false,
      checkpointingEnabled: isSet3(object.checkpointingEnabled) ? globalThis.Boolean(object.checkpointingEnabled) : false,
      checkpoint: isSet3(object.checkpoint) ? CheckpointInfo.fromJSON(object.checkpoint) : void 0,
      objectDependencies: globalThis.Array.isArray(object?.objectDependencies) ? object.objectDependencies.map((e) => ObjectDependency.fromJSON(e)) : [],
      blockNetwork: isSet3(object.blockNetwork) ? globalThis.Boolean(object.blockNetwork) : false,
      maxInputs: isSet3(object.maxInputs) ? globalThis.Number(object.maxInputs) : 0,
      s3Mounts: globalThis.Array.isArray(object?.s3Mounts) ? object.s3Mounts.map((e) => S3Mount.fromJSON(e)) : [],
      cloudBucketMounts: globalThis.Array.isArray(object?.cloudBucketMounts) ? object.cloudBucketMounts.map((e) => CloudBucketMount.fromJSON(e)) : [],
      schedulerPlacement: isSet3(object.schedulerPlacement) ? SchedulerPlacement.fromJSON(object.schedulerPlacement) : void 0,
      isClass: isSet3(object.isClass) ? globalThis.Boolean(object.isClass) : false,
      useFunctionId: isSet3(object.useFunctionId) ? globalThis.String(object.useFunctionId) : "",
      useMethodName: isSet3(object.useMethodName) ? globalThis.String(object.useMethodName) : "",
      classParameterInfo: isSet3(object.classParameterInfo) ? ClassParameterInfo.fromJSON(object.classParameterInfo) : void 0,
      batchMaxSize: isSet3(object.batchMaxSize) ? globalThis.Number(object.batchMaxSize) : 0,
      batchLingerMs: isSet3(object.batchLingerMs) ? globalThis.Number(object.batchLingerMs) : 0,
      i6pnEnabled: isSet3(object.i6pnEnabled) ? globalThis.Boolean(object.i6pnEnabled) : false,
      ExperimentalConcurrentCancellations: isSet3(object.ExperimentalConcurrentCancellations) ? globalThis.Boolean(object.ExperimentalConcurrentCancellations) : false,
      targetConcurrentInputs: isSet3(object.targetConcurrentInputs) ? globalThis.Number(object.targetConcurrentInputs) : 0,
      ExperimentalTaskTemplatesEnabled: isSet3(object.ExperimentalTaskTemplatesEnabled) ? globalThis.Boolean(object.ExperimentalTaskTemplatesEnabled) : false,
      ExperimentalTaskTemplates: globalThis.Array.isArray(object?.ExperimentalTaskTemplates) ? object.ExperimentalTaskTemplates.map((e) => TaskTemplate.fromJSON(e)) : [],
      ExperimentalGroupSize: isSet3(object.ExperimentalGroupSize) ? globalThis.Number(object.ExperimentalGroupSize) : 0,
      untrusted: isSet3(object.untrusted) ? globalThis.Boolean(object.untrusted) : false,
      ExperimentalBufferContainers: isSet3(object.ExperimentalBufferContainers) ? globalThis.Number(object.ExperimentalBufferContainers) : 0,
      ExperimentalProxyIp: isSet3(object.ExperimentalProxyIp) ? globalThis.String(object.ExperimentalProxyIp) : void 0,
      runtimePerfRecord: isSet3(object.runtimePerfRecord) ? globalThis.Boolean(object.runtimePerfRecord) : false,
      schedule: isSet3(object.schedule) ? Schedule.fromJSON(object.schedule) : void 0,
      snapshotDebug: isSet3(object.snapshotDebug) ? globalThis.Boolean(object.snapshotDebug) : false,
      methodDefinitions: isObject2(object.methodDefinitions) ? Object.entries(object.methodDefinitions).reduce((acc, [key, value]) => {
        acc[key] = MethodDefinition.fromJSON(value);
        return acc;
      }, {}) : {},
      methodDefinitionsSet: isSet3(object.methodDefinitionsSet) ? globalThis.Boolean(object.methodDefinitionsSet) : false,
      ExperimentalCustomScaling: isSet3(object.ExperimentalCustomScaling) ? globalThis.Boolean(object.ExperimentalCustomScaling) : false,
      cloudProviderStr: isSet3(object.cloudProviderStr) ? globalThis.String(object.cloudProviderStr) : "",
      ExperimentalEnableGpuSnapshot: isSet3(object.ExperimentalEnableGpuSnapshot) ? globalThis.Boolean(object.ExperimentalEnableGpuSnapshot) : false,
      autoscalerSettings: isSet3(object.autoscalerSettings) ? AutoscalerSettings.fromJSON(object.autoscalerSettings) : void 0,
      functionSchema: isSet3(object.functionSchema) ? FunctionSchema.fromJSON(object.functionSchema) : void 0,
      experimentalOptions: isObject2(object.experimentalOptions) ? Object.entries(object.experimentalOptions).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      mountClientDependencies: isSet3(object.mountClientDependencies) ? globalThis.Boolean(object.mountClientDependencies) : false,
      flashServiceUrls: globalThis.Array.isArray(object?.flashServiceUrls) ? object.flashServiceUrls.map((e) => globalThis.String(e)) : [],
      flashServiceLabel: isSet3(object.flashServiceLabel) ? globalThis.String(object.flashServiceLabel) : "",
      enableGpuSnapshot: isSet3(object.enableGpuSnapshot) ? globalThis.Boolean(object.enableGpuSnapshot) : false,
      startupTimeoutSecs: isSet3(object.startupTimeoutSecs) ? globalThis.Number(object.startupTimeoutSecs) : 0,
      supportedInputFormats: globalThis.Array.isArray(object?.supportedInputFormats) ? object.supportedInputFormats.map((e) => dataFormatFromJSON(e)) : [],
      supportedOutputFormats: globalThis.Array.isArray(object?.supportedOutputFormats) ? object.supportedOutputFormats.map((e) => dataFormatFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.mountIds?.length) {
      obj.mountIds = message.mountIds;
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.functionSerialized.length !== 0) {
      obj.functionSerialized = base64FromBytes(message.functionSerialized);
    }
    if (message.definitionType !== 0) {
      obj.definitionType = function_DefinitionTypeToJSON(message.definitionType);
    }
    if (message.functionType !== 0) {
      obj.functionType = function_FunctionTypeToJSON(message.functionType);
    }
    if (message.resources !== void 0) {
      obj.resources = Resources.toJSON(message.resources);
    }
    if (message.secretIds?.length) {
      obj.secretIds = message.secretIds;
    }
    if (message.rateLimit !== void 0) {
      obj.rateLimit = RateLimit.toJSON(message.rateLimit);
    }
    if (message.webhookConfig !== void 0) {
      obj.webhookConfig = WebhookConfig.toJSON(message.webhookConfig);
    }
    if (message.sharedVolumeMounts?.length) {
      obj.sharedVolumeMounts = message.sharedVolumeMounts.map((e) => SharedVolumeMount.toJSON(e));
    }
    if (message.proxyId !== void 0) {
      obj.proxyId = message.proxyId;
    }
    if (message.retryPolicy !== void 0) {
      obj.retryPolicy = FunctionRetryPolicy.toJSON(message.retryPolicy);
    }
    if (message.concurrencyLimit !== 0) {
      obj.concurrencyLimit = Math.round(message.concurrencyLimit);
    }
    if (message.timeoutSecs !== 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    if (message.ptyInfo !== void 0) {
      obj.ptyInfo = PTYInfo.toJSON(message.ptyInfo);
    }
    if (message.classSerialized.length !== 0) {
      obj.classSerialized = base64FromBytes(message.classSerialized);
    }
    if (message.taskIdleTimeoutSecs !== 0) {
      obj.taskIdleTimeoutSecs = Math.round(message.taskIdleTimeoutSecs);
    }
    if (message.cloudProvider !== void 0) {
      obj.cloudProvider = cloudProviderToJSON(message.cloudProvider);
    }
    if (message.warmPoolSize !== 0) {
      obj.warmPoolSize = Math.round(message.warmPoolSize);
    }
    if (message.webUrl !== "") {
      obj.webUrl = message.webUrl;
    }
    if (message.webUrlInfo !== void 0) {
      obj.webUrlInfo = WebUrlInfo.toJSON(message.webUrlInfo);
    }
    if (message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.volumeMounts?.length) {
      obj.volumeMounts = message.volumeMounts.map((e) => VolumeMount.toJSON(e));
    }
    if (message.maxConcurrentInputs !== 0) {
      obj.maxConcurrentInputs = Math.round(message.maxConcurrentInputs);
    }
    if (message.customDomainInfo?.length) {
      obj.customDomainInfo = message.customDomainInfo.map((e) => CustomDomainInfo.toJSON(e));
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.runtimeDebug !== false) {
      obj.runtimeDebug = message.runtimeDebug;
    }
    if (message.isBuilderFunction !== false) {
      obj.isBuilderFunction = message.isBuilderFunction;
    }
    if (message.isAutoSnapshot !== false) {
      obj.isAutoSnapshot = message.isAutoSnapshot;
    }
    if (message.isMethod !== false) {
      obj.isMethod = message.isMethod;
    }
    if (message.isCheckpointingFunction !== false) {
      obj.isCheckpointingFunction = message.isCheckpointingFunction;
    }
    if (message.checkpointingEnabled !== false) {
      obj.checkpointingEnabled = message.checkpointingEnabled;
    }
    if (message.checkpoint !== void 0) {
      obj.checkpoint = CheckpointInfo.toJSON(message.checkpoint);
    }
    if (message.objectDependencies?.length) {
      obj.objectDependencies = message.objectDependencies.map((e) => ObjectDependency.toJSON(e));
    }
    if (message.blockNetwork !== false) {
      obj.blockNetwork = message.blockNetwork;
    }
    if (message.maxInputs !== 0) {
      obj.maxInputs = Math.round(message.maxInputs);
    }
    if (message.s3Mounts?.length) {
      obj.s3Mounts = message.s3Mounts.map((e) => S3Mount.toJSON(e));
    }
    if (message.cloudBucketMounts?.length) {
      obj.cloudBucketMounts = message.cloudBucketMounts.map((e) => CloudBucketMount.toJSON(e));
    }
    if (message.schedulerPlacement !== void 0) {
      obj.schedulerPlacement = SchedulerPlacement.toJSON(message.schedulerPlacement);
    }
    if (message.isClass !== false) {
      obj.isClass = message.isClass;
    }
    if (message.useFunctionId !== "") {
      obj.useFunctionId = message.useFunctionId;
    }
    if (message.useMethodName !== "") {
      obj.useMethodName = message.useMethodName;
    }
    if (message.classParameterInfo !== void 0) {
      obj.classParameterInfo = ClassParameterInfo.toJSON(message.classParameterInfo);
    }
    if (message.batchMaxSize !== 0) {
      obj.batchMaxSize = Math.round(message.batchMaxSize);
    }
    if (message.batchLingerMs !== 0) {
      obj.batchLingerMs = Math.round(message.batchLingerMs);
    }
    if (message.i6pnEnabled !== false) {
      obj.i6pnEnabled = message.i6pnEnabled;
    }
    if (message.ExperimentalConcurrentCancellations !== false) {
      obj.ExperimentalConcurrentCancellations = message.ExperimentalConcurrentCancellations;
    }
    if (message.targetConcurrentInputs !== 0) {
      obj.targetConcurrentInputs = Math.round(message.targetConcurrentInputs);
    }
    if (message.ExperimentalTaskTemplatesEnabled !== false) {
      obj.ExperimentalTaskTemplatesEnabled = message.ExperimentalTaskTemplatesEnabled;
    }
    if (message.ExperimentalTaskTemplates?.length) {
      obj.ExperimentalTaskTemplates = message.ExperimentalTaskTemplates.map((e) => TaskTemplate.toJSON(e));
    }
    if (message.ExperimentalGroupSize !== 0) {
      obj.ExperimentalGroupSize = Math.round(message.ExperimentalGroupSize);
    }
    if (message.untrusted !== false) {
      obj.untrusted = message.untrusted;
    }
    if (message.ExperimentalBufferContainers !== 0) {
      obj.ExperimentalBufferContainers = Math.round(message.ExperimentalBufferContainers);
    }
    if (message.ExperimentalProxyIp !== void 0) {
      obj.ExperimentalProxyIp = message.ExperimentalProxyIp;
    }
    if (message.runtimePerfRecord !== false) {
      obj.runtimePerfRecord = message.runtimePerfRecord;
    }
    if (message.schedule !== void 0) {
      obj.schedule = Schedule.toJSON(message.schedule);
    }
    if (message.snapshotDebug !== false) {
      obj.snapshotDebug = message.snapshotDebug;
    }
    if (message.methodDefinitions) {
      const entries = Object.entries(message.methodDefinitions);
      if (entries.length > 0) {
        obj.methodDefinitions = {};
        entries.forEach(([k, v]) => {
          obj.methodDefinitions[k] = MethodDefinition.toJSON(v);
        });
      }
    }
    if (message.methodDefinitionsSet !== false) {
      obj.methodDefinitionsSet = message.methodDefinitionsSet;
    }
    if (message.ExperimentalCustomScaling !== false) {
      obj.ExperimentalCustomScaling = message.ExperimentalCustomScaling;
    }
    if (message.cloudProviderStr !== "") {
      obj.cloudProviderStr = message.cloudProviderStr;
    }
    if (message.ExperimentalEnableGpuSnapshot !== false) {
      obj.ExperimentalEnableGpuSnapshot = message.ExperimentalEnableGpuSnapshot;
    }
    if (message.autoscalerSettings !== void 0) {
      obj.autoscalerSettings = AutoscalerSettings.toJSON(message.autoscalerSettings);
    }
    if (message.functionSchema !== void 0) {
      obj.functionSchema = FunctionSchema.toJSON(message.functionSchema);
    }
    if (message.experimentalOptions) {
      const entries = Object.entries(message.experimentalOptions);
      if (entries.length > 0) {
        obj.experimentalOptions = {};
        entries.forEach(([k, v]) => {
          obj.experimentalOptions[k] = v;
        });
      }
    }
    if (message.mountClientDependencies !== false) {
      obj.mountClientDependencies = message.mountClientDependencies;
    }
    if (message.flashServiceUrls?.length) {
      obj.flashServiceUrls = message.flashServiceUrls;
    }
    if (message.flashServiceLabel !== "") {
      obj.flashServiceLabel = message.flashServiceLabel;
    }
    if (message.enableGpuSnapshot !== false) {
      obj.enableGpuSnapshot = message.enableGpuSnapshot;
    }
    if (message.startupTimeoutSecs !== 0) {
      obj.startupTimeoutSecs = Math.round(message.startupTimeoutSecs);
    }
    if (message.supportedInputFormats?.length) {
      obj.supportedInputFormats = message.supportedInputFormats.map((e) => dataFormatToJSON(e));
    }
    if (message.supportedOutputFormats?.length) {
      obj.supportedOutputFormats = message.supportedOutputFormats.map((e) => dataFormatToJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionMessage();
    message.moduleName = object.moduleName ?? "";
    message.functionName = object.functionName ?? "";
    message.mountIds = object.mountIds?.map((e) => e) || [];
    message.imageId = object.imageId ?? "";
    message.functionSerialized = object.functionSerialized ?? new Uint8Array(0);
    message.definitionType = object.definitionType ?? 0;
    message.functionType = object.functionType ?? 0;
    message.resources = object.resources !== void 0 && object.resources !== null ? Resources.fromPartial(object.resources) : void 0;
    message.secretIds = object.secretIds?.map((e) => e) || [];
    message.rateLimit = object.rateLimit !== void 0 && object.rateLimit !== null ? RateLimit.fromPartial(object.rateLimit) : void 0;
    message.webhookConfig = object.webhookConfig !== void 0 && object.webhookConfig !== null ? WebhookConfig.fromPartial(object.webhookConfig) : void 0;
    message.sharedVolumeMounts = object.sharedVolumeMounts?.map((e) => SharedVolumeMount.fromPartial(e)) || [];
    message.proxyId = object.proxyId ?? void 0;
    message.retryPolicy = object.retryPolicy !== void 0 && object.retryPolicy !== null ? FunctionRetryPolicy.fromPartial(object.retryPolicy) : void 0;
    message.concurrencyLimit = object.concurrencyLimit ?? 0;
    message.timeoutSecs = object.timeoutSecs ?? 0;
    message.ptyInfo = object.ptyInfo !== void 0 && object.ptyInfo !== null ? PTYInfo.fromPartial(object.ptyInfo) : void 0;
    message.classSerialized = object.classSerialized ?? new Uint8Array(0);
    message.taskIdleTimeoutSecs = object.taskIdleTimeoutSecs ?? 0;
    message.cloudProvider = object.cloudProvider ?? void 0;
    message.warmPoolSize = object.warmPoolSize ?? 0;
    message.webUrl = object.webUrl ?? "";
    message.webUrlInfo = object.webUrlInfo !== void 0 && object.webUrlInfo !== null ? WebUrlInfo.fromPartial(object.webUrlInfo) : void 0;
    message.runtime = object.runtime ?? "";
    message.appName = object.appName ?? "";
    message.volumeMounts = object.volumeMounts?.map((e) => VolumeMount.fromPartial(e)) || [];
    message.maxConcurrentInputs = object.maxConcurrentInputs ?? 0;
    message.customDomainInfo = object.customDomainInfo?.map((e) => CustomDomainInfo.fromPartial(e)) || [];
    message.workerId = object.workerId ?? "";
    message.runtimeDebug = object.runtimeDebug ?? false;
    message.isBuilderFunction = object.isBuilderFunction ?? false;
    message.isAutoSnapshot = object.isAutoSnapshot ?? false;
    message.isMethod = object.isMethod ?? false;
    message.isCheckpointingFunction = object.isCheckpointingFunction ?? false;
    message.checkpointingEnabled = object.checkpointingEnabled ?? false;
    message.checkpoint = object.checkpoint !== void 0 && object.checkpoint !== null ? CheckpointInfo.fromPartial(object.checkpoint) : void 0;
    message.objectDependencies = object.objectDependencies?.map((e) => ObjectDependency.fromPartial(e)) || [];
    message.blockNetwork = object.blockNetwork ?? false;
    message.maxInputs = object.maxInputs ?? 0;
    message.s3Mounts = object.s3Mounts?.map((e) => S3Mount.fromPartial(e)) || [];
    message.cloudBucketMounts = object.cloudBucketMounts?.map((e) => CloudBucketMount.fromPartial(e)) || [];
    message.schedulerPlacement = object.schedulerPlacement !== void 0 && object.schedulerPlacement !== null ? SchedulerPlacement.fromPartial(object.schedulerPlacement) : void 0;
    message.isClass = object.isClass ?? false;
    message.useFunctionId = object.useFunctionId ?? "";
    message.useMethodName = object.useMethodName ?? "";
    message.classParameterInfo = object.classParameterInfo !== void 0 && object.classParameterInfo !== null ? ClassParameterInfo.fromPartial(object.classParameterInfo) : void 0;
    message.batchMaxSize = object.batchMaxSize ?? 0;
    message.batchLingerMs = object.batchLingerMs ?? 0;
    message.i6pnEnabled = object.i6pnEnabled ?? false;
    message.ExperimentalConcurrentCancellations = object.ExperimentalConcurrentCancellations ?? false;
    message.targetConcurrentInputs = object.targetConcurrentInputs ?? 0;
    message.ExperimentalTaskTemplatesEnabled = object.ExperimentalTaskTemplatesEnabled ?? false;
    message.ExperimentalTaskTemplates = object.ExperimentalTaskTemplates?.map((e) => TaskTemplate.fromPartial(e)) || [];
    message.ExperimentalGroupSize = object.ExperimentalGroupSize ?? 0;
    message.untrusted = object.untrusted ?? false;
    message.ExperimentalBufferContainers = object.ExperimentalBufferContainers ?? 0;
    message.ExperimentalProxyIp = object.ExperimentalProxyIp ?? void 0;
    message.runtimePerfRecord = object.runtimePerfRecord ?? false;
    message.schedule = object.schedule !== void 0 && object.schedule !== null ? Schedule.fromPartial(object.schedule) : void 0;
    message.snapshotDebug = object.snapshotDebug ?? false;
    message.methodDefinitions = Object.entries(object.methodDefinitions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MethodDefinition.fromPartial(value);
      }
      return acc;
    }, {});
    message.methodDefinitionsSet = object.methodDefinitionsSet ?? false;
    message.ExperimentalCustomScaling = object.ExperimentalCustomScaling ?? false;
    message.cloudProviderStr = object.cloudProviderStr ?? "";
    message.ExperimentalEnableGpuSnapshot = object.ExperimentalEnableGpuSnapshot ?? false;
    message.autoscalerSettings = object.autoscalerSettings !== void 0 && object.autoscalerSettings !== null ? AutoscalerSettings.fromPartial(object.autoscalerSettings) : void 0;
    message.functionSchema = object.functionSchema !== void 0 && object.functionSchema !== null ? FunctionSchema.fromPartial(object.functionSchema) : void 0;
    message.experimentalOptions = Object.entries(object.experimentalOptions ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.mountClientDependencies = object.mountClientDependencies ?? false;
    message.flashServiceUrls = object.flashServiceUrls?.map((e) => e) || [];
    message.flashServiceLabel = object.flashServiceLabel ?? "";
    message.enableGpuSnapshot = object.enableGpuSnapshot ?? false;
    message.startupTimeoutSecs = object.startupTimeoutSecs ?? 0;
    message.supportedInputFormats = object.supportedInputFormats?.map((e) => e) || [];
    message.supportedOutputFormats = object.supportedOutputFormats?.map((e) => e) || [];
    return message;
  }
};
function createBaseFunction_MethodDefinitionsEntry() {
  return { key: "", value: void 0 };
}
var Function_MethodDefinitionsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MethodDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunction_MethodDefinitionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = MethodDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? MethodDefinition.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MethodDefinition.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return Function_MethodDefinitionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunction_MethodDefinitionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MethodDefinition.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseFunction_ExperimentalOptionsEntry() {
  return { key: "", value: "" };
}
var Function_ExperimentalOptionsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunction_ExperimentalOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Function_ExperimentalOptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunction_ExperimentalOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseFunctionAsyncInvokeRequest() {
  return { functionId: "", parentInputId: "", input: void 0 };
}
var FunctionAsyncInvokeRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.parentInputId !== "") {
      writer.uint32(18).string(message.parentInputId);
    }
    if (message.input !== void 0) {
      FunctionInput.encode(message.input, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionAsyncInvokeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.parentInputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.input = FunctionInput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      parentInputId: isSet3(object.parentInputId) ? globalThis.String(object.parentInputId) : "",
      input: isSet3(object.input) ? FunctionInput.fromJSON(object.input) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.parentInputId !== "") {
      obj.parentInputId = message.parentInputId;
    }
    if (message.input !== void 0) {
      obj.input = FunctionInput.toJSON(message.input);
    }
    return obj;
  },
  create(base) {
    return FunctionAsyncInvokeRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionAsyncInvokeRequest();
    message.functionId = object.functionId ?? "";
    message.parentInputId = object.parentInputId ?? "";
    message.input = object.input !== void 0 && object.input !== null ? FunctionInput.fromPartial(object.input) : void 0;
    return message;
  }
};
function createBaseFunctionAsyncInvokeResponse() {
  return { retryWithBlobUpload: false, functionCallId: "" };
}
var FunctionAsyncInvokeResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.retryWithBlobUpload !== false) {
      writer.uint32(8).bool(message.retryWithBlobUpload);
    }
    if (message.functionCallId !== "") {
      writer.uint32(18).string(message.functionCallId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionAsyncInvokeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.retryWithBlobUpload = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      retryWithBlobUpload: isSet3(object.retryWithBlobUpload) ? globalThis.Boolean(object.retryWithBlobUpload) : false,
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.retryWithBlobUpload !== false) {
      obj.retryWithBlobUpload = message.retryWithBlobUpload;
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    return obj;
  },
  create(base) {
    return FunctionAsyncInvokeResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionAsyncInvokeResponse();
    message.retryWithBlobUpload = object.retryWithBlobUpload ?? false;
    message.functionCallId = object.functionCallId ?? "";
    return message;
  }
};
function createBaseFunctionBindParamsRequest() {
  return {
    functionId: "",
    serializedParams: new Uint8Array(0),
    functionOptions: void 0,
    environmentName: "",
    authSecret: ""
  };
}
var FunctionBindParamsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.serializedParams.length !== 0) {
      writer.uint32(18).bytes(message.serializedParams);
    }
    if (message.functionOptions !== void 0) {
      FunctionOptions.encode(message.functionOptions, writer.uint32(26).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(34).string(message.environmentName);
    }
    if (message.authSecret !== "") {
      writer.uint32(42).string(message.authSecret);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionBindParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.serializedParams = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionOptions = FunctionOptions.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.authSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      serializedParams: isSet3(object.serializedParams) ? bytesFromBase64(object.serializedParams) : new Uint8Array(0),
      functionOptions: isSet3(object.functionOptions) ? FunctionOptions.fromJSON(object.functionOptions) : void 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      authSecret: isSet3(object.authSecret) ? globalThis.String(object.authSecret) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.serializedParams.length !== 0) {
      obj.serializedParams = base64FromBytes(message.serializedParams);
    }
    if (message.functionOptions !== void 0) {
      obj.functionOptions = FunctionOptions.toJSON(message.functionOptions);
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.authSecret !== "") {
      obj.authSecret = message.authSecret;
    }
    return obj;
  },
  create(base) {
    return FunctionBindParamsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionBindParamsRequest();
    message.functionId = object.functionId ?? "";
    message.serializedParams = object.serializedParams ?? new Uint8Array(0);
    message.functionOptions = object.functionOptions !== void 0 && object.functionOptions !== null ? FunctionOptions.fromPartial(object.functionOptions) : void 0;
    message.environmentName = object.environmentName ?? "";
    message.authSecret = object.authSecret ?? "";
    return message;
  }
};
function createBaseFunctionBindParamsResponse() {
  return { boundFunctionId: "", handleMetadata: void 0 };
}
var FunctionBindParamsResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.boundFunctionId !== "") {
      writer.uint32(10).string(message.boundFunctionId);
    }
    if (message.handleMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.handleMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionBindParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.boundFunctionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.handleMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      boundFunctionId: isSet3(object.boundFunctionId) ? globalThis.String(object.boundFunctionId) : "",
      handleMetadata: isSet3(object.handleMetadata) ? FunctionHandleMetadata.fromJSON(object.handleMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.boundFunctionId !== "") {
      obj.boundFunctionId = message.boundFunctionId;
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = FunctionHandleMetadata.toJSON(message.handleMetadata);
    }
    return obj;
  },
  create(base) {
    return FunctionBindParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionBindParamsResponse();
    message.boundFunctionId = object.boundFunctionId ?? "";
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? FunctionHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    return message;
  }
};
function createBaseFunctionCallCallGraphInfo() {
  return { functionCallId: "", parentInputId: "", functionName: "", moduleName: "" };
}
var FunctionCallCallGraphInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.parentInputId !== "") {
      writer.uint32(18).string(message.parentInputId);
    }
    if (message.functionName !== "") {
      writer.uint32(26).string(message.functionName);
    }
    if (message.moduleName !== "") {
      writer.uint32(34).string(message.moduleName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallCallGraphInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.parentInputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.moduleName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      parentInputId: isSet3(object.parentInputId) ? globalThis.String(object.parentInputId) : "",
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      moduleName: isSet3(object.moduleName) ? globalThis.String(object.moduleName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.parentInputId !== "") {
      obj.parentInputId = message.parentInputId;
    }
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    return obj;
  },
  create(base) {
    return FunctionCallCallGraphInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallCallGraphInfo();
    message.functionCallId = object.functionCallId ?? "";
    message.parentInputId = object.parentInputId ?? "";
    message.functionName = object.functionName ?? "";
    message.moduleName = object.moduleName ?? "";
    return message;
  }
};
function createBaseFunctionCallCancelRequest() {
  return { functionCallId: "", terminateContainers: false, functionId: void 0 };
}
var FunctionCallCancelRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.terminateContainers !== false) {
      writer.uint32(16).bool(message.terminateContainers);
    }
    if (message.functionId !== void 0) {
      writer.uint32(26).string(message.functionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallCancelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.terminateContainers = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      terminateContainers: isSet3(object.terminateContainers) ? globalThis.Boolean(object.terminateContainers) : false,
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.terminateContainers !== false) {
      obj.terminateContainers = message.terminateContainers;
    }
    if (message.functionId !== void 0) {
      obj.functionId = message.functionId;
    }
    return obj;
  },
  create(base) {
    return FunctionCallCancelRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallCancelRequest();
    message.functionCallId = object.functionCallId ?? "";
    message.terminateContainers = object.terminateContainers ?? false;
    message.functionId = object.functionId ?? void 0;
    return message;
  }
};
function createBaseFunctionCallFromIdRequest() {
  return { functionCallId: "" };
}
var FunctionCallFromIdRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallFromIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    return obj;
  },
  create(base) {
    return FunctionCallFromIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallFromIdRequest();
    message.functionCallId = object.functionCallId ?? "";
    return message;
  }
};
function createBaseFunctionCallFromIdResponse() {
  return { functionCallId: "", numInputs: 0 };
}
var FunctionCallFromIdResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.numInputs !== 0) {
      writer.uint32(16).int32(message.numInputs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallFromIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.numInputs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      numInputs: isSet3(object.numInputs) ? globalThis.Number(object.numInputs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.numInputs !== 0) {
      obj.numInputs = Math.round(message.numInputs);
    }
    return obj;
  },
  create(base) {
    return FunctionCallFromIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallFromIdResponse();
    message.functionCallId = object.functionCallId ?? "";
    message.numInputs = object.numInputs ?? 0;
    return message;
  }
};
function createBaseFunctionCallGetDataRequest() {
  return { functionCallId: void 0, attemptToken: void 0, lastIndex: 0 };
}
var FunctionCallGetDataRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== void 0) {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.attemptToken !== void 0) {
      writer.uint32(26).string(message.attemptToken);
    }
    if (message.lastIndex !== 0) {
      writer.uint32(16).uint64(message.lastIndex);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallGetDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.lastIndex = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : void 0,
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : void 0,
      lastIndex: isSet3(object.lastIndex) ? globalThis.Number(object.lastIndex) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== void 0) {
      obj.functionCallId = message.functionCallId;
    }
    if (message.attemptToken !== void 0) {
      obj.attemptToken = message.attemptToken;
    }
    if (message.lastIndex !== 0) {
      obj.lastIndex = Math.round(message.lastIndex);
    }
    return obj;
  },
  create(base) {
    return FunctionCallGetDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallGetDataRequest();
    message.functionCallId = object.functionCallId ?? void 0;
    message.attemptToken = object.attemptToken ?? void 0;
    message.lastIndex = object.lastIndex ?? 0;
    return message;
  }
};
function createBaseFunctionCallInfo() {
  return {
    functionCallId: "",
    idx: 0,
    createdAt: 0,
    scheduledAt: 0,
    pendingInputs: void 0,
    failedInputs: void 0,
    succeededInputs: void 0,
    timeoutInputs: void 0,
    cancelledInputs: void 0,
    totalInputs: 0
  };
}
var FunctionCallInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.idx !== 0) {
      writer.uint32(16).int32(message.idx);
    }
    if (message.createdAt !== 0) {
      writer.uint32(49).double(message.createdAt);
    }
    if (message.scheduledAt !== 0) {
      writer.uint32(57).double(message.scheduledAt);
    }
    if (message.pendingInputs !== void 0) {
      InputCategoryInfo.encode(message.pendingInputs, writer.uint32(98).fork()).join();
    }
    if (message.failedInputs !== void 0) {
      InputCategoryInfo.encode(message.failedInputs, writer.uint32(106).fork()).join();
    }
    if (message.succeededInputs !== void 0) {
      InputCategoryInfo.encode(message.succeededInputs, writer.uint32(114).fork()).join();
    }
    if (message.timeoutInputs !== void 0) {
      InputCategoryInfo.encode(message.timeoutInputs, writer.uint32(122).fork()).join();
    }
    if (message.cancelledInputs !== void 0) {
      InputCategoryInfo.encode(message.cancelledInputs, writer.uint32(130).fork()).join();
    }
    if (message.totalInputs !== 0) {
      writer.uint32(136).int32(message.totalInputs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.idx = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }
          message.scheduledAt = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.pendingInputs = InputCategoryInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.failedInputs = InputCategoryInfo.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.succeededInputs = InputCategoryInfo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.timeoutInputs = InputCategoryInfo.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.cancelledInputs = InputCategoryInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }
          message.totalInputs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      idx: isSet3(object.idx) ? globalThis.Number(object.idx) : 0,
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      scheduledAt: isSet3(object.scheduledAt) ? globalThis.Number(object.scheduledAt) : 0,
      pendingInputs: isSet3(object.pendingInputs) ? InputCategoryInfo.fromJSON(object.pendingInputs) : void 0,
      failedInputs: isSet3(object.failedInputs) ? InputCategoryInfo.fromJSON(object.failedInputs) : void 0,
      succeededInputs: isSet3(object.succeededInputs) ? InputCategoryInfo.fromJSON(object.succeededInputs) : void 0,
      timeoutInputs: isSet3(object.timeoutInputs) ? InputCategoryInfo.fromJSON(object.timeoutInputs) : void 0,
      cancelledInputs: isSet3(object.cancelledInputs) ? InputCategoryInfo.fromJSON(object.cancelledInputs) : void 0,
      totalInputs: isSet3(object.totalInputs) ? globalThis.Number(object.totalInputs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.idx !== 0) {
      obj.idx = Math.round(message.idx);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.scheduledAt !== 0) {
      obj.scheduledAt = message.scheduledAt;
    }
    if (message.pendingInputs !== void 0) {
      obj.pendingInputs = InputCategoryInfo.toJSON(message.pendingInputs);
    }
    if (message.failedInputs !== void 0) {
      obj.failedInputs = InputCategoryInfo.toJSON(message.failedInputs);
    }
    if (message.succeededInputs !== void 0) {
      obj.succeededInputs = InputCategoryInfo.toJSON(message.succeededInputs);
    }
    if (message.timeoutInputs !== void 0) {
      obj.timeoutInputs = InputCategoryInfo.toJSON(message.timeoutInputs);
    }
    if (message.cancelledInputs !== void 0) {
      obj.cancelledInputs = InputCategoryInfo.toJSON(message.cancelledInputs);
    }
    if (message.totalInputs !== 0) {
      obj.totalInputs = Math.round(message.totalInputs);
    }
    return obj;
  },
  create(base) {
    return FunctionCallInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallInfo();
    message.functionCallId = object.functionCallId ?? "";
    message.idx = object.idx ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.scheduledAt = object.scheduledAt ?? 0;
    message.pendingInputs = object.pendingInputs !== void 0 && object.pendingInputs !== null ? InputCategoryInfo.fromPartial(object.pendingInputs) : void 0;
    message.failedInputs = object.failedInputs !== void 0 && object.failedInputs !== null ? InputCategoryInfo.fromPartial(object.failedInputs) : void 0;
    message.succeededInputs = object.succeededInputs !== void 0 && object.succeededInputs !== null ? InputCategoryInfo.fromPartial(object.succeededInputs) : void 0;
    message.timeoutInputs = object.timeoutInputs !== void 0 && object.timeoutInputs !== null ? InputCategoryInfo.fromPartial(object.timeoutInputs) : void 0;
    message.cancelledInputs = object.cancelledInputs !== void 0 && object.cancelledInputs !== null ? InputCategoryInfo.fromPartial(object.cancelledInputs) : void 0;
    message.totalInputs = object.totalInputs ?? 0;
    return message;
  }
};
function createBaseFunctionCallListRequest() {
  return { functionId: "" };
}
var FunctionCallListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    return obj;
  },
  create(base) {
    return FunctionCallListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallListRequest();
    message.functionId = object.functionId ?? "";
    return message;
  }
};
function createBaseFunctionCallListResponse() {
  return { functionCalls: [] };
}
var FunctionCallListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.functionCalls) {
      FunctionCallInfo.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCalls.push(FunctionCallInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCalls: globalThis.Array.isArray(object?.functionCalls) ? object.functionCalls.map((e) => FunctionCallInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCalls?.length) {
      obj.functionCalls = message.functionCalls.map((e) => FunctionCallInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionCallListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallListResponse();
    message.functionCalls = object.functionCalls?.map((e) => FunctionCallInfo.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionCallPutDataRequest() {
  return { functionCallId: void 0, attemptToken: void 0, dataChunks: [] };
}
var FunctionCallPutDataRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== void 0) {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.attemptToken !== void 0) {
      writer.uint32(26).string(message.attemptToken);
    }
    for (const v of message.dataChunks) {
      DataChunk.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallPutDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dataChunks.push(DataChunk.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : void 0,
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : void 0,
      dataChunks: globalThis.Array.isArray(object?.dataChunks) ? object.dataChunks.map((e) => DataChunk.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== void 0) {
      obj.functionCallId = message.functionCallId;
    }
    if (message.attemptToken !== void 0) {
      obj.attemptToken = message.attemptToken;
    }
    if (message.dataChunks?.length) {
      obj.dataChunks = message.dataChunks.map((e) => DataChunk.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionCallPutDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCallPutDataRequest();
    message.functionCallId = object.functionCallId ?? void 0;
    message.attemptToken = object.attemptToken ?? void 0;
    message.dataChunks = object.dataChunks?.map((e) => DataChunk.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionCreateRequest() {
  return { function: void 0, appId: "", schedule: void 0, existingFunctionId: "", functionData: void 0 };
}
var FunctionCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.function !== void 0) {
      FunctionMessage.encode(message.function, writer.uint32(10).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.schedule !== void 0) {
      Schedule.encode(message.schedule, writer.uint32(50).fork()).join();
    }
    if (message.existingFunctionId !== "") {
      writer.uint32(58).string(message.existingFunctionId);
    }
    if (message.functionData !== void 0) {
      FunctionData.encode(message.functionData, writer.uint32(74).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.function = FunctionMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.schedule = Schedule.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.existingFunctionId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.functionData = FunctionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      function: isSet3(object.function) ? FunctionMessage.fromJSON(object.function) : void 0,
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      schedule: isSet3(object.schedule) ? Schedule.fromJSON(object.schedule) : void 0,
      existingFunctionId: isSet3(object.existingFunctionId) ? globalThis.String(object.existingFunctionId) : "",
      functionData: isSet3(object.functionData) ? FunctionData.fromJSON(object.functionData) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.function !== void 0) {
      obj.function = FunctionMessage.toJSON(message.function);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.schedule !== void 0) {
      obj.schedule = Schedule.toJSON(message.schedule);
    }
    if (message.existingFunctionId !== "") {
      obj.existingFunctionId = message.existingFunctionId;
    }
    if (message.functionData !== void 0) {
      obj.functionData = FunctionData.toJSON(message.functionData);
    }
    return obj;
  },
  create(base) {
    return FunctionCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCreateRequest();
    message.function = object.function !== void 0 && object.function !== null ? FunctionMessage.fromPartial(object.function) : void 0;
    message.appId = object.appId ?? "";
    message.schedule = object.schedule !== void 0 && object.schedule !== null ? Schedule.fromPartial(object.schedule) : void 0;
    message.existingFunctionId = object.existingFunctionId ?? "";
    message.functionData = object.functionData !== void 0 && object.functionData !== null ? FunctionData.fromPartial(object.functionData) : void 0;
    return message;
  }
};
function createBaseFunctionCreateResponse() {
  return { functionId: "", DeprecatedWebUrl: "", function: void 0, handleMetadata: void 0, serverWarnings: [] };
}
var FunctionCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.DeprecatedWebUrl !== "") {
      writer.uint32(18).string(message.DeprecatedWebUrl);
    }
    if (message.function !== void 0) {
      FunctionMessage.encode(message.function, writer.uint32(34).fork()).join();
    }
    if (message.handleMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.handleMetadata, writer.uint32(42).fork()).join();
    }
    for (const v of message.serverWarnings) {
      Warning.encode(v, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.DeprecatedWebUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.function = FunctionMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.handleMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.serverWarnings.push(Warning.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      DeprecatedWebUrl: isSet3(object.DeprecatedWebUrl) ? globalThis.String(object.DeprecatedWebUrl) : "",
      function: isSet3(object.function) ? FunctionMessage.fromJSON(object.function) : void 0,
      handleMetadata: isSet3(object.handleMetadata) ? FunctionHandleMetadata.fromJSON(object.handleMetadata) : void 0,
      serverWarnings: globalThis.Array.isArray(object?.serverWarnings) ? object.serverWarnings.map((e) => Warning.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.DeprecatedWebUrl !== "") {
      obj.DeprecatedWebUrl = message.DeprecatedWebUrl;
    }
    if (message.function !== void 0) {
      obj.function = FunctionMessage.toJSON(message.function);
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = FunctionHandleMetadata.toJSON(message.handleMetadata);
    }
    if (message.serverWarnings?.length) {
      obj.serverWarnings = message.serverWarnings.map((e) => Warning.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionCreateResponse();
    message.functionId = object.functionId ?? "";
    message.DeprecatedWebUrl = object.DeprecatedWebUrl ?? "";
    message.function = object.function !== void 0 && object.function !== null ? FunctionMessage.fromPartial(object.function) : void 0;
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? FunctionHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    message.serverWarnings = object.serverWarnings?.map((e) => Warning.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionData() {
  return {
    moduleName: "",
    functionName: "",
    functionType: 0,
    warmPoolSize: 0,
    concurrencyLimit: 0,
    taskIdleTimeoutSecs: 0,
    ExperimentalGroupSize: 0,
    ExperimentalBufferContainers: 0,
    ExperimentalCustomScaling: false,
    ExperimentalEnableGpuSnapshot: false,
    workerId: "",
    timeoutSecs: 0,
    webUrl: "",
    webUrlInfo: void 0,
    webhookConfig: void 0,
    customDomainInfo: [],
    ExperimentalProxyIp: void 0,
    methodDefinitions: {},
    methodDefinitionsSet: false,
    isClass: false,
    classParameterInfo: void 0,
    isMethod: false,
    useFunctionId: "",
    useMethodName: "",
    rankedFunctions: [],
    schedule: void 0,
    untrusted: false,
    snapshotDebug: false,
    runtimePerfRecord: false,
    autoscalerSettings: void 0,
    functionSchema: void 0,
    experimentalOptions: {},
    flashServiceUrls: [],
    flashServiceLabel: "",
    startupTimeoutSecs: 0,
    supportedInputFormats: [],
    supportedOutputFormats: []
  };
}
var FunctionData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.moduleName !== "") {
      writer.uint32(10).string(message.moduleName);
    }
    if (message.functionName !== "") {
      writer.uint32(18).string(message.functionName);
    }
    if (message.functionType !== 0) {
      writer.uint32(24).int32(message.functionType);
    }
    if (message.warmPoolSize !== 0) {
      writer.uint32(32).uint32(message.warmPoolSize);
    }
    if (message.concurrencyLimit !== 0) {
      writer.uint32(40).uint32(message.concurrencyLimit);
    }
    if (message.taskIdleTimeoutSecs !== 0) {
      writer.uint32(48).uint32(message.taskIdleTimeoutSecs);
    }
    if (message.ExperimentalGroupSize !== 0) {
      writer.uint32(152).uint32(message.ExperimentalGroupSize);
    }
    if (message.ExperimentalBufferContainers !== 0) {
      writer.uint32(176).uint32(message.ExperimentalBufferContainers);
    }
    if (message.ExperimentalCustomScaling !== false) {
      writer.uint32(184).bool(message.ExperimentalCustomScaling);
    }
    if (message.ExperimentalEnableGpuSnapshot !== false) {
      writer.uint32(240).bool(message.ExperimentalEnableGpuSnapshot);
    }
    if (message.workerId !== "") {
      writer.uint32(58).string(message.workerId);
    }
    if (message.timeoutSecs !== 0) {
      writer.uint32(64).uint32(message.timeoutSecs);
    }
    if (message.webUrl !== "") {
      writer.uint32(74).string(message.webUrl);
    }
    if (message.webUrlInfo !== void 0) {
      WebUrlInfo.encode(message.webUrlInfo, writer.uint32(82).fork()).join();
    }
    if (message.webhookConfig !== void 0) {
      WebhookConfig.encode(message.webhookConfig, writer.uint32(90).fork()).join();
    }
    for (const v of message.customDomainInfo) {
      CustomDomainInfo.encode(v, writer.uint32(98).fork()).join();
    }
    if (message.ExperimentalProxyIp !== void 0) {
      writer.uint32(194).string(message.ExperimentalProxyIp);
    }
    Object.entries(message.methodDefinitions).forEach(([key, value]) => {
      FunctionData_MethodDefinitionsEntry.encode({ key, value }, writer.uint32(202).fork()).join();
    });
    if (message.methodDefinitionsSet !== false) {
      writer.uint32(208).bool(message.methodDefinitionsSet);
    }
    if (message.isClass !== false) {
      writer.uint32(104).bool(message.isClass);
    }
    if (message.classParameterInfo !== void 0) {
      ClassParameterInfo.encode(message.classParameterInfo, writer.uint32(114).fork()).join();
    }
    if (message.isMethod !== false) {
      writer.uint32(120).bool(message.isMethod);
    }
    if (message.useFunctionId !== "") {
      writer.uint32(130).string(message.useFunctionId);
    }
    if (message.useMethodName !== "") {
      writer.uint32(138).string(message.useMethodName);
    }
    for (const v of message.rankedFunctions) {
      FunctionData_RankedFunction.encode(v, writer.uint32(146).fork()).join();
    }
    if (message.schedule !== void 0) {
      Schedule.encode(message.schedule, writer.uint32(162).fork()).join();
    }
    if (message.untrusted !== false) {
      writer.uint32(216).bool(message.untrusted);
    }
    if (message.snapshotDebug !== false) {
      writer.uint32(224).bool(message.snapshotDebug);
    }
    if (message.runtimePerfRecord !== false) {
      writer.uint32(232).bool(message.runtimePerfRecord);
    }
    if (message.autoscalerSettings !== void 0) {
      AutoscalerSettings.encode(message.autoscalerSettings, writer.uint32(250).fork()).join();
    }
    if (message.functionSchema !== void 0) {
      FunctionSchema.encode(message.functionSchema, writer.uint32(258).fork()).join();
    }
    Object.entries(message.experimentalOptions).forEach(([key, value]) => {
      FunctionData_ExperimentalOptionsEntry.encode({ key, value }, writer.uint32(266).fork()).join();
    });
    for (const v of message.flashServiceUrls) {
      writer.uint32(274).string(v);
    }
    if (message.flashServiceLabel !== "") {
      writer.uint32(282).string(message.flashServiceLabel);
    }
    if (message.startupTimeoutSecs !== 0) {
      writer.uint32(288).uint32(message.startupTimeoutSecs);
    }
    writer.uint32(298).fork();
    for (const v of message.supportedInputFormats) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(306).fork();
    for (const v of message.supportedOutputFormats) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.moduleName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.functionType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.warmPoolSize = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.concurrencyLimit = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.taskIdleTimeoutSecs = reader.uint32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }
          message.ExperimentalGroupSize = reader.uint32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }
          message.ExperimentalBufferContainers = reader.uint32();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }
          message.ExperimentalCustomScaling = reader.bool();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }
          message.ExperimentalEnableGpuSnapshot = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.workerId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.timeoutSecs = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.webUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.webUrlInfo = WebUrlInfo.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.webhookConfig = WebhookConfig.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.customDomainInfo.push(CustomDomainInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }
          message.ExperimentalProxyIp = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }
          const entry25 = FunctionData_MethodDefinitionsEntry.decode(reader, reader.uint32());
          if (entry25.value !== void 0) {
            message.methodDefinitions[entry25.key] = entry25.value;
          }
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }
          message.methodDefinitionsSet = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.isClass = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.classParameterInfo = ClassParameterInfo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }
          message.isMethod = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.useFunctionId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.useMethodName = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.rankedFunctions.push(FunctionData_RankedFunction.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }
          message.schedule = Schedule.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }
          message.untrusted = reader.bool();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }
          message.snapshotDebug = reader.bool();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }
          message.runtimePerfRecord = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }
          message.autoscalerSettings = AutoscalerSettings.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }
          message.functionSchema = FunctionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }
          const entry33 = FunctionData_ExperimentalOptionsEntry.decode(reader, reader.uint32());
          if (entry33.value !== void 0) {
            message.experimentalOptions[entry33.key] = entry33.value;
          }
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }
          message.flashServiceUrls.push(reader.string());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }
          message.flashServiceLabel = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }
          message.startupTimeoutSecs = reader.uint32();
          continue;
        }
        case 37: {
          if (tag === 296) {
            message.supportedInputFormats.push(reader.int32());
            continue;
          }
          if (tag === 298) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedInputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 38: {
          if (tag === 304) {
            message.supportedOutputFormats.push(reader.int32());
            continue;
          }
          if (tag === 306) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedOutputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      moduleName: isSet3(object.moduleName) ? globalThis.String(object.moduleName) : "",
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      functionType: isSet3(object.functionType) ? function_FunctionTypeFromJSON(object.functionType) : 0,
      warmPoolSize: isSet3(object.warmPoolSize) ? globalThis.Number(object.warmPoolSize) : 0,
      concurrencyLimit: isSet3(object.concurrencyLimit) ? globalThis.Number(object.concurrencyLimit) : 0,
      taskIdleTimeoutSecs: isSet3(object.taskIdleTimeoutSecs) ? globalThis.Number(object.taskIdleTimeoutSecs) : 0,
      ExperimentalGroupSize: isSet3(object.ExperimentalGroupSize) ? globalThis.Number(object.ExperimentalGroupSize) : 0,
      ExperimentalBufferContainers: isSet3(object.ExperimentalBufferContainers) ? globalThis.Number(object.ExperimentalBufferContainers) : 0,
      ExperimentalCustomScaling: isSet3(object.ExperimentalCustomScaling) ? globalThis.Boolean(object.ExperimentalCustomScaling) : false,
      ExperimentalEnableGpuSnapshot: isSet3(object.ExperimentalEnableGpuSnapshot) ? globalThis.Boolean(object.ExperimentalEnableGpuSnapshot) : false,
      workerId: isSet3(object.workerId) ? globalThis.String(object.workerId) : "",
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : 0,
      webUrl: isSet3(object.webUrl) ? globalThis.String(object.webUrl) : "",
      webUrlInfo: isSet3(object.webUrlInfo) ? WebUrlInfo.fromJSON(object.webUrlInfo) : void 0,
      webhookConfig: isSet3(object.webhookConfig) ? WebhookConfig.fromJSON(object.webhookConfig) : void 0,
      customDomainInfo: globalThis.Array.isArray(object?.customDomainInfo) ? object.customDomainInfo.map((e) => CustomDomainInfo.fromJSON(e)) : [],
      ExperimentalProxyIp: isSet3(object.ExperimentalProxyIp) ? globalThis.String(object.ExperimentalProxyIp) : void 0,
      methodDefinitions: isObject2(object.methodDefinitions) ? Object.entries(object.methodDefinitions).reduce((acc, [key, value]) => {
        acc[key] = MethodDefinition.fromJSON(value);
        return acc;
      }, {}) : {},
      methodDefinitionsSet: isSet3(object.methodDefinitionsSet) ? globalThis.Boolean(object.methodDefinitionsSet) : false,
      isClass: isSet3(object.isClass) ? globalThis.Boolean(object.isClass) : false,
      classParameterInfo: isSet3(object.classParameterInfo) ? ClassParameterInfo.fromJSON(object.classParameterInfo) : void 0,
      isMethod: isSet3(object.isMethod) ? globalThis.Boolean(object.isMethod) : false,
      useFunctionId: isSet3(object.useFunctionId) ? globalThis.String(object.useFunctionId) : "",
      useMethodName: isSet3(object.useMethodName) ? globalThis.String(object.useMethodName) : "",
      rankedFunctions: globalThis.Array.isArray(object?.rankedFunctions) ? object.rankedFunctions.map((e) => FunctionData_RankedFunction.fromJSON(e)) : [],
      schedule: isSet3(object.schedule) ? Schedule.fromJSON(object.schedule) : void 0,
      untrusted: isSet3(object.untrusted) ? globalThis.Boolean(object.untrusted) : false,
      snapshotDebug: isSet3(object.snapshotDebug) ? globalThis.Boolean(object.snapshotDebug) : false,
      runtimePerfRecord: isSet3(object.runtimePerfRecord) ? globalThis.Boolean(object.runtimePerfRecord) : false,
      autoscalerSettings: isSet3(object.autoscalerSettings) ? AutoscalerSettings.fromJSON(object.autoscalerSettings) : void 0,
      functionSchema: isSet3(object.functionSchema) ? FunctionSchema.fromJSON(object.functionSchema) : void 0,
      experimentalOptions: isObject2(object.experimentalOptions) ? Object.entries(object.experimentalOptions).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      flashServiceUrls: globalThis.Array.isArray(object?.flashServiceUrls) ? object.flashServiceUrls.map((e) => globalThis.String(e)) : [],
      flashServiceLabel: isSet3(object.flashServiceLabel) ? globalThis.String(object.flashServiceLabel) : "",
      startupTimeoutSecs: isSet3(object.startupTimeoutSecs) ? globalThis.Number(object.startupTimeoutSecs) : 0,
      supportedInputFormats: globalThis.Array.isArray(object?.supportedInputFormats) ? object.supportedInputFormats.map((e) => dataFormatFromJSON(e)) : [],
      supportedOutputFormats: globalThis.Array.isArray(object?.supportedOutputFormats) ? object.supportedOutputFormats.map((e) => dataFormatFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.moduleName !== "") {
      obj.moduleName = message.moduleName;
    }
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.functionType !== 0) {
      obj.functionType = function_FunctionTypeToJSON(message.functionType);
    }
    if (message.warmPoolSize !== 0) {
      obj.warmPoolSize = Math.round(message.warmPoolSize);
    }
    if (message.concurrencyLimit !== 0) {
      obj.concurrencyLimit = Math.round(message.concurrencyLimit);
    }
    if (message.taskIdleTimeoutSecs !== 0) {
      obj.taskIdleTimeoutSecs = Math.round(message.taskIdleTimeoutSecs);
    }
    if (message.ExperimentalGroupSize !== 0) {
      obj.ExperimentalGroupSize = Math.round(message.ExperimentalGroupSize);
    }
    if (message.ExperimentalBufferContainers !== 0) {
      obj.ExperimentalBufferContainers = Math.round(message.ExperimentalBufferContainers);
    }
    if (message.ExperimentalCustomScaling !== false) {
      obj.ExperimentalCustomScaling = message.ExperimentalCustomScaling;
    }
    if (message.ExperimentalEnableGpuSnapshot !== false) {
      obj.ExperimentalEnableGpuSnapshot = message.ExperimentalEnableGpuSnapshot;
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.timeoutSecs !== 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    if (message.webUrl !== "") {
      obj.webUrl = message.webUrl;
    }
    if (message.webUrlInfo !== void 0) {
      obj.webUrlInfo = WebUrlInfo.toJSON(message.webUrlInfo);
    }
    if (message.webhookConfig !== void 0) {
      obj.webhookConfig = WebhookConfig.toJSON(message.webhookConfig);
    }
    if (message.customDomainInfo?.length) {
      obj.customDomainInfo = message.customDomainInfo.map((e) => CustomDomainInfo.toJSON(e));
    }
    if (message.ExperimentalProxyIp !== void 0) {
      obj.ExperimentalProxyIp = message.ExperimentalProxyIp;
    }
    if (message.methodDefinitions) {
      const entries = Object.entries(message.methodDefinitions);
      if (entries.length > 0) {
        obj.methodDefinitions = {};
        entries.forEach(([k, v]) => {
          obj.methodDefinitions[k] = MethodDefinition.toJSON(v);
        });
      }
    }
    if (message.methodDefinitionsSet !== false) {
      obj.methodDefinitionsSet = message.methodDefinitionsSet;
    }
    if (message.isClass !== false) {
      obj.isClass = message.isClass;
    }
    if (message.classParameterInfo !== void 0) {
      obj.classParameterInfo = ClassParameterInfo.toJSON(message.classParameterInfo);
    }
    if (message.isMethod !== false) {
      obj.isMethod = message.isMethod;
    }
    if (message.useFunctionId !== "") {
      obj.useFunctionId = message.useFunctionId;
    }
    if (message.useMethodName !== "") {
      obj.useMethodName = message.useMethodName;
    }
    if (message.rankedFunctions?.length) {
      obj.rankedFunctions = message.rankedFunctions.map((e) => FunctionData_RankedFunction.toJSON(e));
    }
    if (message.schedule !== void 0) {
      obj.schedule = Schedule.toJSON(message.schedule);
    }
    if (message.untrusted !== false) {
      obj.untrusted = message.untrusted;
    }
    if (message.snapshotDebug !== false) {
      obj.snapshotDebug = message.snapshotDebug;
    }
    if (message.runtimePerfRecord !== false) {
      obj.runtimePerfRecord = message.runtimePerfRecord;
    }
    if (message.autoscalerSettings !== void 0) {
      obj.autoscalerSettings = AutoscalerSettings.toJSON(message.autoscalerSettings);
    }
    if (message.functionSchema !== void 0) {
      obj.functionSchema = FunctionSchema.toJSON(message.functionSchema);
    }
    if (message.experimentalOptions) {
      const entries = Object.entries(message.experimentalOptions);
      if (entries.length > 0) {
        obj.experimentalOptions = {};
        entries.forEach(([k, v]) => {
          obj.experimentalOptions[k] = v;
        });
      }
    }
    if (message.flashServiceUrls?.length) {
      obj.flashServiceUrls = message.flashServiceUrls;
    }
    if (message.flashServiceLabel !== "") {
      obj.flashServiceLabel = message.flashServiceLabel;
    }
    if (message.startupTimeoutSecs !== 0) {
      obj.startupTimeoutSecs = Math.round(message.startupTimeoutSecs);
    }
    if (message.supportedInputFormats?.length) {
      obj.supportedInputFormats = message.supportedInputFormats.map((e) => dataFormatToJSON(e));
    }
    if (message.supportedOutputFormats?.length) {
      obj.supportedOutputFormats = message.supportedOutputFormats.map((e) => dataFormatToJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionData();
    message.moduleName = object.moduleName ?? "";
    message.functionName = object.functionName ?? "";
    message.functionType = object.functionType ?? 0;
    message.warmPoolSize = object.warmPoolSize ?? 0;
    message.concurrencyLimit = object.concurrencyLimit ?? 0;
    message.taskIdleTimeoutSecs = object.taskIdleTimeoutSecs ?? 0;
    message.ExperimentalGroupSize = object.ExperimentalGroupSize ?? 0;
    message.ExperimentalBufferContainers = object.ExperimentalBufferContainers ?? 0;
    message.ExperimentalCustomScaling = object.ExperimentalCustomScaling ?? false;
    message.ExperimentalEnableGpuSnapshot = object.ExperimentalEnableGpuSnapshot ?? false;
    message.workerId = object.workerId ?? "";
    message.timeoutSecs = object.timeoutSecs ?? 0;
    message.webUrl = object.webUrl ?? "";
    message.webUrlInfo = object.webUrlInfo !== void 0 && object.webUrlInfo !== null ? WebUrlInfo.fromPartial(object.webUrlInfo) : void 0;
    message.webhookConfig = object.webhookConfig !== void 0 && object.webhookConfig !== null ? WebhookConfig.fromPartial(object.webhookConfig) : void 0;
    message.customDomainInfo = object.customDomainInfo?.map((e) => CustomDomainInfo.fromPartial(e)) || [];
    message.ExperimentalProxyIp = object.ExperimentalProxyIp ?? void 0;
    message.methodDefinitions = Object.entries(object.methodDefinitions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MethodDefinition.fromPartial(value);
      }
      return acc;
    }, {});
    message.methodDefinitionsSet = object.methodDefinitionsSet ?? false;
    message.isClass = object.isClass ?? false;
    message.classParameterInfo = object.classParameterInfo !== void 0 && object.classParameterInfo !== null ? ClassParameterInfo.fromPartial(object.classParameterInfo) : void 0;
    message.isMethod = object.isMethod ?? false;
    message.useFunctionId = object.useFunctionId ?? "";
    message.useMethodName = object.useMethodName ?? "";
    message.rankedFunctions = object.rankedFunctions?.map((e) => FunctionData_RankedFunction.fromPartial(e)) || [];
    message.schedule = object.schedule !== void 0 && object.schedule !== null ? Schedule.fromPartial(object.schedule) : void 0;
    message.untrusted = object.untrusted ?? false;
    message.snapshotDebug = object.snapshotDebug ?? false;
    message.runtimePerfRecord = object.runtimePerfRecord ?? false;
    message.autoscalerSettings = object.autoscalerSettings !== void 0 && object.autoscalerSettings !== null ? AutoscalerSettings.fromPartial(object.autoscalerSettings) : void 0;
    message.functionSchema = object.functionSchema !== void 0 && object.functionSchema !== null ? FunctionSchema.fromPartial(object.functionSchema) : void 0;
    message.experimentalOptions = Object.entries(object.experimentalOptions ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.flashServiceUrls = object.flashServiceUrls?.map((e) => e) || [];
    message.flashServiceLabel = object.flashServiceLabel ?? "";
    message.startupTimeoutSecs = object.startupTimeoutSecs ?? 0;
    message.supportedInputFormats = object.supportedInputFormats?.map((e) => e) || [];
    message.supportedOutputFormats = object.supportedOutputFormats?.map((e) => e) || [];
    return message;
  }
};
function createBaseFunctionData_MethodDefinitionsEntry() {
  return { key: "", value: void 0 };
}
var FunctionData_MethodDefinitionsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MethodDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionData_MethodDefinitionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = MethodDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? MethodDefinition.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MethodDefinition.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return FunctionData_MethodDefinitionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionData_MethodDefinitionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MethodDefinition.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseFunctionData_RankedFunction() {
  return { rank: 0, function: void 0 };
}
var FunctionData_RankedFunction = {
  encode(message, writer = new BinaryWriter()) {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.function !== void 0) {
      FunctionMessage.encode(message.function, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionData_RankedFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.function = FunctionMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      rank: isSet3(object.rank) ? globalThis.Number(object.rank) : 0,
      function: isSet3(object.function) ? FunctionMessage.fromJSON(object.function) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.function !== void 0) {
      obj.function = FunctionMessage.toJSON(message.function);
    }
    return obj;
  },
  create(base) {
    return FunctionData_RankedFunction.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionData_RankedFunction();
    message.rank = object.rank ?? 0;
    message.function = object.function !== void 0 && object.function !== null ? FunctionMessage.fromPartial(object.function) : void 0;
    return message;
  }
};
function createBaseFunctionData_ExperimentalOptionsEntry() {
  return { key: "", value: "" };
}
var FunctionData_ExperimentalOptionsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionData_ExperimentalOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return FunctionData_ExperimentalOptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionData_ExperimentalOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseFunctionFinishInputsRequest() {
  return { functionId: "", functionCallId: "", numInputs: 0 };
}
var FunctionFinishInputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.functionCallId !== "") {
      writer.uint32(18).string(message.functionCallId);
    }
    if (message.numInputs !== 0) {
      writer.uint32(24).uint32(message.numInputs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionFinishInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.numInputs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      numInputs: isSet3(object.numInputs) ? globalThis.Number(object.numInputs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.numInputs !== 0) {
      obj.numInputs = Math.round(message.numInputs);
    }
    return obj;
  },
  create(base) {
    return FunctionFinishInputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionFinishInputsRequest();
    message.functionId = object.functionId ?? "";
    message.functionCallId = object.functionCallId ?? "";
    message.numInputs = object.numInputs ?? 0;
    return message;
  }
};
function createBaseFunctionGetCallGraphRequest() {
  return { functionCallId: "" };
}
var FunctionGetCallGraphRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(18).string(message.functionCallId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetCallGraphRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    return obj;
  },
  create(base) {
    return FunctionGetCallGraphRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetCallGraphRequest();
    message.functionCallId = object.functionCallId ?? "";
    return message;
  }
};
function createBaseFunctionGetCallGraphResponse() {
  return { inputs: [], functionCalls: [] };
}
var FunctionGetCallGraphResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.inputs) {
      InputCallGraphInfo.encode(v, writer.uint32(10).fork()).join();
    }
    for (const v of message.functionCalls) {
      FunctionCallCallGraphInfo.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetCallGraphResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputs.push(InputCallGraphInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionCalls.push(FunctionCallCallGraphInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e) => InputCallGraphInfo.fromJSON(e)) : [],
      functionCalls: globalThis.Array.isArray(object?.functionCalls) ? object.functionCalls.map((e) => FunctionCallCallGraphInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => InputCallGraphInfo.toJSON(e));
    }
    if (message.functionCalls?.length) {
      obj.functionCalls = message.functionCalls.map((e) => FunctionCallCallGraphInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionGetCallGraphResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetCallGraphResponse();
    message.inputs = object.inputs?.map((e) => InputCallGraphInfo.fromPartial(e)) || [];
    message.functionCalls = object.functionCalls?.map((e) => FunctionCallCallGraphInfo.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionGetCurrentStatsRequest() {
  return { functionId: "" };
}
var FunctionGetCurrentStatsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetCurrentStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    return obj;
  },
  create(base) {
    return FunctionGetCurrentStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetCurrentStatsRequest();
    message.functionId = object.functionId ?? "";
    return message;
  }
};
function createBaseFunctionGetDynamicConcurrencyRequest() {
  return { functionId: "", targetConcurrency: 0, maxConcurrency: 0 };
}
var FunctionGetDynamicConcurrencyRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.targetConcurrency !== 0) {
      writer.uint32(16).uint32(message.targetConcurrency);
    }
    if (message.maxConcurrency !== 0) {
      writer.uint32(24).uint32(message.maxConcurrency);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetDynamicConcurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.targetConcurrency = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxConcurrency = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      targetConcurrency: isSet3(object.targetConcurrency) ? globalThis.Number(object.targetConcurrency) : 0,
      maxConcurrency: isSet3(object.maxConcurrency) ? globalThis.Number(object.maxConcurrency) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.targetConcurrency !== 0) {
      obj.targetConcurrency = Math.round(message.targetConcurrency);
    }
    if (message.maxConcurrency !== 0) {
      obj.maxConcurrency = Math.round(message.maxConcurrency);
    }
    return obj;
  },
  create(base) {
    return FunctionGetDynamicConcurrencyRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetDynamicConcurrencyRequest();
    message.functionId = object.functionId ?? "";
    message.targetConcurrency = object.targetConcurrency ?? 0;
    message.maxConcurrency = object.maxConcurrency ?? 0;
    return message;
  }
};
function createBaseFunctionGetDynamicConcurrencyResponse() {
  return { concurrency: 0 };
}
var FunctionGetDynamicConcurrencyResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.concurrency !== 0) {
      writer.uint32(8).uint32(message.concurrency);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetDynamicConcurrencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.concurrency = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { concurrency: isSet3(object.concurrency) ? globalThis.Number(object.concurrency) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.concurrency !== 0) {
      obj.concurrency = Math.round(message.concurrency);
    }
    return obj;
  },
  create(base) {
    return FunctionGetDynamicConcurrencyResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetDynamicConcurrencyResponse();
    message.concurrency = object.concurrency ?? 0;
    return message;
  }
};
function createBaseFunctionGetInputsItem() {
  return {
    inputId: "",
    input: void 0,
    killSwitch: false,
    functionCallId: "",
    functionCallInvocationType: 0,
    retryCount: 0,
    functionMapIdx: void 0,
    attemptToken: ""
  };
}
var FunctionGetInputsItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.inputId !== "") {
      writer.uint32(10).string(message.inputId);
    }
    if (message.input !== void 0) {
      FunctionInput.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.killSwitch !== false) {
      writer.uint32(24).bool(message.killSwitch);
    }
    if (message.functionCallId !== "") {
      writer.uint32(42).string(message.functionCallId);
    }
    if (message.functionCallInvocationType !== 0) {
      writer.uint32(48).int32(message.functionCallInvocationType);
    }
    if (message.retryCount !== 0) {
      writer.uint32(56).uint32(message.retryCount);
    }
    if (message.functionMapIdx !== void 0) {
      writer.uint32(64).int32(message.functionMapIdx);
    }
    if (message.attemptToken !== "") {
      writer.uint32(74).string(message.attemptToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetInputsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.input = FunctionInput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.killSwitch = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.functionCallInvocationType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.retryCount = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.functionMapIdx = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      input: isSet3(object.input) ? FunctionInput.fromJSON(object.input) : void 0,
      killSwitch: isSet3(object.killSwitch) ? globalThis.Boolean(object.killSwitch) : false,
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      functionCallInvocationType: isSet3(object.functionCallInvocationType) ? functionCallInvocationTypeFromJSON(object.functionCallInvocationType) : 0,
      retryCount: isSet3(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      functionMapIdx: isSet3(object.functionMapIdx) ? globalThis.Number(object.functionMapIdx) : void 0,
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.input !== void 0) {
      obj.input = FunctionInput.toJSON(message.input);
    }
    if (message.killSwitch !== false) {
      obj.killSwitch = message.killSwitch;
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.functionCallInvocationType !== 0) {
      obj.functionCallInvocationType = functionCallInvocationTypeToJSON(message.functionCallInvocationType);
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.functionMapIdx !== void 0) {
      obj.functionMapIdx = Math.round(message.functionMapIdx);
    }
    if (message.attemptToken !== "") {
      obj.attemptToken = message.attemptToken;
    }
    return obj;
  },
  create(base) {
    return FunctionGetInputsItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetInputsItem();
    message.inputId = object.inputId ?? "";
    message.input = object.input !== void 0 && object.input !== null ? FunctionInput.fromPartial(object.input) : void 0;
    message.killSwitch = object.killSwitch ?? false;
    message.functionCallId = object.functionCallId ?? "";
    message.functionCallInvocationType = object.functionCallInvocationType ?? 0;
    message.retryCount = object.retryCount ?? 0;
    message.functionMapIdx = object.functionMapIdx ?? void 0;
    message.attemptToken = object.attemptToken ?? "";
    return message;
  }
};
function createBaseFunctionGetInputsRequest() {
  return { functionId: "", maxValues: 0, averageCallTime: 0, inputConcurrency: 0, batchMaxSize: 0, batchLingerMs: 0 };
}
var FunctionGetInputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.maxValues !== 0) {
      writer.uint32(24).int32(message.maxValues);
    }
    if (message.averageCallTime !== 0) {
      writer.uint32(45).float(message.averageCallTime);
    }
    if (message.inputConcurrency !== 0) {
      writer.uint32(48).int32(message.inputConcurrency);
    }
    if (message.batchMaxSize !== 0) {
      writer.uint32(88).uint32(message.batchMaxSize);
    }
    if (message.batchLingerMs !== 0) {
      writer.uint32(96).uint64(message.batchLingerMs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxValues = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }
          message.averageCallTime = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.inputConcurrency = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.batchMaxSize = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.batchLingerMs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      maxValues: isSet3(object.maxValues) ? globalThis.Number(object.maxValues) : 0,
      averageCallTime: isSet3(object.averageCallTime) ? globalThis.Number(object.averageCallTime) : 0,
      inputConcurrency: isSet3(object.inputConcurrency) ? globalThis.Number(object.inputConcurrency) : 0,
      batchMaxSize: isSet3(object.batchMaxSize) ? globalThis.Number(object.batchMaxSize) : 0,
      batchLingerMs: isSet3(object.batchLingerMs) ? globalThis.Number(object.batchLingerMs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.maxValues !== 0) {
      obj.maxValues = Math.round(message.maxValues);
    }
    if (message.averageCallTime !== 0) {
      obj.averageCallTime = message.averageCallTime;
    }
    if (message.inputConcurrency !== 0) {
      obj.inputConcurrency = Math.round(message.inputConcurrency);
    }
    if (message.batchMaxSize !== 0) {
      obj.batchMaxSize = Math.round(message.batchMaxSize);
    }
    if (message.batchLingerMs !== 0) {
      obj.batchLingerMs = Math.round(message.batchLingerMs);
    }
    return obj;
  },
  create(base) {
    return FunctionGetInputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetInputsRequest();
    message.functionId = object.functionId ?? "";
    message.maxValues = object.maxValues ?? 0;
    message.averageCallTime = object.averageCallTime ?? 0;
    message.inputConcurrency = object.inputConcurrency ?? 0;
    message.batchMaxSize = object.batchMaxSize ?? 0;
    message.batchLingerMs = object.batchLingerMs ?? 0;
    return message;
  }
};
function createBaseFunctionGetInputsResponse() {
  return { inputs: [], rateLimitSleepDuration: 0 };
}
var FunctionGetInputsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.inputs) {
      FunctionGetInputsItem.encode(v, writer.uint32(26).fork()).join();
    }
    if (message.rateLimitSleepDuration !== 0) {
      writer.uint32(37).float(message.rateLimitSleepDuration);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetInputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.inputs.push(FunctionGetInputsItem.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }
          message.rateLimitSleepDuration = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e) => FunctionGetInputsItem.fromJSON(e)) : [],
      rateLimitSleepDuration: isSet3(object.rateLimitSleepDuration) ? globalThis.Number(object.rateLimitSleepDuration) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => FunctionGetInputsItem.toJSON(e));
    }
    if (message.rateLimitSleepDuration !== 0) {
      obj.rateLimitSleepDuration = message.rateLimitSleepDuration;
    }
    return obj;
  },
  create(base) {
    return FunctionGetInputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetInputsResponse();
    message.inputs = object.inputs?.map((e) => FunctionGetInputsItem.fromPartial(e)) || [];
    message.rateLimitSleepDuration = object.rateLimitSleepDuration ?? 0;
    return message;
  }
};
function createBaseFunctionGetOutputsItem() {
  return {
    result: void 0,
    idx: 0,
    inputId: "",
    dataFormat: 0,
    taskId: "",
    inputStartedAt: 0,
    outputCreatedAt: 0,
    retryCount: 0,
    fcTraceTag: ""
  };
}
var FunctionGetOutputsItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    if (message.idx !== 0) {
      writer.uint32(16).int32(message.idx);
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    if (message.dataFormat !== 0) {
      writer.uint32(40).int32(message.dataFormat);
    }
    if (message.taskId !== "") {
      writer.uint32(50).string(message.taskId);
    }
    if (message.inputStartedAt !== 0) {
      writer.uint32(57).double(message.inputStartedAt);
    }
    if (message.outputCreatedAt !== 0) {
      writer.uint32(65).double(message.outputCreatedAt);
    }
    if (message.retryCount !== 0) {
      writer.uint32(72).uint32(message.retryCount);
    }
    if (message.fcTraceTag !== "") {
      writer.uint32(82).string(message.fcTraceTag);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetOutputsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.idx = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.dataFormat = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }
          message.inputStartedAt = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }
          message.outputCreatedAt = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.retryCount = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.fcTraceTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      idx: isSet3(object.idx) ? globalThis.Number(object.idx) : 0,
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      dataFormat: isSet3(object.dataFormat) ? dataFormatFromJSON(object.dataFormat) : 0,
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      inputStartedAt: isSet3(object.inputStartedAt) ? globalThis.Number(object.inputStartedAt) : 0,
      outputCreatedAt: isSet3(object.outputCreatedAt) ? globalThis.Number(object.outputCreatedAt) : 0,
      retryCount: isSet3(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      fcTraceTag: isSet3(object.fcTraceTag) ? globalThis.String(object.fcTraceTag) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.idx !== 0) {
      obj.idx = Math.round(message.idx);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = dataFormatToJSON(message.dataFormat);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.inputStartedAt !== 0) {
      obj.inputStartedAt = message.inputStartedAt;
    }
    if (message.outputCreatedAt !== 0) {
      obj.outputCreatedAt = message.outputCreatedAt;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.fcTraceTag !== "") {
      obj.fcTraceTag = message.fcTraceTag;
    }
    return obj;
  },
  create(base) {
    return FunctionGetOutputsItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetOutputsItem();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.idx = object.idx ?? 0;
    message.inputId = object.inputId ?? "";
    message.dataFormat = object.dataFormat ?? 0;
    message.taskId = object.taskId ?? "";
    message.inputStartedAt = object.inputStartedAt ?? 0;
    message.outputCreatedAt = object.outputCreatedAt ?? 0;
    message.retryCount = object.retryCount ?? 0;
    message.fcTraceTag = object.fcTraceTag ?? "";
    return message;
  }
};
function createBaseFunctionGetOutputsRequest() {
  return {
    functionCallId: "",
    maxValues: 0,
    timeout: 0,
    lastEntryId: "",
    clearOnSuccess: false,
    requestedAt: 0,
    inputJwts: [],
    startIdx: void 0,
    endIdx: void 0
  };
}
var FunctionGetOutputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.maxValues !== 0) {
      writer.uint32(16).int32(message.maxValues);
    }
    if (message.timeout !== 0) {
      writer.uint32(29).float(message.timeout);
    }
    if (message.lastEntryId !== "") {
      writer.uint32(50).string(message.lastEntryId);
    }
    if (message.clearOnSuccess !== false) {
      writer.uint32(56).bool(message.clearOnSuccess);
    }
    if (message.requestedAt !== 0) {
      writer.uint32(65).double(message.requestedAt);
    }
    for (const v of message.inputJwts) {
      writer.uint32(74).string(v);
    }
    if (message.startIdx !== void 0) {
      writer.uint32(80).int32(message.startIdx);
    }
    if (message.endIdx !== void 0) {
      writer.uint32(88).int32(message.endIdx);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetOutputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.maxValues = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.clearOnSuccess = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }
          message.requestedAt = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.inputJwts.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.startIdx = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.endIdx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      maxValues: isSet3(object.maxValues) ? globalThis.Number(object.maxValues) : 0,
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      clearOnSuccess: isSet3(object.clearOnSuccess) ? globalThis.Boolean(object.clearOnSuccess) : false,
      requestedAt: isSet3(object.requestedAt) ? globalThis.Number(object.requestedAt) : 0,
      inputJwts: globalThis.Array.isArray(object?.inputJwts) ? object.inputJwts.map((e) => globalThis.String(e)) : [],
      startIdx: isSet3(object.startIdx) ? globalThis.Number(object.startIdx) : void 0,
      endIdx: isSet3(object.endIdx) ? globalThis.Number(object.endIdx) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.maxValues !== 0) {
      obj.maxValues = Math.round(message.maxValues);
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.clearOnSuccess !== false) {
      obj.clearOnSuccess = message.clearOnSuccess;
    }
    if (message.requestedAt !== 0) {
      obj.requestedAt = message.requestedAt;
    }
    if (message.inputJwts?.length) {
      obj.inputJwts = message.inputJwts;
    }
    if (message.startIdx !== void 0) {
      obj.startIdx = Math.round(message.startIdx);
    }
    if (message.endIdx !== void 0) {
      obj.endIdx = Math.round(message.endIdx);
    }
    return obj;
  },
  create(base) {
    return FunctionGetOutputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetOutputsRequest();
    message.functionCallId = object.functionCallId ?? "";
    message.maxValues = object.maxValues ?? 0;
    message.timeout = object.timeout ?? 0;
    message.lastEntryId = object.lastEntryId ?? "";
    message.clearOnSuccess = object.clearOnSuccess ?? false;
    message.requestedAt = object.requestedAt ?? 0;
    message.inputJwts = object.inputJwts?.map((e) => e) || [];
    message.startIdx = object.startIdx ?? void 0;
    message.endIdx = object.endIdx ?? void 0;
    return message;
  }
};
function createBaseFunctionGetOutputsResponse() {
  return { idxs: [], outputs: [], lastEntryId: "", numUnfinishedInputs: 0 };
}
var FunctionGetOutputsResponse = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(26).fork();
    for (const v of message.idxs) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.outputs) {
      FunctionGetOutputsItem.encode(v, writer.uint32(34).fork()).join();
    }
    if (message.lastEntryId !== "") {
      writer.uint32(42).string(message.lastEntryId);
    }
    if (message.numUnfinishedInputs !== 0) {
      writer.uint32(48).int32(message.numUnfinishedInputs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetOutputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag === 24) {
            message.idxs.push(reader.int32());
            continue;
          }
          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.idxs.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.outputs.push(FunctionGetOutputsItem.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.numUnfinishedInputs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      idxs: globalThis.Array.isArray(object?.idxs) ? object.idxs.map((e) => globalThis.Number(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e) => FunctionGetOutputsItem.fromJSON(e)) : [],
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      numUnfinishedInputs: isSet3(object.numUnfinishedInputs) ? globalThis.Number(object.numUnfinishedInputs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.idxs?.length) {
      obj.idxs = message.idxs.map((e) => Math.round(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => FunctionGetOutputsItem.toJSON(e));
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.numUnfinishedInputs !== 0) {
      obj.numUnfinishedInputs = Math.round(message.numUnfinishedInputs);
    }
    return obj;
  },
  create(base) {
    return FunctionGetOutputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetOutputsResponse();
    message.idxs = object.idxs?.map((e) => e) || [];
    message.outputs = object.outputs?.map((e) => FunctionGetOutputsItem.fromPartial(e)) || [];
    message.lastEntryId = object.lastEntryId ?? "";
    message.numUnfinishedInputs = object.numUnfinishedInputs ?? 0;
    return message;
  }
};
function createBaseFunctionGetRequest() {
  return { appName: "", objectTag: "", environmentName: "" };
}
var FunctionGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appName !== "") {
      writer.uint32(10).string(message.appName);
    }
    if (message.objectTag !== "") {
      writer.uint32(18).string(message.objectTag);
    }
    if (message.environmentName !== "") {
      writer.uint32(34).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.objectTag = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appName: isSet3(object.appName) ? globalThis.String(object.appName) : "",
      objectTag: isSet3(object.objectTag) ? globalThis.String(object.objectTag) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    if (message.objectTag !== "") {
      obj.objectTag = message.objectTag;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return FunctionGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetRequest();
    message.appName = object.appName ?? "";
    message.objectTag = object.objectTag ?? "";
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseFunctionGetResponse() {
  return { functionId: "", handleMetadata: void 0, serverWarnings: [] };
}
var FunctionGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.handleMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.handleMetadata, writer.uint32(18).fork()).join();
    }
    for (const v of message.serverWarnings) {
      Warning.encode(v, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.handleMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.serverWarnings.push(Warning.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      handleMetadata: isSet3(object.handleMetadata) ? FunctionHandleMetadata.fromJSON(object.handleMetadata) : void 0,
      serverWarnings: globalThis.Array.isArray(object?.serverWarnings) ? object.serverWarnings.map((e) => Warning.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = FunctionHandleMetadata.toJSON(message.handleMetadata);
    }
    if (message.serverWarnings?.length) {
      obj.serverWarnings = message.serverWarnings.map((e) => Warning.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetResponse();
    message.functionId = object.functionId ?? "";
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? FunctionHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    message.serverWarnings = object.serverWarnings?.map((e) => Warning.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionGetSerializedRequest() {
  return { functionId: "" };
}
var FunctionGetSerializedRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetSerializedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    return obj;
  },
  create(base) {
    return FunctionGetSerializedRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetSerializedRequest();
    message.functionId = object.functionId ?? "";
    return message;
  }
};
function createBaseFunctionGetSerializedResponse() {
  return { functionSerialized: new Uint8Array(0), classSerialized: new Uint8Array(0) };
}
var FunctionGetSerializedResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionSerialized.length !== 0) {
      writer.uint32(10).bytes(message.functionSerialized);
    }
    if (message.classSerialized.length !== 0) {
      writer.uint32(18).bytes(message.classSerialized);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionGetSerializedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionSerialized = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.classSerialized = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionSerialized: isSet3(object.functionSerialized) ? bytesFromBase64(object.functionSerialized) : new Uint8Array(0),
      classSerialized: isSet3(object.classSerialized) ? bytesFromBase64(object.classSerialized) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionSerialized.length !== 0) {
      obj.functionSerialized = base64FromBytes(message.functionSerialized);
    }
    if (message.classSerialized.length !== 0) {
      obj.classSerialized = base64FromBytes(message.classSerialized);
    }
    return obj;
  },
  create(base) {
    return FunctionGetSerializedResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionGetSerializedResponse();
    message.functionSerialized = object.functionSerialized ?? new Uint8Array(0);
    message.classSerialized = object.classSerialized ?? new Uint8Array(0);
    return message;
  }
};
function createBaseFunctionHandleMetadata() {
  return {
    functionName: "",
    functionType: 0,
    webUrl: "",
    isMethod: false,
    useFunctionId: "",
    useMethodName: "",
    definitionId: "",
    classParameterInfo: void 0,
    methodHandleMetadata: {},
    functionSchema: void 0,
    inputPlaneUrl: void 0,
    inputPlaneRegion: void 0,
    maxObjectSizeBytes: void 0,
    ExperimentalFlashUrls: [],
    supportedInputFormats: [],
    supportedOutputFormats: []
  };
}
var FunctionHandleMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionName !== "") {
      writer.uint32(18).string(message.functionName);
    }
    if (message.functionType !== 0) {
      writer.uint32(64).int32(message.functionType);
    }
    if (message.webUrl !== "") {
      writer.uint32(226).string(message.webUrl);
    }
    if (message.isMethod !== false) {
      writer.uint32(312).bool(message.isMethod);
    }
    if (message.useFunctionId !== "") {
      writer.uint32(322).string(message.useFunctionId);
    }
    if (message.useMethodName !== "") {
      writer.uint32(330).string(message.useMethodName);
    }
    if (message.definitionId !== "") {
      writer.uint32(338).string(message.definitionId);
    }
    if (message.classParameterInfo !== void 0) {
      ClassParameterInfo.encode(message.classParameterInfo, writer.uint32(346).fork()).join();
    }
    Object.entries(message.methodHandleMetadata).forEach(([key, value]) => {
      FunctionHandleMetadata_MethodHandleMetadataEntry.encode({ key, value }, writer.uint32(354).fork()).join();
    });
    if (message.functionSchema !== void 0) {
      FunctionSchema.encode(message.functionSchema, writer.uint32(362).fork()).join();
    }
    if (message.inputPlaneUrl !== void 0) {
      writer.uint32(370).string(message.inputPlaneUrl);
    }
    if (message.inputPlaneRegion !== void 0) {
      writer.uint32(378).string(message.inputPlaneRegion);
    }
    if (message.maxObjectSizeBytes !== void 0) {
      writer.uint32(384).uint64(message.maxObjectSizeBytes);
    }
    for (const v of message.ExperimentalFlashUrls) {
      writer.uint32(394).string(v);
    }
    writer.uint32(402).fork();
    for (const v of message.supportedInputFormats) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(410).fork();
    for (const v of message.supportedOutputFormats) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionHandleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.functionType = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }
          message.webUrl = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }
          message.isMethod = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }
          message.useFunctionId = reader.string();
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }
          message.useMethodName = reader.string();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }
          message.definitionId = reader.string();
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }
          message.classParameterInfo = ClassParameterInfo.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }
          const entry44 = FunctionHandleMetadata_MethodHandleMetadataEntry.decode(reader, reader.uint32());
          if (entry44.value !== void 0) {
            message.methodHandleMetadata[entry44.key] = entry44.value;
          }
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }
          message.functionSchema = FunctionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }
          message.inputPlaneUrl = reader.string();
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }
          message.inputPlaneRegion = reader.string();
          continue;
        }
        case 48: {
          if (tag !== 384) {
            break;
          }
          message.maxObjectSizeBytes = longToNumber(reader.uint64());
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }
          message.ExperimentalFlashUrls.push(reader.string());
          continue;
        }
        case 50: {
          if (tag === 400) {
            message.supportedInputFormats.push(reader.int32());
            continue;
          }
          if (tag === 402) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedInputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 51: {
          if (tag === 408) {
            message.supportedOutputFormats.push(reader.int32());
            continue;
          }
          if (tag === 410) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedOutputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      functionType: isSet3(object.functionType) ? function_FunctionTypeFromJSON(object.functionType) : 0,
      webUrl: isSet3(object.webUrl) ? globalThis.String(object.webUrl) : "",
      isMethod: isSet3(object.isMethod) ? globalThis.Boolean(object.isMethod) : false,
      useFunctionId: isSet3(object.useFunctionId) ? globalThis.String(object.useFunctionId) : "",
      useMethodName: isSet3(object.useMethodName) ? globalThis.String(object.useMethodName) : "",
      definitionId: isSet3(object.definitionId) ? globalThis.String(object.definitionId) : "",
      classParameterInfo: isSet3(object.classParameterInfo) ? ClassParameterInfo.fromJSON(object.classParameterInfo) : void 0,
      methodHandleMetadata: isObject2(object.methodHandleMetadata) ? Object.entries(object.methodHandleMetadata).reduce(
        (acc, [key, value]) => {
          acc[key] = FunctionHandleMetadata.fromJSON(value);
          return acc;
        },
        {}
      ) : {},
      functionSchema: isSet3(object.functionSchema) ? FunctionSchema.fromJSON(object.functionSchema) : void 0,
      inputPlaneUrl: isSet3(object.inputPlaneUrl) ? globalThis.String(object.inputPlaneUrl) : void 0,
      inputPlaneRegion: isSet3(object.inputPlaneRegion) ? globalThis.String(object.inputPlaneRegion) : void 0,
      maxObjectSizeBytes: isSet3(object.maxObjectSizeBytes) ? globalThis.Number(object.maxObjectSizeBytes) : void 0,
      ExperimentalFlashUrls: globalThis.Array.isArray(object?.ExperimentalFlashUrls) ? object.ExperimentalFlashUrls.map((e) => globalThis.String(e)) : [],
      supportedInputFormats: globalThis.Array.isArray(object?.supportedInputFormats) ? object.supportedInputFormats.map((e) => dataFormatFromJSON(e)) : [],
      supportedOutputFormats: globalThis.Array.isArray(object?.supportedOutputFormats) ? object.supportedOutputFormats.map((e) => dataFormatFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.functionType !== 0) {
      obj.functionType = function_FunctionTypeToJSON(message.functionType);
    }
    if (message.webUrl !== "") {
      obj.webUrl = message.webUrl;
    }
    if (message.isMethod !== false) {
      obj.isMethod = message.isMethod;
    }
    if (message.useFunctionId !== "") {
      obj.useFunctionId = message.useFunctionId;
    }
    if (message.useMethodName !== "") {
      obj.useMethodName = message.useMethodName;
    }
    if (message.definitionId !== "") {
      obj.definitionId = message.definitionId;
    }
    if (message.classParameterInfo !== void 0) {
      obj.classParameterInfo = ClassParameterInfo.toJSON(message.classParameterInfo);
    }
    if (message.methodHandleMetadata) {
      const entries = Object.entries(message.methodHandleMetadata);
      if (entries.length > 0) {
        obj.methodHandleMetadata = {};
        entries.forEach(([k, v]) => {
          obj.methodHandleMetadata[k] = FunctionHandleMetadata.toJSON(v);
        });
      }
    }
    if (message.functionSchema !== void 0) {
      obj.functionSchema = FunctionSchema.toJSON(message.functionSchema);
    }
    if (message.inputPlaneUrl !== void 0) {
      obj.inputPlaneUrl = message.inputPlaneUrl;
    }
    if (message.inputPlaneRegion !== void 0) {
      obj.inputPlaneRegion = message.inputPlaneRegion;
    }
    if (message.maxObjectSizeBytes !== void 0) {
      obj.maxObjectSizeBytes = Math.round(message.maxObjectSizeBytes);
    }
    if (message.ExperimentalFlashUrls?.length) {
      obj.ExperimentalFlashUrls = message.ExperimentalFlashUrls;
    }
    if (message.supportedInputFormats?.length) {
      obj.supportedInputFormats = message.supportedInputFormats.map((e) => dataFormatToJSON(e));
    }
    if (message.supportedOutputFormats?.length) {
      obj.supportedOutputFormats = message.supportedOutputFormats.map((e) => dataFormatToJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionHandleMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionHandleMetadata();
    message.functionName = object.functionName ?? "";
    message.functionType = object.functionType ?? 0;
    message.webUrl = object.webUrl ?? "";
    message.isMethod = object.isMethod ?? false;
    message.useFunctionId = object.useFunctionId ?? "";
    message.useMethodName = object.useMethodName ?? "";
    message.definitionId = object.definitionId ?? "";
    message.classParameterInfo = object.classParameterInfo !== void 0 && object.classParameterInfo !== null ? ClassParameterInfo.fromPartial(object.classParameterInfo) : void 0;
    message.methodHandleMetadata = Object.entries(object.methodHandleMetadata ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = FunctionHandleMetadata.fromPartial(value);
      }
      return acc;
    }, {});
    message.functionSchema = object.functionSchema !== void 0 && object.functionSchema !== null ? FunctionSchema.fromPartial(object.functionSchema) : void 0;
    message.inputPlaneUrl = object.inputPlaneUrl ?? void 0;
    message.inputPlaneRegion = object.inputPlaneRegion ?? void 0;
    message.maxObjectSizeBytes = object.maxObjectSizeBytes ?? void 0;
    message.ExperimentalFlashUrls = object.ExperimentalFlashUrls?.map((e) => e) || [];
    message.supportedInputFormats = object.supportedInputFormats?.map((e) => e) || [];
    message.supportedOutputFormats = object.supportedOutputFormats?.map((e) => e) || [];
    return message;
  }
};
function createBaseFunctionHandleMetadata_MethodHandleMetadataEntry() {
  return { key: "", value: void 0 };
}
var FunctionHandleMetadata_MethodHandleMetadataEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      FunctionHandleMetadata.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionHandleMetadata_MethodHandleMetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? FunctionHandleMetadata.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = FunctionHandleMetadata.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return FunctionHandleMetadata_MethodHandleMetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionHandleMetadata_MethodHandleMetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? FunctionHandleMetadata.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseFunctionInput() {
  return { args: void 0, argsBlobId: void 0, finalInput: false, dataFormat: 0, methodName: void 0 };
}
var FunctionInput = {
  encode(message, writer = new BinaryWriter()) {
    if (message.args !== void 0) {
      writer.uint32(10).bytes(message.args);
    }
    if (message.argsBlobId !== void 0) {
      writer.uint32(58).string(message.argsBlobId);
    }
    if (message.finalInput !== false) {
      writer.uint32(72).bool(message.finalInput);
    }
    if (message.dataFormat !== 0) {
      writer.uint32(80).int32(message.dataFormat);
    }
    if (message.methodName !== void 0) {
      writer.uint32(90).string(message.methodName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.args = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.argsBlobId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.finalInput = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.dataFormat = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.methodName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      args: isSet3(object.args) ? bytesFromBase64(object.args) : void 0,
      argsBlobId: isSet3(object.argsBlobId) ? globalThis.String(object.argsBlobId) : void 0,
      finalInput: isSet3(object.finalInput) ? globalThis.Boolean(object.finalInput) : false,
      dataFormat: isSet3(object.dataFormat) ? dataFormatFromJSON(object.dataFormat) : 0,
      methodName: isSet3(object.methodName) ? globalThis.String(object.methodName) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.args !== void 0) {
      obj.args = base64FromBytes(message.args);
    }
    if (message.argsBlobId !== void 0) {
      obj.argsBlobId = message.argsBlobId;
    }
    if (message.finalInput !== false) {
      obj.finalInput = message.finalInput;
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = dataFormatToJSON(message.dataFormat);
    }
    if (message.methodName !== void 0) {
      obj.methodName = message.methodName;
    }
    return obj;
  },
  create(base) {
    return FunctionInput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionInput();
    message.args = object.args ?? void 0;
    message.argsBlobId = object.argsBlobId ?? void 0;
    message.finalInput = object.finalInput ?? false;
    message.dataFormat = object.dataFormat ?? 0;
    message.methodName = object.methodName ?? void 0;
    return message;
  }
};
function createBaseFunctionMapRequest() {
  return {
    functionId: "",
    parentInputId: "",
    returnExceptions: false,
    functionCallType: 0,
    pipelinedInputs: [],
    functionCallInvocationType: 0,
    fromSpawnMap: false
  };
}
var FunctionMapRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.parentInputId !== "") {
      writer.uint32(18).string(message.parentInputId);
    }
    if (message.returnExceptions !== false) {
      writer.uint32(24).bool(message.returnExceptions);
    }
    if (message.functionCallType !== 0) {
      writer.uint32(32).int32(message.functionCallType);
    }
    for (const v of message.pipelinedInputs) {
      FunctionPutInputsItem.encode(v, writer.uint32(42).fork()).join();
    }
    if (message.functionCallInvocationType !== 0) {
      writer.uint32(48).int32(message.functionCallInvocationType);
    }
    if (message.fromSpawnMap !== false) {
      writer.uint32(56).bool(message.fromSpawnMap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.parentInputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.returnExceptions = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.functionCallType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.pipelinedInputs.push(FunctionPutInputsItem.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.functionCallInvocationType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.fromSpawnMap = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      parentInputId: isSet3(object.parentInputId) ? globalThis.String(object.parentInputId) : "",
      returnExceptions: isSet3(object.returnExceptions) ? globalThis.Boolean(object.returnExceptions) : false,
      functionCallType: isSet3(object.functionCallType) ? functionCallTypeFromJSON(object.functionCallType) : 0,
      pipelinedInputs: globalThis.Array.isArray(object?.pipelinedInputs) ? object.pipelinedInputs.map((e) => FunctionPutInputsItem.fromJSON(e)) : [],
      functionCallInvocationType: isSet3(object.functionCallInvocationType) ? functionCallInvocationTypeFromJSON(object.functionCallInvocationType) : 0,
      fromSpawnMap: isSet3(object.fromSpawnMap) ? globalThis.Boolean(object.fromSpawnMap) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.parentInputId !== "") {
      obj.parentInputId = message.parentInputId;
    }
    if (message.returnExceptions !== false) {
      obj.returnExceptions = message.returnExceptions;
    }
    if (message.functionCallType !== 0) {
      obj.functionCallType = functionCallTypeToJSON(message.functionCallType);
    }
    if (message.pipelinedInputs?.length) {
      obj.pipelinedInputs = message.pipelinedInputs.map((e) => FunctionPutInputsItem.toJSON(e));
    }
    if (message.functionCallInvocationType !== 0) {
      obj.functionCallInvocationType = functionCallInvocationTypeToJSON(message.functionCallInvocationType);
    }
    if (message.fromSpawnMap !== false) {
      obj.fromSpawnMap = message.fromSpawnMap;
    }
    return obj;
  },
  create(base) {
    return FunctionMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionMapRequest();
    message.functionId = object.functionId ?? "";
    message.parentInputId = object.parentInputId ?? "";
    message.returnExceptions = object.returnExceptions ?? false;
    message.functionCallType = object.functionCallType ?? 0;
    message.pipelinedInputs = object.pipelinedInputs?.map((e) => FunctionPutInputsItem.fromPartial(e)) || [];
    message.functionCallInvocationType = object.functionCallInvocationType ?? 0;
    message.fromSpawnMap = object.fromSpawnMap ?? false;
    return message;
  }
};
function createBaseFunctionMapResponse() {
  return {
    functionCallId: "",
    pipelinedInputs: [],
    retryPolicy: void 0,
    functionCallJwt: "",
    syncClientRetriesEnabled: false,
    maxInputsOutstanding: 0
  };
}
var FunctionMapResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== "") {
      writer.uint32(10).string(message.functionCallId);
    }
    for (const v of message.pipelinedInputs) {
      FunctionPutInputsResponseItem.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.retryPolicy !== void 0) {
      FunctionRetryPolicy.encode(message.retryPolicy, writer.uint32(26).fork()).join();
    }
    if (message.functionCallJwt !== "") {
      writer.uint32(34).string(message.functionCallJwt);
    }
    if (message.syncClientRetriesEnabled !== false) {
      writer.uint32(40).bool(message.syncClientRetriesEnabled);
    }
    if (message.maxInputsOutstanding !== 0) {
      writer.uint32(48).uint32(message.maxInputsOutstanding);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionMapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.pipelinedInputs.push(FunctionPutInputsResponseItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.retryPolicy = FunctionRetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.functionCallJwt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.syncClientRetriesEnabled = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.maxInputsOutstanding = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      pipelinedInputs: globalThis.Array.isArray(object?.pipelinedInputs) ? object.pipelinedInputs.map((e) => FunctionPutInputsResponseItem.fromJSON(e)) : [],
      retryPolicy: isSet3(object.retryPolicy) ? FunctionRetryPolicy.fromJSON(object.retryPolicy) : void 0,
      functionCallJwt: isSet3(object.functionCallJwt) ? globalThis.String(object.functionCallJwt) : "",
      syncClientRetriesEnabled: isSet3(object.syncClientRetriesEnabled) ? globalThis.Boolean(object.syncClientRetriesEnabled) : false,
      maxInputsOutstanding: isSet3(object.maxInputsOutstanding) ? globalThis.Number(object.maxInputsOutstanding) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.pipelinedInputs?.length) {
      obj.pipelinedInputs = message.pipelinedInputs.map((e) => FunctionPutInputsResponseItem.toJSON(e));
    }
    if (message.retryPolicy !== void 0) {
      obj.retryPolicy = FunctionRetryPolicy.toJSON(message.retryPolicy);
    }
    if (message.functionCallJwt !== "") {
      obj.functionCallJwt = message.functionCallJwt;
    }
    if (message.syncClientRetriesEnabled !== false) {
      obj.syncClientRetriesEnabled = message.syncClientRetriesEnabled;
    }
    if (message.maxInputsOutstanding !== 0) {
      obj.maxInputsOutstanding = Math.round(message.maxInputsOutstanding);
    }
    return obj;
  },
  create(base) {
    return FunctionMapResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionMapResponse();
    message.functionCallId = object.functionCallId ?? "";
    message.pipelinedInputs = object.pipelinedInputs?.map((e) => FunctionPutInputsResponseItem.fromPartial(e)) || [];
    message.retryPolicy = object.retryPolicy !== void 0 && object.retryPolicy !== null ? FunctionRetryPolicy.fromPartial(object.retryPolicy) : void 0;
    message.functionCallJwt = object.functionCallJwt ?? "";
    message.syncClientRetriesEnabled = object.syncClientRetriesEnabled ?? false;
    message.maxInputsOutstanding = object.maxInputsOutstanding ?? 0;
    return message;
  }
};
function createBaseFunctionOptions() {
  return {
    secretIds: [],
    mountIds: [],
    resources: void 0,
    retryPolicy: void 0,
    concurrencyLimit: void 0,
    timeoutSecs: void 0,
    taskIdleTimeoutSecs: void 0,
    warmPoolSize: void 0,
    volumeMounts: [],
    targetConcurrentInputs: void 0,
    replaceVolumeMounts: false,
    replaceSecretIds: false,
    bufferContainers: void 0,
    maxConcurrentInputs: void 0,
    batchMaxSize: void 0,
    batchLingerMs: void 0,
    schedulerPlacement: void 0,
    cloudProviderStr: void 0
  };
}
var FunctionOptions = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.secretIds) {
      writer.uint32(10).string(v);
    }
    for (const v of message.mountIds) {
      writer.uint32(18).string(v);
    }
    if (message.resources !== void 0) {
      Resources.encode(message.resources, writer.uint32(26).fork()).join();
    }
    if (message.retryPolicy !== void 0) {
      FunctionRetryPolicy.encode(message.retryPolicy, writer.uint32(34).fork()).join();
    }
    if (message.concurrencyLimit !== void 0) {
      writer.uint32(40).uint32(message.concurrencyLimit);
    }
    if (message.timeoutSecs !== void 0) {
      writer.uint32(48).uint32(message.timeoutSecs);
    }
    if (message.taskIdleTimeoutSecs !== void 0) {
      writer.uint32(56).uint32(message.taskIdleTimeoutSecs);
    }
    if (message.warmPoolSize !== void 0) {
      writer.uint32(64).uint32(message.warmPoolSize);
    }
    for (const v of message.volumeMounts) {
      VolumeMount.encode(v, writer.uint32(74).fork()).join();
    }
    if (message.targetConcurrentInputs !== void 0) {
      writer.uint32(80).uint32(message.targetConcurrentInputs);
    }
    if (message.replaceVolumeMounts !== false) {
      writer.uint32(88).bool(message.replaceVolumeMounts);
    }
    if (message.replaceSecretIds !== false) {
      writer.uint32(96).bool(message.replaceSecretIds);
    }
    if (message.bufferContainers !== void 0) {
      writer.uint32(104).uint32(message.bufferContainers);
    }
    if (message.maxConcurrentInputs !== void 0) {
      writer.uint32(112).uint32(message.maxConcurrentInputs);
    }
    if (message.batchMaxSize !== void 0) {
      writer.uint32(120).uint32(message.batchMaxSize);
    }
    if (message.batchLingerMs !== void 0) {
      writer.uint32(128).uint64(message.batchLingerMs);
    }
    if (message.schedulerPlacement !== void 0) {
      SchedulerPlacement.encode(message.schedulerPlacement, writer.uint32(138).fork()).join();
    }
    if (message.cloudProviderStr !== void 0) {
      writer.uint32(146).string(message.cloudProviderStr);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.secretIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mountIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.resources = Resources.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.retryPolicy = FunctionRetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.concurrencyLimit = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.timeoutSecs = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.taskIdleTimeoutSecs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.warmPoolSize = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.volumeMounts.push(VolumeMount.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.targetConcurrentInputs = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.replaceVolumeMounts = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.replaceSecretIds = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.bufferContainers = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }
          message.maxConcurrentInputs = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }
          message.batchMaxSize = reader.uint32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }
          message.batchLingerMs = longToNumber(reader.uint64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.schedulerPlacement = SchedulerPlacement.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.cloudProviderStr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      secretIds: globalThis.Array.isArray(object?.secretIds) ? object.secretIds.map((e) => globalThis.String(e)) : [],
      mountIds: globalThis.Array.isArray(object?.mountIds) ? object.mountIds.map((e) => globalThis.String(e)) : [],
      resources: isSet3(object.resources) ? Resources.fromJSON(object.resources) : void 0,
      retryPolicy: isSet3(object.retryPolicy) ? FunctionRetryPolicy.fromJSON(object.retryPolicy) : void 0,
      concurrencyLimit: isSet3(object.concurrencyLimit) ? globalThis.Number(object.concurrencyLimit) : void 0,
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : void 0,
      taskIdleTimeoutSecs: isSet3(object.taskIdleTimeoutSecs) ? globalThis.Number(object.taskIdleTimeoutSecs) : void 0,
      warmPoolSize: isSet3(object.warmPoolSize) ? globalThis.Number(object.warmPoolSize) : void 0,
      volumeMounts: globalThis.Array.isArray(object?.volumeMounts) ? object.volumeMounts.map((e) => VolumeMount.fromJSON(e)) : [],
      targetConcurrentInputs: isSet3(object.targetConcurrentInputs) ? globalThis.Number(object.targetConcurrentInputs) : void 0,
      replaceVolumeMounts: isSet3(object.replaceVolumeMounts) ? globalThis.Boolean(object.replaceVolumeMounts) : false,
      replaceSecretIds: isSet3(object.replaceSecretIds) ? globalThis.Boolean(object.replaceSecretIds) : false,
      bufferContainers: isSet3(object.bufferContainers) ? globalThis.Number(object.bufferContainers) : void 0,
      maxConcurrentInputs: isSet3(object.maxConcurrentInputs) ? globalThis.Number(object.maxConcurrentInputs) : void 0,
      batchMaxSize: isSet3(object.batchMaxSize) ? globalThis.Number(object.batchMaxSize) : void 0,
      batchLingerMs: isSet3(object.batchLingerMs) ? globalThis.Number(object.batchLingerMs) : void 0,
      schedulerPlacement: isSet3(object.schedulerPlacement) ? SchedulerPlacement.fromJSON(object.schedulerPlacement) : void 0,
      cloudProviderStr: isSet3(object.cloudProviderStr) ? globalThis.String(object.cloudProviderStr) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.secretIds?.length) {
      obj.secretIds = message.secretIds;
    }
    if (message.mountIds?.length) {
      obj.mountIds = message.mountIds;
    }
    if (message.resources !== void 0) {
      obj.resources = Resources.toJSON(message.resources);
    }
    if (message.retryPolicy !== void 0) {
      obj.retryPolicy = FunctionRetryPolicy.toJSON(message.retryPolicy);
    }
    if (message.concurrencyLimit !== void 0) {
      obj.concurrencyLimit = Math.round(message.concurrencyLimit);
    }
    if (message.timeoutSecs !== void 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    if (message.taskIdleTimeoutSecs !== void 0) {
      obj.taskIdleTimeoutSecs = Math.round(message.taskIdleTimeoutSecs);
    }
    if (message.warmPoolSize !== void 0) {
      obj.warmPoolSize = Math.round(message.warmPoolSize);
    }
    if (message.volumeMounts?.length) {
      obj.volumeMounts = message.volumeMounts.map((e) => VolumeMount.toJSON(e));
    }
    if (message.targetConcurrentInputs !== void 0) {
      obj.targetConcurrentInputs = Math.round(message.targetConcurrentInputs);
    }
    if (message.replaceVolumeMounts !== false) {
      obj.replaceVolumeMounts = message.replaceVolumeMounts;
    }
    if (message.replaceSecretIds !== false) {
      obj.replaceSecretIds = message.replaceSecretIds;
    }
    if (message.bufferContainers !== void 0) {
      obj.bufferContainers = Math.round(message.bufferContainers);
    }
    if (message.maxConcurrentInputs !== void 0) {
      obj.maxConcurrentInputs = Math.round(message.maxConcurrentInputs);
    }
    if (message.batchMaxSize !== void 0) {
      obj.batchMaxSize = Math.round(message.batchMaxSize);
    }
    if (message.batchLingerMs !== void 0) {
      obj.batchLingerMs = Math.round(message.batchLingerMs);
    }
    if (message.schedulerPlacement !== void 0) {
      obj.schedulerPlacement = SchedulerPlacement.toJSON(message.schedulerPlacement);
    }
    if (message.cloudProviderStr !== void 0) {
      obj.cloudProviderStr = message.cloudProviderStr;
    }
    return obj;
  },
  create(base) {
    return FunctionOptions.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionOptions();
    message.secretIds = object.secretIds?.map((e) => e) || [];
    message.mountIds = object.mountIds?.map((e) => e) || [];
    message.resources = object.resources !== void 0 && object.resources !== null ? Resources.fromPartial(object.resources) : void 0;
    message.retryPolicy = object.retryPolicy !== void 0 && object.retryPolicy !== null ? FunctionRetryPolicy.fromPartial(object.retryPolicy) : void 0;
    message.concurrencyLimit = object.concurrencyLimit ?? void 0;
    message.timeoutSecs = object.timeoutSecs ?? void 0;
    message.taskIdleTimeoutSecs = object.taskIdleTimeoutSecs ?? void 0;
    message.warmPoolSize = object.warmPoolSize ?? void 0;
    message.volumeMounts = object.volumeMounts?.map((e) => VolumeMount.fromPartial(e)) || [];
    message.targetConcurrentInputs = object.targetConcurrentInputs ?? void 0;
    message.replaceVolumeMounts = object.replaceVolumeMounts ?? false;
    message.replaceSecretIds = object.replaceSecretIds ?? false;
    message.bufferContainers = object.bufferContainers ?? void 0;
    message.maxConcurrentInputs = object.maxConcurrentInputs ?? void 0;
    message.batchMaxSize = object.batchMaxSize ?? void 0;
    message.batchLingerMs = object.batchLingerMs ?? void 0;
    message.schedulerPlacement = object.schedulerPlacement !== void 0 && object.schedulerPlacement !== null ? SchedulerPlacement.fromPartial(object.schedulerPlacement) : void 0;
    message.cloudProviderStr = object.cloudProviderStr ?? void 0;
    return message;
  }
};
function createBaseFunctionPrecreateRequest() {
  return {
    appId: "",
    functionName: "",
    existingFunctionId: "",
    functionType: 0,
    webhookConfig: void 0,
    useFunctionId: "",
    useMethodName: "",
    methodDefinitions: {},
    functionSchema: void 0,
    supportedInputFormats: [],
    supportedOutputFormats: []
  };
}
var FunctionPrecreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.functionName !== "") {
      writer.uint32(18).string(message.functionName);
    }
    if (message.existingFunctionId !== "") {
      writer.uint32(26).string(message.existingFunctionId);
    }
    if (message.functionType !== 0) {
      writer.uint32(32).int32(message.functionType);
    }
    if (message.webhookConfig !== void 0) {
      WebhookConfig.encode(message.webhookConfig, writer.uint32(42).fork()).join();
    }
    if (message.useFunctionId !== "") {
      writer.uint32(50).string(message.useFunctionId);
    }
    if (message.useMethodName !== "") {
      writer.uint32(58).string(message.useMethodName);
    }
    Object.entries(message.methodDefinitions).forEach(([key, value]) => {
      FunctionPrecreateRequest_MethodDefinitionsEntry.encode({ key, value }, writer.uint32(66).fork()).join();
    });
    if (message.functionSchema !== void 0) {
      FunctionSchema.encode(message.functionSchema, writer.uint32(74).fork()).join();
    }
    writer.uint32(82).fork();
    for (const v of message.supportedInputFormats) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(90).fork();
    for (const v of message.supportedOutputFormats) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPrecreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.existingFunctionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.functionType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.webhookConfig = WebhookConfig.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.useFunctionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.useMethodName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          const entry8 = FunctionPrecreateRequest_MethodDefinitionsEntry.decode(reader, reader.uint32());
          if (entry8.value !== void 0) {
            message.methodDefinitions[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.functionSchema = FunctionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag === 80) {
            message.supportedInputFormats.push(reader.int32());
            continue;
          }
          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedInputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 11: {
          if (tag === 88) {
            message.supportedOutputFormats.push(reader.int32());
            continue;
          }
          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedOutputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      existingFunctionId: isSet3(object.existingFunctionId) ? globalThis.String(object.existingFunctionId) : "",
      functionType: isSet3(object.functionType) ? function_FunctionTypeFromJSON(object.functionType) : 0,
      webhookConfig: isSet3(object.webhookConfig) ? WebhookConfig.fromJSON(object.webhookConfig) : void 0,
      useFunctionId: isSet3(object.useFunctionId) ? globalThis.String(object.useFunctionId) : "",
      useMethodName: isSet3(object.useMethodName) ? globalThis.String(object.useMethodName) : "",
      methodDefinitions: isObject2(object.methodDefinitions) ? Object.entries(object.methodDefinitions).reduce((acc, [key, value]) => {
        acc[key] = MethodDefinition.fromJSON(value);
        return acc;
      }, {}) : {},
      functionSchema: isSet3(object.functionSchema) ? FunctionSchema.fromJSON(object.functionSchema) : void 0,
      supportedInputFormats: globalThis.Array.isArray(object?.supportedInputFormats) ? object.supportedInputFormats.map((e) => dataFormatFromJSON(e)) : [],
      supportedOutputFormats: globalThis.Array.isArray(object?.supportedOutputFormats) ? object.supportedOutputFormats.map((e) => dataFormatFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.existingFunctionId !== "") {
      obj.existingFunctionId = message.existingFunctionId;
    }
    if (message.functionType !== 0) {
      obj.functionType = function_FunctionTypeToJSON(message.functionType);
    }
    if (message.webhookConfig !== void 0) {
      obj.webhookConfig = WebhookConfig.toJSON(message.webhookConfig);
    }
    if (message.useFunctionId !== "") {
      obj.useFunctionId = message.useFunctionId;
    }
    if (message.useMethodName !== "") {
      obj.useMethodName = message.useMethodName;
    }
    if (message.methodDefinitions) {
      const entries = Object.entries(message.methodDefinitions);
      if (entries.length > 0) {
        obj.methodDefinitions = {};
        entries.forEach(([k, v]) => {
          obj.methodDefinitions[k] = MethodDefinition.toJSON(v);
        });
      }
    }
    if (message.functionSchema !== void 0) {
      obj.functionSchema = FunctionSchema.toJSON(message.functionSchema);
    }
    if (message.supportedInputFormats?.length) {
      obj.supportedInputFormats = message.supportedInputFormats.map((e) => dataFormatToJSON(e));
    }
    if (message.supportedOutputFormats?.length) {
      obj.supportedOutputFormats = message.supportedOutputFormats.map((e) => dataFormatToJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionPrecreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPrecreateRequest();
    message.appId = object.appId ?? "";
    message.functionName = object.functionName ?? "";
    message.existingFunctionId = object.existingFunctionId ?? "";
    message.functionType = object.functionType ?? 0;
    message.webhookConfig = object.webhookConfig !== void 0 && object.webhookConfig !== null ? WebhookConfig.fromPartial(object.webhookConfig) : void 0;
    message.useFunctionId = object.useFunctionId ?? "";
    message.useMethodName = object.useMethodName ?? "";
    message.methodDefinitions = Object.entries(object.methodDefinitions ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = MethodDefinition.fromPartial(value);
      }
      return acc;
    }, {});
    message.functionSchema = object.functionSchema !== void 0 && object.functionSchema !== null ? FunctionSchema.fromPartial(object.functionSchema) : void 0;
    message.supportedInputFormats = object.supportedInputFormats?.map((e) => e) || [];
    message.supportedOutputFormats = object.supportedOutputFormats?.map((e) => e) || [];
    return message;
  }
};
function createBaseFunctionPrecreateRequest_MethodDefinitionsEntry() {
  return { key: "", value: void 0 };
}
var FunctionPrecreateRequest_MethodDefinitionsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      MethodDefinition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPrecreateRequest_MethodDefinitionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = MethodDefinition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? MethodDefinition.fromJSON(object.value) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== void 0) {
      obj.value = MethodDefinition.toJSON(message.value);
    }
    return obj;
  },
  create(base) {
    return FunctionPrecreateRequest_MethodDefinitionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPrecreateRequest_MethodDefinitionsEntry();
    message.key = object.key ?? "";
    message.value = object.value !== void 0 && object.value !== null ? MethodDefinition.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseFunctionPrecreateResponse() {
  return { functionId: "", handleMetadata: void 0 };
}
var FunctionPrecreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.handleMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.handleMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPrecreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.handleMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      handleMetadata: isSet3(object.handleMetadata) ? FunctionHandleMetadata.fromJSON(object.handleMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = FunctionHandleMetadata.toJSON(message.handleMetadata);
    }
    return obj;
  },
  create(base) {
    return FunctionPrecreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPrecreateResponse();
    message.functionId = object.functionId ?? "";
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? FunctionHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    return message;
  }
};
function createBaseFunctionPutInputsItem() {
  return { idx: 0, input: void 0, r2Failed: false, r2ThroughputBytesS: 0 };
}
var FunctionPutInputsItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.idx !== 0) {
      writer.uint32(8).int32(message.idx);
    }
    if (message.input !== void 0) {
      FunctionInput.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.r2Failed !== false) {
      writer.uint32(24).bool(message.r2Failed);
    }
    if (message.r2ThroughputBytesS !== 0) {
      writer.uint32(40).uint64(message.r2ThroughputBytesS);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPutInputsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.idx = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.input = FunctionInput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.r2Failed = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.r2ThroughputBytesS = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      idx: isSet3(object.idx) ? globalThis.Number(object.idx) : 0,
      input: isSet3(object.input) ? FunctionInput.fromJSON(object.input) : void 0,
      r2Failed: isSet3(object.r2Failed) ? globalThis.Boolean(object.r2Failed) : false,
      r2ThroughputBytesS: isSet3(object.r2ThroughputBytesS) ? globalThis.Number(object.r2ThroughputBytesS) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.idx !== 0) {
      obj.idx = Math.round(message.idx);
    }
    if (message.input !== void 0) {
      obj.input = FunctionInput.toJSON(message.input);
    }
    if (message.r2Failed !== false) {
      obj.r2Failed = message.r2Failed;
    }
    if (message.r2ThroughputBytesS !== 0) {
      obj.r2ThroughputBytesS = Math.round(message.r2ThroughputBytesS);
    }
    return obj;
  },
  create(base) {
    return FunctionPutInputsItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPutInputsItem();
    message.idx = object.idx ?? 0;
    message.input = object.input !== void 0 && object.input !== null ? FunctionInput.fromPartial(object.input) : void 0;
    message.r2Failed = object.r2Failed ?? false;
    message.r2ThroughputBytesS = object.r2ThroughputBytesS ?? 0;
    return message;
  }
};
function createBaseFunctionPutInputsRequest() {
  return { functionId: "", functionCallId: "", inputs: [] };
}
var FunctionPutInputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.functionCallId !== "") {
      writer.uint32(26).string(message.functionCallId);
    }
    for (const v of message.inputs) {
      FunctionPutInputsItem.encode(v, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPutInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.inputs.push(FunctionPutInputsItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e) => FunctionPutInputsItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => FunctionPutInputsItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionPutInputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPutInputsRequest();
    message.functionId = object.functionId ?? "";
    message.functionCallId = object.functionCallId ?? "";
    message.inputs = object.inputs?.map((e) => FunctionPutInputsItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionPutInputsResponse() {
  return { inputs: [] };
}
var FunctionPutInputsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.inputs) {
      FunctionPutInputsResponseItem.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPutInputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputs.push(FunctionPutInputsResponseItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e) => FunctionPutInputsResponseItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => FunctionPutInputsResponseItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionPutInputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPutInputsResponse();
    message.inputs = object.inputs?.map((e) => FunctionPutInputsResponseItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionPutInputsResponseItem() {
  return { idx: 0, inputId: "", inputJwt: "" };
}
var FunctionPutInputsResponseItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.idx !== 0) {
      writer.uint32(8).int32(message.idx);
    }
    if (message.inputId !== "") {
      writer.uint32(18).string(message.inputId);
    }
    if (message.inputJwt !== "") {
      writer.uint32(26).string(message.inputJwt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPutInputsResponseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.idx = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.inputJwt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      idx: isSet3(object.idx) ? globalThis.Number(object.idx) : 0,
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      inputJwt: isSet3(object.inputJwt) ? globalThis.String(object.inputJwt) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.idx !== 0) {
      obj.idx = Math.round(message.idx);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.inputJwt !== "") {
      obj.inputJwt = message.inputJwt;
    }
    return obj;
  },
  create(base) {
    return FunctionPutInputsResponseItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPutInputsResponseItem();
    message.idx = object.idx ?? 0;
    message.inputId = object.inputId ?? "";
    message.inputJwt = object.inputJwt ?? "";
    return message;
  }
};
function createBaseFunctionPutOutputsItem() {
  return {
    inputId: "",
    result: void 0,
    inputStartedAt: 0,
    outputCreatedAt: 0,
    dataFormat: 0,
    retryCount: 0,
    functionCallId: "",
    functionMapIdx: void 0
  };
}
var FunctionPutOutputsItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.inputId !== "") {
      writer.uint32(10).string(message.inputId);
    }
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.inputStartedAt !== 0) {
      writer.uint32(25).double(message.inputStartedAt);
    }
    if (message.outputCreatedAt !== 0) {
      writer.uint32(33).double(message.outputCreatedAt);
    }
    if (message.dataFormat !== 0) {
      writer.uint32(56).int32(message.dataFormat);
    }
    if (message.retryCount !== 0) {
      writer.uint32(64).uint32(message.retryCount);
    }
    if (message.functionCallId !== "") {
      writer.uint32(74).string(message.functionCallId);
    }
    if (message.functionMapIdx !== void 0) {
      writer.uint32(80).int32(message.functionMapIdx);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPutOutputsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.inputStartedAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }
          message.outputCreatedAt = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.dataFormat = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.retryCount = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.functionMapIdx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      inputStartedAt: isSet3(object.inputStartedAt) ? globalThis.Number(object.inputStartedAt) : 0,
      outputCreatedAt: isSet3(object.outputCreatedAt) ? globalThis.Number(object.outputCreatedAt) : 0,
      dataFormat: isSet3(object.dataFormat) ? dataFormatFromJSON(object.dataFormat) : 0,
      retryCount: isSet3(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      functionMapIdx: isSet3(object.functionMapIdx) ? globalThis.Number(object.functionMapIdx) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.inputStartedAt !== 0) {
      obj.inputStartedAt = message.inputStartedAt;
    }
    if (message.outputCreatedAt !== 0) {
      obj.outputCreatedAt = message.outputCreatedAt;
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = dataFormatToJSON(message.dataFormat);
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.functionMapIdx !== void 0) {
      obj.functionMapIdx = Math.round(message.functionMapIdx);
    }
    return obj;
  },
  create(base) {
    return FunctionPutOutputsItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPutOutputsItem();
    message.inputId = object.inputId ?? "";
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.inputStartedAt = object.inputStartedAt ?? 0;
    message.outputCreatedAt = object.outputCreatedAt ?? 0;
    message.dataFormat = object.dataFormat ?? 0;
    message.retryCount = object.retryCount ?? 0;
    message.functionCallId = object.functionCallId ?? "";
    message.functionMapIdx = object.functionMapIdx ?? void 0;
    return message;
  }
};
function createBaseFunctionPutOutputsRequest() {
  return { outputs: [], requestedAt: 0 };
}
var FunctionPutOutputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.outputs) {
      FunctionPutOutputsItem.encode(v, writer.uint32(34).fork()).join();
    }
    if (message.requestedAt !== 0) {
      writer.uint32(41).double(message.requestedAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionPutOutputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.outputs.push(FunctionPutOutputsItem.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }
          message.requestedAt = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e) => FunctionPutOutputsItem.fromJSON(e)) : [],
      requestedAt: isSet3(object.requestedAt) ? globalThis.Number(object.requestedAt) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => FunctionPutOutputsItem.toJSON(e));
    }
    if (message.requestedAt !== 0) {
      obj.requestedAt = message.requestedAt;
    }
    return obj;
  },
  create(base) {
    return FunctionPutOutputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionPutOutputsRequest();
    message.outputs = object.outputs?.map((e) => FunctionPutOutputsItem.fromPartial(e)) || [];
    message.requestedAt = object.requestedAt ?? 0;
    return message;
  }
};
function createBaseFunctionRetryInputsItem() {
  return { inputJwt: "", input: void 0, retryCount: 0 };
}
var FunctionRetryInputsItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.inputJwt !== "") {
      writer.uint32(10).string(message.inputJwt);
    }
    if (message.input !== void 0) {
      FunctionInput.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.retryCount !== 0) {
      writer.uint32(24).uint32(message.retryCount);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionRetryInputsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputJwt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.input = FunctionInput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.retryCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputJwt: isSet3(object.inputJwt) ? globalThis.String(object.inputJwt) : "",
      input: isSet3(object.input) ? FunctionInput.fromJSON(object.input) : void 0,
      retryCount: isSet3(object.retryCount) ? globalThis.Number(object.retryCount) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputJwt !== "") {
      obj.inputJwt = message.inputJwt;
    }
    if (message.input !== void 0) {
      obj.input = FunctionInput.toJSON(message.input);
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    return obj;
  },
  create(base) {
    return FunctionRetryInputsItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionRetryInputsItem();
    message.inputJwt = object.inputJwt ?? "";
    message.input = object.input !== void 0 && object.input !== null ? FunctionInput.fromPartial(object.input) : void 0;
    message.retryCount = object.retryCount ?? 0;
    return message;
  }
};
function createBaseFunctionRetryInputsRequest() {
  return { functionCallJwt: "", inputs: [] };
}
var FunctionRetryInputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallJwt !== "") {
      writer.uint32(10).string(message.functionCallJwt);
    }
    for (const v of message.inputs) {
      FunctionRetryInputsItem.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionRetryInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallJwt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.inputs.push(FunctionRetryInputsItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallJwt: isSet3(object.functionCallJwt) ? globalThis.String(object.functionCallJwt) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e) => FunctionRetryInputsItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallJwt !== "") {
      obj.functionCallJwt = message.functionCallJwt;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => FunctionRetryInputsItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return FunctionRetryInputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionRetryInputsRequest();
    message.functionCallJwt = object.functionCallJwt ?? "";
    message.inputs = object.inputs?.map((e) => FunctionRetryInputsItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFunctionRetryInputsResponse() {
  return { inputJwts: [] };
}
var FunctionRetryInputsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.inputJwts) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionRetryInputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputJwts.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputJwts: globalThis.Array.isArray(object?.inputJwts) ? object.inputJwts.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputJwts?.length) {
      obj.inputJwts = message.inputJwts;
    }
    return obj;
  },
  create(base) {
    return FunctionRetryInputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionRetryInputsResponse();
    message.inputJwts = object.inputJwts?.map((e) => e) || [];
    return message;
  }
};
function createBaseFunctionRetryPolicy() {
  return { backoffCoefficient: 0, initialDelayMs: 0, maxDelayMs: 0, retries: 0 };
}
var FunctionRetryPolicy = {
  encode(message, writer = new BinaryWriter()) {
    if (message.backoffCoefficient !== 0) {
      writer.uint32(13).float(message.backoffCoefficient);
    }
    if (message.initialDelayMs !== 0) {
      writer.uint32(16).uint32(message.initialDelayMs);
    }
    if (message.maxDelayMs !== 0) {
      writer.uint32(24).uint32(message.maxDelayMs);
    }
    if (message.retries !== 0) {
      writer.uint32(144).uint32(message.retries);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.backoffCoefficient = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.initialDelayMs = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxDelayMs = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }
          message.retries = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      backoffCoefficient: isSet3(object.backoffCoefficient) ? globalThis.Number(object.backoffCoefficient) : 0,
      initialDelayMs: isSet3(object.initialDelayMs) ? globalThis.Number(object.initialDelayMs) : 0,
      maxDelayMs: isSet3(object.maxDelayMs) ? globalThis.Number(object.maxDelayMs) : 0,
      retries: isSet3(object.retries) ? globalThis.Number(object.retries) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.backoffCoefficient !== 0) {
      obj.backoffCoefficient = message.backoffCoefficient;
    }
    if (message.initialDelayMs !== 0) {
      obj.initialDelayMs = Math.round(message.initialDelayMs);
    }
    if (message.maxDelayMs !== 0) {
      obj.maxDelayMs = Math.round(message.maxDelayMs);
    }
    if (message.retries !== 0) {
      obj.retries = Math.round(message.retries);
    }
    return obj;
  },
  create(base) {
    return FunctionRetryPolicy.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionRetryPolicy();
    message.backoffCoefficient = object.backoffCoefficient ?? 0;
    message.initialDelayMs = object.initialDelayMs ?? 0;
    message.maxDelayMs = object.maxDelayMs ?? 0;
    message.retries = object.retries ?? 0;
    return message;
  }
};
function createBaseFunctionSchema() {
  return { schemaType: 0, arguments: [], returnType: void 0 };
}
var FunctionSchema = {
  encode(message, writer = new BinaryWriter()) {
    if (message.schemaType !== 0) {
      writer.uint32(8).int32(message.schemaType);
    }
    for (const v of message.arguments) {
      ClassParameterSpec.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.returnType !== void 0) {
      GenericPayloadType.encode(message.returnType, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.schemaType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.arguments.push(ClassParameterSpec.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.returnType = GenericPayloadType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      schemaType: isSet3(object.schemaType) ? functionSchema_FunctionSchemaTypeFromJSON(object.schemaType) : 0,
      arguments: globalThis.Array.isArray(object?.arguments) ? object.arguments.map((e) => ClassParameterSpec.fromJSON(e)) : [],
      returnType: isSet3(object.returnType) ? GenericPayloadType.fromJSON(object.returnType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.schemaType !== 0) {
      obj.schemaType = functionSchema_FunctionSchemaTypeToJSON(message.schemaType);
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments.map((e) => ClassParameterSpec.toJSON(e));
    }
    if (message.returnType !== void 0) {
      obj.returnType = GenericPayloadType.toJSON(message.returnType);
    }
    return obj;
  },
  create(base) {
    return FunctionSchema.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionSchema();
    message.schemaType = object.schemaType ?? 0;
    message.arguments = object.arguments?.map((e) => ClassParameterSpec.fromPartial(e)) || [];
    message.returnType = object.returnType !== void 0 && object.returnType !== null ? GenericPayloadType.fromPartial(object.returnType) : void 0;
    return message;
  }
};
function createBaseFunctionStats() {
  return { backlog: 0, numTotalTasks: 0 };
}
var FunctionStats = {
  encode(message, writer = new BinaryWriter()) {
    if (message.backlog !== 0) {
      writer.uint32(8).uint32(message.backlog);
    }
    if (message.numTotalTasks !== 0) {
      writer.uint32(24).uint32(message.numTotalTasks);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.backlog = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.numTotalTasks = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      backlog: isSet3(object.backlog) ? globalThis.Number(object.backlog) : 0,
      numTotalTasks: isSet3(object.numTotalTasks) ? globalThis.Number(object.numTotalTasks) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.backlog !== 0) {
      obj.backlog = Math.round(message.backlog);
    }
    if (message.numTotalTasks !== 0) {
      obj.numTotalTasks = Math.round(message.numTotalTasks);
    }
    return obj;
  },
  create(base) {
    return FunctionStats.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionStats();
    message.backlog = object.backlog ?? 0;
    message.numTotalTasks = object.numTotalTasks ?? 0;
    return message;
  }
};
function createBaseFunctionUpdateSchedulingParamsRequest() {
  return { functionId: "", warmPoolSizeOverride: 0, settings: void 0 };
}
var FunctionUpdateSchedulingParamsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.warmPoolSizeOverride !== 0) {
      writer.uint32(16).uint32(message.warmPoolSizeOverride);
    }
    if (message.settings !== void 0) {
      AutoscalerSettings.encode(message.settings, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionUpdateSchedulingParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.warmPoolSizeOverride = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.settings = AutoscalerSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      warmPoolSizeOverride: isSet3(object.warmPoolSizeOverride) ? globalThis.Number(object.warmPoolSizeOverride) : 0,
      settings: isSet3(object.settings) ? AutoscalerSettings.fromJSON(object.settings) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.warmPoolSizeOverride !== 0) {
      obj.warmPoolSizeOverride = Math.round(message.warmPoolSizeOverride);
    }
    if (message.settings !== void 0) {
      obj.settings = AutoscalerSettings.toJSON(message.settings);
    }
    return obj;
  },
  create(base) {
    return FunctionUpdateSchedulingParamsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseFunctionUpdateSchedulingParamsRequest();
    message.functionId = object.functionId ?? "";
    message.warmPoolSizeOverride = object.warmPoolSizeOverride ?? 0;
    message.settings = object.settings !== void 0 && object.settings !== null ? AutoscalerSettings.fromPartial(object.settings) : void 0;
    return message;
  }
};
function createBaseFunctionUpdateSchedulingParamsResponse() {
  return {};
}
var FunctionUpdateSchedulingParamsResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFunctionUpdateSchedulingParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return FunctionUpdateSchedulingParamsResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseFunctionUpdateSchedulingParamsResponse();
    return message;
  }
};
function createBaseGPUConfig() {
  return { type: 0, count: 0, gpuType: "" };
}
var GPUConfig = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    if (message.gpuType !== "") {
      writer.uint32(34).string(message.gpuType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGPUConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.count = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.gpuType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet3(object.type) ? gPUTypeFromJSON(object.type) : 0,
      count: isSet3(object.count) ? globalThis.Number(object.count) : 0,
      gpuType: isSet3(object.gpuType) ? globalThis.String(object.gpuType) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = gPUTypeToJSON(message.type);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.gpuType !== "") {
      obj.gpuType = message.gpuType;
    }
    return obj;
  },
  create(base) {
    return GPUConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGPUConfig();
    message.type = object.type ?? 0;
    message.count = object.count ?? 0;
    message.gpuType = object.gpuType ?? "";
    return message;
  }
};
function createBaseGeneratorDone() {
  return { itemsTotal: 0 };
}
var GeneratorDone = {
  encode(message, writer = new BinaryWriter()) {
    if (message.itemsTotal !== 0) {
      writer.uint32(8).uint64(message.itemsTotal);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeneratorDone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.itemsTotal = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { itemsTotal: isSet3(object.itemsTotal) ? globalThis.Number(object.itemsTotal) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.itemsTotal !== 0) {
      obj.itemsTotal = Math.round(message.itemsTotal);
    }
    return obj;
  },
  create(base) {
    return GeneratorDone.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGeneratorDone();
    message.itemsTotal = object.itemsTotal ?? 0;
    return message;
  }
};
function createBaseGenericPayloadType() {
  return { baseType: 0, subTypes: [] };
}
var GenericPayloadType = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseType !== 0) {
      writer.uint32(8).int32(message.baseType);
    }
    for (const v of message.subTypes) {
      GenericPayloadType.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericPayloadType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.baseType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.subTypes.push(GenericPayloadType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      baseType: isSet3(object.baseType) ? parameterTypeFromJSON(object.baseType) : 0,
      subTypes: globalThis.Array.isArray(object?.subTypes) ? object.subTypes.map((e) => GenericPayloadType.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.baseType !== 0) {
      obj.baseType = parameterTypeToJSON(message.baseType);
    }
    if (message.subTypes?.length) {
      obj.subTypes = message.subTypes.map((e) => GenericPayloadType.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return GenericPayloadType.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGenericPayloadType();
    message.baseType = object.baseType ?? 0;
    message.subTypes = object.subTypes?.map((e) => GenericPayloadType.fromPartial(e)) || [];
    return message;
  }
};
function createBaseGenericResult() {
  return {
    status: 0,
    exception: "",
    exitcode: 0,
    traceback: "",
    serializedTb: new Uint8Array(0),
    tbLineCache: new Uint8Array(0),
    data: void 0,
    dataBlobId: void 0,
    propagationReason: ""
  };
}
var GenericResult = {
  encode(message, writer = new BinaryWriter()) {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.exception !== "") {
      writer.uint32(18).string(message.exception);
    }
    if (message.exitcode !== 0) {
      writer.uint32(24).int32(message.exitcode);
    }
    if (message.traceback !== "") {
      writer.uint32(34).string(message.traceback);
    }
    if (message.serializedTb.length !== 0) {
      writer.uint32(90).bytes(message.serializedTb);
    }
    if (message.tbLineCache.length !== 0) {
      writer.uint32(98).bytes(message.tbLineCache);
    }
    if (message.data !== void 0) {
      writer.uint32(42).bytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      writer.uint32(82).string(message.dataBlobId);
    }
    if (message.propagationReason !== "") {
      writer.uint32(106).string(message.propagationReason);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGenericResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.exception = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.exitcode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.traceback = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.serializedTb = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.tbLineCache = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.dataBlobId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.propagationReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      status: isSet3(object.status) ? genericResult_GenericStatusFromJSON(object.status) : 0,
      exception: isSet3(object.exception) ? globalThis.String(object.exception) : "",
      exitcode: isSet3(object.exitcode) ? globalThis.Number(object.exitcode) : 0,
      traceback: isSet3(object.traceback) ? globalThis.String(object.traceback) : "",
      serializedTb: isSet3(object.serializedTb) ? bytesFromBase64(object.serializedTb) : new Uint8Array(0),
      tbLineCache: isSet3(object.tbLineCache) ? bytesFromBase64(object.tbLineCache) : new Uint8Array(0),
      data: isSet3(object.data) ? bytesFromBase64(object.data) : void 0,
      dataBlobId: isSet3(object.dataBlobId) ? globalThis.String(object.dataBlobId) : void 0,
      propagationReason: isSet3(object.propagationReason) ? globalThis.String(object.propagationReason) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.status !== 0) {
      obj.status = genericResult_GenericStatusToJSON(message.status);
    }
    if (message.exception !== "") {
      obj.exception = message.exception;
    }
    if (message.exitcode !== 0) {
      obj.exitcode = Math.round(message.exitcode);
    }
    if (message.traceback !== "") {
      obj.traceback = message.traceback;
    }
    if (message.serializedTb.length !== 0) {
      obj.serializedTb = base64FromBytes(message.serializedTb);
    }
    if (message.tbLineCache.length !== 0) {
      obj.tbLineCache = base64FromBytes(message.tbLineCache);
    }
    if (message.data !== void 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      obj.dataBlobId = message.dataBlobId;
    }
    if (message.propagationReason !== "") {
      obj.propagationReason = message.propagationReason;
    }
    return obj;
  },
  create(base) {
    return GenericResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGenericResult();
    message.status = object.status ?? 0;
    message.exception = object.exception ?? "";
    message.exitcode = object.exitcode ?? 0;
    message.traceback = object.traceback ?? "";
    message.serializedTb = object.serializedTb ?? new Uint8Array(0);
    message.tbLineCache = object.tbLineCache ?? new Uint8Array(0);
    message.data = object.data ?? void 0;
    message.dataBlobId = object.dataBlobId ?? void 0;
    message.propagationReason = object.propagationReason ?? "";
    return message;
  }
};
function createBaseImage() {
  return {
    baseImages: [],
    dockerfileCommands: [],
    contextFiles: [],
    version: "",
    secretIds: [],
    contextMountId: "",
    gpuConfig: void 0,
    imageRegistryConfig: void 0,
    buildFunctionDef: "",
    buildFunctionGlobals: new Uint8Array(0),
    runtime: "",
    runtimeDebug: false,
    buildFunction: void 0,
    buildArgs: {}
  };
}
var Image = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.baseImages) {
      BaseImage.encode(v, writer.uint32(42).fork()).join();
    }
    for (const v of message.dockerfileCommands) {
      writer.uint32(50).string(v);
    }
    for (const v of message.contextFiles) {
      ImageContextFile.encode(v, writer.uint32(58).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(90).string(message.version);
    }
    for (const v of message.secretIds) {
      writer.uint32(98).string(v);
    }
    if (message.contextMountId !== "") {
      writer.uint32(122).string(message.contextMountId);
    }
    if (message.gpuConfig !== void 0) {
      GPUConfig.encode(message.gpuConfig, writer.uint32(130).fork()).join();
    }
    if (message.imageRegistryConfig !== void 0) {
      ImageRegistryConfig.encode(message.imageRegistryConfig, writer.uint32(138).fork()).join();
    }
    if (message.buildFunctionDef !== "") {
      writer.uint32(114).string(message.buildFunctionDef);
    }
    if (message.buildFunctionGlobals.length !== 0) {
      writer.uint32(146).bytes(message.buildFunctionGlobals);
    }
    if (message.runtime !== "") {
      writer.uint32(154).string(message.runtime);
    }
    if (message.runtimeDebug !== false) {
      writer.uint32(160).bool(message.runtimeDebug);
    }
    if (message.buildFunction !== void 0) {
      BuildFunction.encode(message.buildFunction, writer.uint32(170).fork()).join();
    }
    Object.entries(message.buildArgs).forEach(([key, value]) => {
      Image_BuildArgsEntry.encode({ key, value }, writer.uint32(178).fork()).join();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.baseImages.push(BaseImage.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.dockerfileCommands.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.contextFiles.push(ImageContextFile.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.version = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.secretIds.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.contextMountId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.gpuConfig = GPUConfig.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.imageRegistryConfig = ImageRegistryConfig.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.buildFunctionDef = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.buildFunctionGlobals = reader.bytes();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }
          message.runtime = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }
          message.runtimeDebug = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }
          message.buildFunction = BuildFunction.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }
          const entry22 = Image_BuildArgsEntry.decode(reader, reader.uint32());
          if (entry22.value !== void 0) {
            message.buildArgs[entry22.key] = entry22.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      baseImages: globalThis.Array.isArray(object?.baseImages) ? object.baseImages.map((e) => BaseImage.fromJSON(e)) : [],
      dockerfileCommands: globalThis.Array.isArray(object?.dockerfileCommands) ? object.dockerfileCommands.map((e) => globalThis.String(e)) : [],
      contextFiles: globalThis.Array.isArray(object?.contextFiles) ? object.contextFiles.map((e) => ImageContextFile.fromJSON(e)) : [],
      version: isSet3(object.version) ? globalThis.String(object.version) : "",
      secretIds: globalThis.Array.isArray(object?.secretIds) ? object.secretIds.map((e) => globalThis.String(e)) : [],
      contextMountId: isSet3(object.contextMountId) ? globalThis.String(object.contextMountId) : "",
      gpuConfig: isSet3(object.gpuConfig) ? GPUConfig.fromJSON(object.gpuConfig) : void 0,
      imageRegistryConfig: isSet3(object.imageRegistryConfig) ? ImageRegistryConfig.fromJSON(object.imageRegistryConfig) : void 0,
      buildFunctionDef: isSet3(object.buildFunctionDef) ? globalThis.String(object.buildFunctionDef) : "",
      buildFunctionGlobals: isSet3(object.buildFunctionGlobals) ? bytesFromBase64(object.buildFunctionGlobals) : new Uint8Array(0),
      runtime: isSet3(object.runtime) ? globalThis.String(object.runtime) : "",
      runtimeDebug: isSet3(object.runtimeDebug) ? globalThis.Boolean(object.runtimeDebug) : false,
      buildFunction: isSet3(object.buildFunction) ? BuildFunction.fromJSON(object.buildFunction) : void 0,
      buildArgs: isObject2(object.buildArgs) ? Object.entries(object.buildArgs).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {}
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.baseImages?.length) {
      obj.baseImages = message.baseImages.map((e) => BaseImage.toJSON(e));
    }
    if (message.dockerfileCommands?.length) {
      obj.dockerfileCommands = message.dockerfileCommands;
    }
    if (message.contextFiles?.length) {
      obj.contextFiles = message.contextFiles.map((e) => ImageContextFile.toJSON(e));
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.secretIds?.length) {
      obj.secretIds = message.secretIds;
    }
    if (message.contextMountId !== "") {
      obj.contextMountId = message.contextMountId;
    }
    if (message.gpuConfig !== void 0) {
      obj.gpuConfig = GPUConfig.toJSON(message.gpuConfig);
    }
    if (message.imageRegistryConfig !== void 0) {
      obj.imageRegistryConfig = ImageRegistryConfig.toJSON(message.imageRegistryConfig);
    }
    if (message.buildFunctionDef !== "") {
      obj.buildFunctionDef = message.buildFunctionDef;
    }
    if (message.buildFunctionGlobals.length !== 0) {
      obj.buildFunctionGlobals = base64FromBytes(message.buildFunctionGlobals);
    }
    if (message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.runtimeDebug !== false) {
      obj.runtimeDebug = message.runtimeDebug;
    }
    if (message.buildFunction !== void 0) {
      obj.buildFunction = BuildFunction.toJSON(message.buildFunction);
    }
    if (message.buildArgs) {
      const entries = Object.entries(message.buildArgs);
      if (entries.length > 0) {
        obj.buildArgs = {};
        entries.forEach(([k, v]) => {
          obj.buildArgs[k] = v;
        });
      }
    }
    return obj;
  },
  create(base) {
    return Image.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImage();
    message.baseImages = object.baseImages?.map((e) => BaseImage.fromPartial(e)) || [];
    message.dockerfileCommands = object.dockerfileCommands?.map((e) => e) || [];
    message.contextFiles = object.contextFiles?.map((e) => ImageContextFile.fromPartial(e)) || [];
    message.version = object.version ?? "";
    message.secretIds = object.secretIds?.map((e) => e) || [];
    message.contextMountId = object.contextMountId ?? "";
    message.gpuConfig = object.gpuConfig !== void 0 && object.gpuConfig !== null ? GPUConfig.fromPartial(object.gpuConfig) : void 0;
    message.imageRegistryConfig = object.imageRegistryConfig !== void 0 && object.imageRegistryConfig !== null ? ImageRegistryConfig.fromPartial(object.imageRegistryConfig) : void 0;
    message.buildFunctionDef = object.buildFunctionDef ?? "";
    message.buildFunctionGlobals = object.buildFunctionGlobals ?? new Uint8Array(0);
    message.runtime = object.runtime ?? "";
    message.runtimeDebug = object.runtimeDebug ?? false;
    message.buildFunction = object.buildFunction !== void 0 && object.buildFunction !== null ? BuildFunction.fromPartial(object.buildFunction) : void 0;
    message.buildArgs = Object.entries(object.buildArgs ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    return message;
  }
};
function createBaseImage_BuildArgsEntry() {
  return { key: "", value: "" };
}
var Image_BuildArgsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImage_BuildArgsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Image_BuildArgsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImage_BuildArgsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseImageContextFile() {
  return { filename: "", data: new Uint8Array(0) };
}
var ImageContextFile = {
  encode(message, writer = new BinaryWriter()) {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageContextFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filename: isSet3(object.filename) ? globalThis.String(object.filename) : "",
      data: isSet3(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },
  create(base) {
    return ImageContextFile.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageContextFile();
    message.filename = object.filename ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  }
};
function createBaseImageDeleteRequest() {
  return { imageId: "" };
}
var ImageDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    return obj;
  },
  create(base) {
    return ImageDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageDeleteRequest();
    message.imageId = object.imageId ?? "";
    return message;
  }
};
function createBaseImageFromIdRequest() {
  return { imageId: "" };
}
var ImageFromIdRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageFromIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    return obj;
  },
  create(base) {
    return ImageFromIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageFromIdRequest();
    message.imageId = object.imageId ?? "";
    return message;
  }
};
function createBaseImageFromIdResponse() {
  return { imageId: "", metadata: void 0 };
}
var ImageFromIdResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    if (message.metadata !== void 0) {
      ImageMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageFromIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = ImageMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      metadata: isSet3(object.metadata) ? ImageMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = ImageMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return ImageFromIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageFromIdResponse();
    message.imageId = object.imageId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? ImageMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseImageGetOrCreateRequest() {
  return {
    image: void 0,
    appId: "",
    existingImageId: "",
    buildFunctionId: "",
    forceBuild: false,
    namespace: 0,
    builderVersion: "",
    allowGlobalDeployment: false,
    ignoreCache: false
  };
}
var ImageGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.image !== void 0) {
      Image.encode(message.image, writer.uint32(18).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(34).string(message.appId);
    }
    if (message.existingImageId !== "") {
      writer.uint32(42).string(message.existingImageId);
    }
    if (message.buildFunctionId !== "") {
      writer.uint32(50).string(message.buildFunctionId);
    }
    if (message.forceBuild !== false) {
      writer.uint32(56).bool(message.forceBuild);
    }
    if (message.namespace !== 0) {
      writer.uint32(64).int32(message.namespace);
    }
    if (message.builderVersion !== "") {
      writer.uint32(74).string(message.builderVersion);
    }
    if (message.allowGlobalDeployment !== false) {
      writer.uint32(80).bool(message.allowGlobalDeployment);
    }
    if (message.ignoreCache !== false) {
      writer.uint32(88).bool(message.ignoreCache);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.image = Image.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.existingImageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.buildFunctionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.forceBuild = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.namespace = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.builderVersion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.allowGlobalDeployment = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.ignoreCache = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      image: isSet3(object.image) ? Image.fromJSON(object.image) : void 0,
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      existingImageId: isSet3(object.existingImageId) ? globalThis.String(object.existingImageId) : "",
      buildFunctionId: isSet3(object.buildFunctionId) ? globalThis.String(object.buildFunctionId) : "",
      forceBuild: isSet3(object.forceBuild) ? globalThis.Boolean(object.forceBuild) : false,
      namespace: isSet3(object.namespace) ? deploymentNamespaceFromJSON(object.namespace) : 0,
      builderVersion: isSet3(object.builderVersion) ? globalThis.String(object.builderVersion) : "",
      allowGlobalDeployment: isSet3(object.allowGlobalDeployment) ? globalThis.Boolean(object.allowGlobalDeployment) : false,
      ignoreCache: isSet3(object.ignoreCache) ? globalThis.Boolean(object.ignoreCache) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.image !== void 0) {
      obj.image = Image.toJSON(message.image);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.existingImageId !== "") {
      obj.existingImageId = message.existingImageId;
    }
    if (message.buildFunctionId !== "") {
      obj.buildFunctionId = message.buildFunctionId;
    }
    if (message.forceBuild !== false) {
      obj.forceBuild = message.forceBuild;
    }
    if (message.namespace !== 0) {
      obj.namespace = deploymentNamespaceToJSON(message.namespace);
    }
    if (message.builderVersion !== "") {
      obj.builderVersion = message.builderVersion;
    }
    if (message.allowGlobalDeployment !== false) {
      obj.allowGlobalDeployment = message.allowGlobalDeployment;
    }
    if (message.ignoreCache !== false) {
      obj.ignoreCache = message.ignoreCache;
    }
    return obj;
  },
  create(base) {
    return ImageGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageGetOrCreateRequest();
    message.image = object.image !== void 0 && object.image !== null ? Image.fromPartial(object.image) : void 0;
    message.appId = object.appId ?? "";
    message.existingImageId = object.existingImageId ?? "";
    message.buildFunctionId = object.buildFunctionId ?? "";
    message.forceBuild = object.forceBuild ?? false;
    message.namespace = object.namespace ?? 0;
    message.builderVersion = object.builderVersion ?? "";
    message.allowGlobalDeployment = object.allowGlobalDeployment ?? false;
    message.ignoreCache = object.ignoreCache ?? false;
    return message;
  }
};
function createBaseImageGetOrCreateResponse() {
  return { imageId: "", result: void 0, metadata: void 0 };
}
var ImageGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== void 0) {
      ImageMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.metadata = ImageMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      metadata: isSet3(object.metadata) ? ImageMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.metadata !== void 0) {
      obj.metadata = ImageMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return ImageGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageGetOrCreateResponse();
    message.imageId = object.imageId ?? "";
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? ImageMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseImageJoinStreamingRequest() {
  return { imageId: "", timeout: 0, lastEntryId: "", includeLogsForFinished: false };
}
var ImageJoinStreamingRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    if (message.lastEntryId !== "") {
      writer.uint32(26).string(message.lastEntryId);
    }
    if (message.includeLogsForFinished !== false) {
      writer.uint32(32).bool(message.includeLogsForFinished);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageJoinStreamingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.includeLogsForFinished = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      includeLogsForFinished: isSet3(object.includeLogsForFinished) ? globalThis.Boolean(object.includeLogsForFinished) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.includeLogsForFinished !== false) {
      obj.includeLogsForFinished = message.includeLogsForFinished;
    }
    return obj;
  },
  create(base) {
    return ImageJoinStreamingRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageJoinStreamingRequest();
    message.imageId = object.imageId ?? "";
    message.timeout = object.timeout ?? 0;
    message.lastEntryId = object.lastEntryId ?? "";
    message.includeLogsForFinished = object.includeLogsForFinished ?? false;
    return message;
  }
};
function createBaseImageJoinStreamingResponse() {
  return { result: void 0, taskLogs: [], entryId: "", eof: false, metadata: void 0 };
}
var ImageJoinStreamingResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    for (const v of message.taskLogs) {
      TaskLogs.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.entryId !== "") {
      writer.uint32(26).string(message.entryId);
    }
    if (message.eof !== false) {
      writer.uint32(32).bool(message.eof);
    }
    if (message.metadata !== void 0) {
      ImageMetadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageJoinStreamingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.taskLogs.push(TaskLogs.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.entryId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.eof = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.metadata = ImageMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      taskLogs: globalThis.Array.isArray(object?.taskLogs) ? object.taskLogs.map((e) => TaskLogs.fromJSON(e)) : [],
      entryId: isSet3(object.entryId) ? globalThis.String(object.entryId) : "",
      eof: isSet3(object.eof) ? globalThis.Boolean(object.eof) : false,
      metadata: isSet3(object.metadata) ? ImageMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.taskLogs?.length) {
      obj.taskLogs = message.taskLogs.map((e) => TaskLogs.toJSON(e));
    }
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.eof !== false) {
      obj.eof = message.eof;
    }
    if (message.metadata !== void 0) {
      obj.metadata = ImageMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return ImageJoinStreamingResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageJoinStreamingResponse();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.taskLogs = object.taskLogs?.map((e) => TaskLogs.fromPartial(e)) || [];
    message.entryId = object.entryId ?? "";
    message.eof = object.eof ?? false;
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? ImageMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseImageMetadata() {
  return {
    pythonVersionInfo: void 0,
    pythonPackages: {},
    workdir: void 0,
    libcVersionInfo: void 0,
    imageBuilderVersion: void 0
  };
}
var ImageMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.pythonVersionInfo !== void 0) {
      writer.uint32(10).string(message.pythonVersionInfo);
    }
    Object.entries(message.pythonPackages).forEach(([key, value]) => {
      ImageMetadata_PythonPackagesEntry.encode({ key, value }, writer.uint32(18).fork()).join();
    });
    if (message.workdir !== void 0) {
      writer.uint32(26).string(message.workdir);
    }
    if (message.libcVersionInfo !== void 0) {
      writer.uint32(34).string(message.libcVersionInfo);
    }
    if (message.imageBuilderVersion !== void 0) {
      writer.uint32(42).string(message.imageBuilderVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.pythonVersionInfo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          const entry2 = ImageMetadata_PythonPackagesEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.pythonPackages[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.workdir = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.libcVersionInfo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.imageBuilderVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      pythonVersionInfo: isSet3(object.pythonVersionInfo) ? globalThis.String(object.pythonVersionInfo) : void 0,
      pythonPackages: isObject2(object.pythonPackages) ? Object.entries(object.pythonPackages).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      workdir: isSet3(object.workdir) ? globalThis.String(object.workdir) : void 0,
      libcVersionInfo: isSet3(object.libcVersionInfo) ? globalThis.String(object.libcVersionInfo) : void 0,
      imageBuilderVersion: isSet3(object.imageBuilderVersion) ? globalThis.String(object.imageBuilderVersion) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.pythonVersionInfo !== void 0) {
      obj.pythonVersionInfo = message.pythonVersionInfo;
    }
    if (message.pythonPackages) {
      const entries = Object.entries(message.pythonPackages);
      if (entries.length > 0) {
        obj.pythonPackages = {};
        entries.forEach(([k, v]) => {
          obj.pythonPackages[k] = v;
        });
      }
    }
    if (message.workdir !== void 0) {
      obj.workdir = message.workdir;
    }
    if (message.libcVersionInfo !== void 0) {
      obj.libcVersionInfo = message.libcVersionInfo;
    }
    if (message.imageBuilderVersion !== void 0) {
      obj.imageBuilderVersion = message.imageBuilderVersion;
    }
    return obj;
  },
  create(base) {
    return ImageMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageMetadata();
    message.pythonVersionInfo = object.pythonVersionInfo ?? void 0;
    message.pythonPackages = Object.entries(object.pythonPackages ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    message.workdir = object.workdir ?? void 0;
    message.libcVersionInfo = object.libcVersionInfo ?? void 0;
    message.imageBuilderVersion = object.imageBuilderVersion ?? void 0;
    return message;
  }
};
function createBaseImageMetadata_PythonPackagesEntry() {
  return { key: "", value: "" };
}
var ImageMetadata_PythonPackagesEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageMetadata_PythonPackagesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return ImageMetadata_PythonPackagesEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageMetadata_PythonPackagesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseImageRegistryConfig() {
  return { registryAuthType: 0, secretId: "" };
}
var ImageRegistryConfig = {
  encode(message, writer = new BinaryWriter()) {
    if (message.registryAuthType !== 0) {
      writer.uint32(8).int32(message.registryAuthType);
    }
    if (message.secretId !== "") {
      writer.uint32(18).string(message.secretId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageRegistryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.registryAuthType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.secretId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      registryAuthType: isSet3(object.registryAuthType) ? registryAuthTypeFromJSON(object.registryAuthType) : 0,
      secretId: isSet3(object.secretId) ? globalThis.String(object.secretId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.registryAuthType !== 0) {
      obj.registryAuthType = registryAuthTypeToJSON(message.registryAuthType);
    }
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    return obj;
  },
  create(base) {
    return ImageRegistryConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseImageRegistryConfig();
    message.registryAuthType = object.registryAuthType ?? 0;
    message.secretId = object.secretId ?? "";
    return message;
  }
};
function createBaseInputCallGraphInfo() {
  return { inputId: "", status: 0, functionCallId: "", taskId: "" };
}
var InputCallGraphInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.inputId !== "") {
      writer.uint32(10).string(message.inputId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.functionCallId !== "") {
      writer.uint32(26).string(message.functionCallId);
    }
    if (message.taskId !== "") {
      writer.uint32(34).string(message.taskId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInputCallGraphInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.status = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      status: isSet3(object.status) ? genericResult_GenericStatusFromJSON(object.status) : 0,
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.status !== 0) {
      obj.status = genericResult_GenericStatusToJSON(message.status);
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },
  create(base) {
    return InputCallGraphInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInputCallGraphInfo();
    message.inputId = object.inputId ?? "";
    message.status = object.status ?? 0;
    message.functionCallId = object.functionCallId ?? "";
    message.taskId = object.taskId ?? "";
    return message;
  }
};
function createBaseInputCategoryInfo() {
  return { total: 0, latest: [] };
}
var InputCategoryInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    for (const v of message.latest) {
      InputInfo.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInputCategoryInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.latest.push(InputInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      total: isSet3(object.total) ? globalThis.Number(object.total) : 0,
      latest: globalThis.Array.isArray(object?.latest) ? object.latest.map((e) => InputInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.latest?.length) {
      obj.latest = message.latest.map((e) => InputInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return InputCategoryInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInputCategoryInfo();
    message.total = object.total ?? 0;
    message.latest = object.latest?.map((e) => InputInfo.fromPartial(e)) || [];
    return message;
  }
};
function createBaseInputInfo() {
  return { inputId: "", idx: 0, taskId: "", startedAt: 0, finishedAt: 0, taskStartupTime: 0, taskFirstInput: false };
}
var InputInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.inputId !== "") {
      writer.uint32(10).string(message.inputId);
    }
    if (message.idx !== 0) {
      writer.uint32(16).int32(message.idx);
    }
    if (message.taskId !== "") {
      writer.uint32(26).string(message.taskId);
    }
    if (message.startedAt !== 0) {
      writer.uint32(33).double(message.startedAt);
    }
    if (message.finishedAt !== 0) {
      writer.uint32(41).double(message.finishedAt);
    }
    if (message.taskStartupTime !== 0) {
      writer.uint32(49).double(message.taskStartupTime);
    }
    if (message.taskFirstInput !== false) {
      writer.uint32(56).bool(message.taskFirstInput);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInputInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.idx = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }
          message.startedAt = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }
          message.finishedAt = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }
          message.taskStartupTime = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.taskFirstInput = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      idx: isSet3(object.idx) ? globalThis.Number(object.idx) : 0,
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      startedAt: isSet3(object.startedAt) ? globalThis.Number(object.startedAt) : 0,
      finishedAt: isSet3(object.finishedAt) ? globalThis.Number(object.finishedAt) : 0,
      taskStartupTime: isSet3(object.taskStartupTime) ? globalThis.Number(object.taskStartupTime) : 0,
      taskFirstInput: isSet3(object.taskFirstInput) ? globalThis.Boolean(object.taskFirstInput) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.idx !== 0) {
      obj.idx = Math.round(message.idx);
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.startedAt !== 0) {
      obj.startedAt = message.startedAt;
    }
    if (message.finishedAt !== 0) {
      obj.finishedAt = message.finishedAt;
    }
    if (message.taskStartupTime !== 0) {
      obj.taskStartupTime = message.taskStartupTime;
    }
    if (message.taskFirstInput !== false) {
      obj.taskFirstInput = message.taskFirstInput;
    }
    return obj;
  },
  create(base) {
    return InputInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseInputInfo();
    message.inputId = object.inputId ?? "";
    message.idx = object.idx ?? 0;
    message.taskId = object.taskId ?? "";
    message.startedAt = object.startedAt ?? 0;
    message.finishedAt = object.finishedAt ?? 0;
    message.taskStartupTime = object.taskStartupTime ?? 0;
    message.taskFirstInput = object.taskFirstInput ?? false;
    return message;
  }
};
function createBaseListPagination() {
  return { maxObjects: 0, createdBefore: 0 };
}
var ListPagination = {
  encode(message, writer = new BinaryWriter()) {
    if (message.maxObjects !== 0) {
      writer.uint32(8).int32(message.maxObjects);
    }
    if (message.createdBefore !== 0) {
      writer.uint32(17).double(message.createdBefore);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListPagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.maxObjects = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.createdBefore = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxObjects: isSet3(object.maxObjects) ? globalThis.Number(object.maxObjects) : 0,
      createdBefore: isSet3(object.createdBefore) ? globalThis.Number(object.createdBefore) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.maxObjects !== 0) {
      obj.maxObjects = Math.round(message.maxObjects);
    }
    if (message.createdBefore !== 0) {
      obj.createdBefore = message.createdBefore;
    }
    return obj;
  },
  create(base) {
    return ListPagination.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListPagination();
    message.maxObjects = object.maxObjects ?? 0;
    message.createdBefore = object.createdBefore ?? 0;
    return message;
  }
};
function createBaseMapAwaitRequest() {
  return { functionCallId: void 0, mapToken: void 0, lastEntryId: "", requestedAt: 0, timeout: 0 };
}
var MapAwaitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionCallId !== void 0) {
      writer.uint32(10).string(message.functionCallId);
    }
    if (message.mapToken !== void 0) {
      writer.uint32(42).string(message.mapToken);
    }
    if (message.lastEntryId !== "") {
      writer.uint32(18).string(message.lastEntryId);
    }
    if (message.requestedAt !== 0) {
      writer.uint32(25).double(message.requestedAt);
    }
    if (message.timeout !== 0) {
      writer.uint32(37).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapAwaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.mapToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.requestedAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : void 0,
      mapToken: isSet3(object.mapToken) ? globalThis.String(object.mapToken) : void 0,
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      requestedAt: isSet3(object.requestedAt) ? globalThis.Number(object.requestedAt) : 0,
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionCallId !== void 0) {
      obj.functionCallId = message.functionCallId;
    }
    if (message.mapToken !== void 0) {
      obj.mapToken = message.mapToken;
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.requestedAt !== 0) {
      obj.requestedAt = message.requestedAt;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return MapAwaitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapAwaitRequest();
    message.functionCallId = object.functionCallId ?? void 0;
    message.mapToken = object.mapToken ?? void 0;
    message.lastEntryId = object.lastEntryId ?? "";
    message.requestedAt = object.requestedAt ?? 0;
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseMapAwaitResponse() {
  return { outputs: [], lastEntryId: "" };
}
var MapAwaitResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.outputs) {
      FunctionGetOutputsItem.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.lastEntryId !== "") {
      writer.uint32(18).string(message.lastEntryId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapAwaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.outputs.push(FunctionGetOutputsItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e) => FunctionGetOutputsItem.fromJSON(e)) : [],
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => FunctionGetOutputsItem.toJSON(e));
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    return obj;
  },
  create(base) {
    return MapAwaitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapAwaitResponse();
    message.outputs = object.outputs?.map((e) => FunctionGetOutputsItem.fromPartial(e)) || [];
    message.lastEntryId = object.lastEntryId ?? "";
    return message;
  }
};
function createBaseMapCheckInputsRequest() {
  return { lastEntryId: "", timeout: 0, attemptTokens: [] };
}
var MapCheckInputsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.lastEntryId !== "") {
      writer.uint32(10).string(message.lastEntryId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    for (const v of message.attemptTokens) {
      writer.uint32(26).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapCheckInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.attemptTokens.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      attemptTokens: globalThis.Array.isArray(object?.attemptTokens) ? object.attemptTokens.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.attemptTokens?.length) {
      obj.attemptTokens = message.attemptTokens;
    }
    return obj;
  },
  create(base) {
    return MapCheckInputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapCheckInputsRequest();
    message.lastEntryId = object.lastEntryId ?? "";
    message.timeout = object.timeout ?? 0;
    message.attemptTokens = object.attemptTokens?.map((e) => e) || [];
    return message;
  }
};
function createBaseMapCheckInputsResponse() {
  return { lost: [] };
}
var MapCheckInputsResponse = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(10).fork();
    for (const v of message.lost) {
      writer.bool(v);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapCheckInputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.lost.push(reader.bool());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lost.push(reader.bool());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { lost: globalThis.Array.isArray(object?.lost) ? object.lost.map((e) => globalThis.Boolean(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.lost?.length) {
      obj.lost = message.lost;
    }
    return obj;
  },
  create(base) {
    return MapCheckInputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapCheckInputsResponse();
    message.lost = object.lost?.map((e) => e) || [];
    return message;
  }
};
function createBaseMapStartOrContinueItem() {
  return { input: void 0, attemptToken: void 0 };
}
var MapStartOrContinueItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.input !== void 0) {
      FunctionPutInputsItem.encode(message.input, writer.uint32(10).fork()).join();
    }
    if (message.attemptToken !== void 0) {
      writer.uint32(18).string(message.attemptToken);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapStartOrContinueItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.input = FunctionPutInputsItem.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.attemptToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      input: isSet3(object.input) ? FunctionPutInputsItem.fromJSON(object.input) : void 0,
      attemptToken: isSet3(object.attemptToken) ? globalThis.String(object.attemptToken) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.input !== void 0) {
      obj.input = FunctionPutInputsItem.toJSON(message.input);
    }
    if (message.attemptToken !== void 0) {
      obj.attemptToken = message.attemptToken;
    }
    return obj;
  },
  create(base) {
    return MapStartOrContinueItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapStartOrContinueItem();
    message.input = object.input !== void 0 && object.input !== null ? FunctionPutInputsItem.fromPartial(object.input) : void 0;
    message.attemptToken = object.attemptToken ?? void 0;
    return message;
  }
};
function createBaseMapStartOrContinueRequest() {
  return { functionId: "", parentInputId: "", functionCallId: void 0, mapToken: void 0, items: [] };
}
var MapStartOrContinueRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.parentInputId !== "") {
      writer.uint32(18).string(message.parentInputId);
    }
    if (message.functionCallId !== void 0) {
      writer.uint32(26).string(message.functionCallId);
    }
    if (message.mapToken !== void 0) {
      writer.uint32(42).string(message.mapToken);
    }
    for (const v of message.items) {
      MapStartOrContinueItem.encode(v, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapStartOrContinueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.parentInputId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.mapToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.items.push(MapStartOrContinueItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      parentInputId: isSet3(object.parentInputId) ? globalThis.String(object.parentInputId) : "",
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : void 0,
      mapToken: isSet3(object.mapToken) ? globalThis.String(object.mapToken) : void 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => MapStartOrContinueItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.parentInputId !== "") {
      obj.parentInputId = message.parentInputId;
    }
    if (message.functionCallId !== void 0) {
      obj.functionCallId = message.functionCallId;
    }
    if (message.mapToken !== void 0) {
      obj.mapToken = message.mapToken;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => MapStartOrContinueItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MapStartOrContinueRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapStartOrContinueRequest();
    message.functionId = object.functionId ?? "";
    message.parentInputId = object.parentInputId ?? "";
    message.functionCallId = object.functionCallId ?? void 0;
    message.mapToken = object.mapToken ?? void 0;
    message.items = object.items?.map((e) => MapStartOrContinueItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseMapStartOrContinueResponse() {
  return {
    mapToken: "",
    functionId: "",
    functionCallId: "",
    maxInputsOutstanding: 0,
    attemptTokens: [],
    retryPolicy: void 0
  };
}
var MapStartOrContinueResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mapToken !== "") {
      writer.uint32(50).string(message.mapToken);
    }
    if (message.functionId !== "") {
      writer.uint32(10).string(message.functionId);
    }
    if (message.functionCallId !== "") {
      writer.uint32(18).string(message.functionCallId);
    }
    if (message.maxInputsOutstanding !== 0) {
      writer.uint32(24).uint32(message.maxInputsOutstanding);
    }
    for (const v of message.attemptTokens) {
      writer.uint32(34).string(v);
    }
    if (message.retryPolicy !== void 0) {
      FunctionRetryPolicy.encode(message.retryPolicy, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapStartOrContinueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.mapToken = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxInputsOutstanding = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.attemptTokens.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.retryPolicy = FunctionRetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      mapToken: isSet3(object.mapToken) ? globalThis.String(object.mapToken) : "",
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      maxInputsOutstanding: isSet3(object.maxInputsOutstanding) ? globalThis.Number(object.maxInputsOutstanding) : 0,
      attemptTokens: globalThis.Array.isArray(object?.attemptTokens) ? object.attemptTokens.map((e) => globalThis.String(e)) : [],
      retryPolicy: isSet3(object.retryPolicy) ? FunctionRetryPolicy.fromJSON(object.retryPolicy) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.mapToken !== "") {
      obj.mapToken = message.mapToken;
    }
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.maxInputsOutstanding !== 0) {
      obj.maxInputsOutstanding = Math.round(message.maxInputsOutstanding);
    }
    if (message.attemptTokens?.length) {
      obj.attemptTokens = message.attemptTokens;
    }
    if (message.retryPolicy !== void 0) {
      obj.retryPolicy = FunctionRetryPolicy.toJSON(message.retryPolicy);
    }
    return obj;
  },
  create(base) {
    return MapStartOrContinueResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMapStartOrContinueResponse();
    message.mapToken = object.mapToken ?? "";
    message.functionId = object.functionId ?? "";
    message.functionCallId = object.functionCallId ?? "";
    message.maxInputsOutstanding = object.maxInputsOutstanding ?? 0;
    message.attemptTokens = object.attemptTokens?.map((e) => e) || [];
    message.retryPolicy = object.retryPolicy !== void 0 && object.retryPolicy !== null ? FunctionRetryPolicy.fromPartial(object.retryPolicy) : void 0;
    return message;
  }
};
function createBaseMethodDefinition() {
  return {
    functionName: "",
    functionType: 0,
    webhookConfig: void 0,
    webUrl: "",
    webUrlInfo: void 0,
    customDomainInfo: [],
    functionSchema: void 0,
    supportedInputFormats: [],
    supportedOutputFormats: []
  };
}
var MethodDefinition = {
  encode(message, writer = new BinaryWriter()) {
    if (message.functionName !== "") {
      writer.uint32(10).string(message.functionName);
    }
    if (message.functionType !== 0) {
      writer.uint32(16).int32(message.functionType);
    }
    if (message.webhookConfig !== void 0) {
      WebhookConfig.encode(message.webhookConfig, writer.uint32(26).fork()).join();
    }
    if (message.webUrl !== "") {
      writer.uint32(34).string(message.webUrl);
    }
    if (message.webUrlInfo !== void 0) {
      WebUrlInfo.encode(message.webUrlInfo, writer.uint32(42).fork()).join();
    }
    for (const v of message.customDomainInfo) {
      CustomDomainInfo.encode(v, writer.uint32(50).fork()).join();
    }
    if (message.functionSchema !== void 0) {
      FunctionSchema.encode(message.functionSchema, writer.uint32(58).fork()).join();
    }
    writer.uint32(66).fork();
    for (const v of message.supportedInputFormats) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(74).fork();
    for (const v of message.supportedOutputFormats) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMethodDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.functionName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.functionType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.webhookConfig = WebhookConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.webUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.webUrlInfo = WebUrlInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.customDomainInfo.push(CustomDomainInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.functionSchema = FunctionSchema.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.supportedInputFormats.push(reader.int32());
            continue;
          }
          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedInputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 9: {
          if (tag === 72) {
            message.supportedOutputFormats.push(reader.int32());
            continue;
          }
          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedOutputFormats.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      functionName: isSet3(object.functionName) ? globalThis.String(object.functionName) : "",
      functionType: isSet3(object.functionType) ? function_FunctionTypeFromJSON(object.functionType) : 0,
      webhookConfig: isSet3(object.webhookConfig) ? WebhookConfig.fromJSON(object.webhookConfig) : void 0,
      webUrl: isSet3(object.webUrl) ? globalThis.String(object.webUrl) : "",
      webUrlInfo: isSet3(object.webUrlInfo) ? WebUrlInfo.fromJSON(object.webUrlInfo) : void 0,
      customDomainInfo: globalThis.Array.isArray(object?.customDomainInfo) ? object.customDomainInfo.map((e) => CustomDomainInfo.fromJSON(e)) : [],
      functionSchema: isSet3(object.functionSchema) ? FunctionSchema.fromJSON(object.functionSchema) : void 0,
      supportedInputFormats: globalThis.Array.isArray(object?.supportedInputFormats) ? object.supportedInputFormats.map((e) => dataFormatFromJSON(e)) : [],
      supportedOutputFormats: globalThis.Array.isArray(object?.supportedOutputFormats) ? object.supportedOutputFormats.map((e) => dataFormatFromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    if (message.functionType !== 0) {
      obj.functionType = function_FunctionTypeToJSON(message.functionType);
    }
    if (message.webhookConfig !== void 0) {
      obj.webhookConfig = WebhookConfig.toJSON(message.webhookConfig);
    }
    if (message.webUrl !== "") {
      obj.webUrl = message.webUrl;
    }
    if (message.webUrlInfo !== void 0) {
      obj.webUrlInfo = WebUrlInfo.toJSON(message.webUrlInfo);
    }
    if (message.customDomainInfo?.length) {
      obj.customDomainInfo = message.customDomainInfo.map((e) => CustomDomainInfo.toJSON(e));
    }
    if (message.functionSchema !== void 0) {
      obj.functionSchema = FunctionSchema.toJSON(message.functionSchema);
    }
    if (message.supportedInputFormats?.length) {
      obj.supportedInputFormats = message.supportedInputFormats.map((e) => dataFormatToJSON(e));
    }
    if (message.supportedOutputFormats?.length) {
      obj.supportedOutputFormats = message.supportedOutputFormats.map((e) => dataFormatToJSON(e));
    }
    return obj;
  },
  create(base) {
    return MethodDefinition.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMethodDefinition();
    message.functionName = object.functionName ?? "";
    message.functionType = object.functionType ?? 0;
    message.webhookConfig = object.webhookConfig !== void 0 && object.webhookConfig !== null ? WebhookConfig.fromPartial(object.webhookConfig) : void 0;
    message.webUrl = object.webUrl ?? "";
    message.webUrlInfo = object.webUrlInfo !== void 0 && object.webUrlInfo !== null ? WebUrlInfo.fromPartial(object.webUrlInfo) : void 0;
    message.customDomainInfo = object.customDomainInfo?.map((e) => CustomDomainInfo.fromPartial(e)) || [];
    message.functionSchema = object.functionSchema !== void 0 && object.functionSchema !== null ? FunctionSchema.fromPartial(object.functionSchema) : void 0;
    message.supportedInputFormats = object.supportedInputFormats?.map((e) => e) || [];
    message.supportedOutputFormats = object.supportedOutputFormats?.map((e) => e) || [];
    return message;
  }
};
function createBaseMountFile() {
  return { filename: "", sha256Hex: "", size: void 0, mode: void 0 };
}
var MountFile = {
  encode(message, writer = new BinaryWriter()) {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.sha256Hex !== "") {
      writer.uint32(26).string(message.sha256Hex);
    }
    if (message.size !== void 0) {
      writer.uint32(32).uint64(message.size);
    }
    if (message.mode !== void 0) {
      writer.uint32(40).uint32(message.mode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMountFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.filename = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.sha256Hex = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.mode = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      filename: isSet3(object.filename) ? globalThis.String(object.filename) : "",
      sha256Hex: isSet3(object.sha256Hex) ? globalThis.String(object.sha256Hex) : "",
      size: isSet3(object.size) ? globalThis.Number(object.size) : void 0,
      mode: isSet3(object.mode) ? globalThis.Number(object.mode) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.sha256Hex !== "") {
      obj.sha256Hex = message.sha256Hex;
    }
    if (message.size !== void 0) {
      obj.size = Math.round(message.size);
    }
    if (message.mode !== void 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },
  create(base) {
    return MountFile.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMountFile();
    message.filename = object.filename ?? "";
    message.sha256Hex = object.sha256Hex ?? "";
    message.size = object.size ?? void 0;
    message.mode = object.mode ?? void 0;
    return message;
  }
};
function createBaseMountGetOrCreateRequest() {
  return { deploymentName: "", namespace: 0, environmentName: "", objectCreationType: 0, files: [], appId: "" };
}
var MountGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.namespace !== 0) {
      writer.uint32(16).int32(message.namespace);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    for (const v of message.files) {
      MountFile.encode(v, writer.uint32(42).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(50).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMountGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.namespace = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.files.push(MountFile.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      namespace: isSet3(object.namespace) ? deploymentNamespaceFromJSON(object.namespace) : 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0,
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => MountFile.fromJSON(e)) : [],
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.namespace !== 0) {
      obj.namespace = deploymentNamespaceToJSON(message.namespace);
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => MountFile.toJSON(e));
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return MountGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMountGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.namespace = object.namespace ?? 0;
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    message.files = object.files?.map((e) => MountFile.fromPartial(e)) || [];
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseMountGetOrCreateResponse() {
  return { mountId: "", handleMetadata: void 0 };
}
var MountGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mountId !== "") {
      writer.uint32(10).string(message.mountId);
    }
    if (message.handleMetadata !== void 0) {
      MountHandleMetadata.encode(message.handleMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMountGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.mountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.handleMetadata = MountHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      mountId: isSet3(object.mountId) ? globalThis.String(object.mountId) : "",
      handleMetadata: isSet3(object.handleMetadata) ? MountHandleMetadata.fromJSON(object.handleMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.mountId !== "") {
      obj.mountId = message.mountId;
    }
    if (message.handleMetadata !== void 0) {
      obj.handleMetadata = MountHandleMetadata.toJSON(message.handleMetadata);
    }
    return obj;
  },
  create(base) {
    return MountGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMountGetOrCreateResponse();
    message.mountId = object.mountId ?? "";
    message.handleMetadata = object.handleMetadata !== void 0 && object.handleMetadata !== null ? MountHandleMetadata.fromPartial(object.handleMetadata) : void 0;
    return message;
  }
};
function createBaseMountHandleMetadata() {
  return { contentChecksumSha256Hex: "" };
}
var MountHandleMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.contentChecksumSha256Hex !== "") {
      writer.uint32(10).string(message.contentChecksumSha256Hex);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMountHandleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.contentChecksumSha256Hex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contentChecksumSha256Hex: isSet3(object.contentChecksumSha256Hex) ? globalThis.String(object.contentChecksumSha256Hex) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contentChecksumSha256Hex !== "") {
      obj.contentChecksumSha256Hex = message.contentChecksumSha256Hex;
    }
    return obj;
  },
  create(base) {
    return MountHandleMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMountHandleMetadata();
    message.contentChecksumSha256Hex = object.contentChecksumSha256Hex ?? "";
    return message;
  }
};
function createBaseMountPutFileRequest() {
  return { sha256Hex: "", data: void 0, dataBlobId: void 0 };
}
var MountPutFileRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sha256Hex !== "") {
      writer.uint32(18).string(message.sha256Hex);
    }
    if (message.data !== void 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      writer.uint32(42).string(message.dataBlobId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMountPutFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.sha256Hex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.dataBlobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sha256Hex: isSet3(object.sha256Hex) ? globalThis.String(object.sha256Hex) : "",
      data: isSet3(object.data) ? bytesFromBase64(object.data) : void 0,
      dataBlobId: isSet3(object.dataBlobId) ? globalThis.String(object.dataBlobId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sha256Hex !== "") {
      obj.sha256Hex = message.sha256Hex;
    }
    if (message.data !== void 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      obj.dataBlobId = message.dataBlobId;
    }
    return obj;
  },
  create(base) {
    return MountPutFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMountPutFileRequest();
    message.sha256Hex = object.sha256Hex ?? "";
    message.data = object.data ?? void 0;
    message.dataBlobId = object.dataBlobId ?? void 0;
    return message;
  }
};
function createBaseMountPutFileResponse() {
  return { exists: false };
}
var MountPutFileResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.exists !== false) {
      writer.uint32(16).bool(message.exists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMountPutFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { exists: isSet3(object.exists) ? globalThis.Boolean(object.exists) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },
  create(base) {
    return MountPutFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMountPutFileResponse();
    message.exists = object.exists ?? false;
    return message;
  }
};
function createBaseMultiPartUpload() {
  return { partLength: 0, uploadUrls: [], completionUrl: "" };
}
var MultiPartUpload = {
  encode(message, writer = new BinaryWriter()) {
    if (message.partLength !== 0) {
      writer.uint32(8).int64(message.partLength);
    }
    for (const v of message.uploadUrls) {
      writer.uint32(18).string(v);
    }
    if (message.completionUrl !== "") {
      writer.uint32(26).string(message.completionUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultiPartUpload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.partLength = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.uploadUrls.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.completionUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      partLength: isSet3(object.partLength) ? globalThis.Number(object.partLength) : 0,
      uploadUrls: globalThis.Array.isArray(object?.uploadUrls) ? object.uploadUrls.map((e) => globalThis.String(e)) : [],
      completionUrl: isSet3(object.completionUrl) ? globalThis.String(object.completionUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.partLength !== 0) {
      obj.partLength = Math.round(message.partLength);
    }
    if (message.uploadUrls?.length) {
      obj.uploadUrls = message.uploadUrls;
    }
    if (message.completionUrl !== "") {
      obj.completionUrl = message.completionUrl;
    }
    return obj;
  },
  create(base) {
    return MultiPartUpload.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMultiPartUpload();
    message.partLength = object.partLength ?? 0;
    message.uploadUrls = object.uploadUrls?.map((e) => e) || [];
    message.completionUrl = object.completionUrl ?? "";
    return message;
  }
};
function createBaseMultiPartUploadList() {
  return { items: [] };
}
var MultiPartUploadList = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      MultiPartUpload.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMultiPartUploadList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(MultiPartUpload.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => MultiPartUpload.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => MultiPartUpload.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return MultiPartUploadList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseMultiPartUploadList();
    message.items = object.items?.map((e) => MultiPartUpload.fromPartial(e)) || [];
    return message;
  }
};
function createBaseNetworkAccess() {
  return { networkAccessType: 0, allowedCidrs: [] };
}
var NetworkAccess = {
  encode(message, writer = new BinaryWriter()) {
    if (message.networkAccessType !== 0) {
      writer.uint32(8).int32(message.networkAccessType);
    }
    for (const v of message.allowedCidrs) {
      writer.uint32(18).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNetworkAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.networkAccessType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.allowedCidrs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      networkAccessType: isSet3(object.networkAccessType) ? networkAccess_NetworkAccessTypeFromJSON(object.networkAccessType) : 0,
      allowedCidrs: globalThis.Array.isArray(object?.allowedCidrs) ? object.allowedCidrs.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.networkAccessType !== 0) {
      obj.networkAccessType = networkAccess_NetworkAccessTypeToJSON(message.networkAccessType);
    }
    if (message.allowedCidrs?.length) {
      obj.allowedCidrs = message.allowedCidrs;
    }
    return obj;
  },
  create(base) {
    return NetworkAccess.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNetworkAccess();
    message.networkAccessType = object.networkAccessType ?? 0;
    message.allowedCidrs = object.allowedCidrs?.map((e) => e) || [];
    return message;
  }
};
function createBaseNotebookKernelPublishResultsRequest() {
  return { notebookId: "", results: [] };
}
var NotebookKernelPublishResultsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.notebookId !== "") {
      writer.uint32(10).string(message.notebookId);
    }
    for (const v of message.results) {
      NotebookKernelPublishResultsRequest_CellResult.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookKernelPublishResultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.notebookId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.results.push(NotebookKernelPublishResultsRequest_CellResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      notebookId: isSet3(object.notebookId) ? globalThis.String(object.notebookId) : "",
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e) => NotebookKernelPublishResultsRequest_CellResult.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.notebookId !== "") {
      obj.notebookId = message.notebookId;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => NotebookKernelPublishResultsRequest_CellResult.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return NotebookKernelPublishResultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookKernelPublishResultsRequest();
    message.notebookId = object.notebookId ?? "";
    message.results = object.results?.map((e) => NotebookKernelPublishResultsRequest_CellResult.fromPartial(e)) || [];
    return message;
  }
};
function createBaseNotebookKernelPublishResultsRequest_ExecuteReply() {
  return { status: "", executionCount: 0, duration: 0 };
}
var NotebookKernelPublishResultsRequest_ExecuteReply = {
  encode(message, writer = new BinaryWriter()) {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.executionCount !== 0) {
      writer.uint32(16).uint32(message.executionCount);
    }
    if (message.duration !== 0) {
      writer.uint32(25).double(message.duration);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookKernelPublishResultsRequest_ExecuteReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.executionCount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.duration = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      status: isSet3(object.status) ? globalThis.String(object.status) : "",
      executionCount: isSet3(object.executionCount) ? globalThis.Number(object.executionCount) : 0,
      duration: isSet3(object.duration) ? globalThis.Number(object.duration) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.executionCount !== 0) {
      obj.executionCount = Math.round(message.executionCount);
    }
    if (message.duration !== 0) {
      obj.duration = message.duration;
    }
    return obj;
  },
  create(base) {
    return NotebookKernelPublishResultsRequest_ExecuteReply.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookKernelPublishResultsRequest_ExecuteReply();
    message.status = object.status ?? "";
    message.executionCount = object.executionCount ?? 0;
    message.duration = object.duration ?? 0;
    return message;
  }
};
function createBaseNotebookKernelPublishResultsRequest_CellResult() {
  return { cellId: "", output: void 0, clearOutput: void 0, executeReply: void 0 };
}
var NotebookKernelPublishResultsRequest_CellResult = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cellId !== "") {
      writer.uint32(10).string(message.cellId);
    }
    if (message.output !== void 0) {
      NotebookOutput.encode(message.output, writer.uint32(18).fork()).join();
    }
    if (message.clearOutput !== void 0) {
      writer.uint32(24).bool(message.clearOutput);
    }
    if (message.executeReply !== void 0) {
      NotebookKernelPublishResultsRequest_ExecuteReply.encode(message.executeReply, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookKernelPublishResultsRequest_CellResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cellId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.output = NotebookOutput.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.clearOutput = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.executeReply = NotebookKernelPublishResultsRequest_ExecuteReply.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cellId: isSet3(object.cellId) ? globalThis.String(object.cellId) : "",
      output: isSet3(object.output) ? NotebookOutput.fromJSON(object.output) : void 0,
      clearOutput: isSet3(object.clearOutput) ? globalThis.Boolean(object.clearOutput) : void 0,
      executeReply: isSet3(object.executeReply) ? NotebookKernelPublishResultsRequest_ExecuteReply.fromJSON(object.executeReply) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cellId !== "") {
      obj.cellId = message.cellId;
    }
    if (message.output !== void 0) {
      obj.output = NotebookOutput.toJSON(message.output);
    }
    if (message.clearOutput !== void 0) {
      obj.clearOutput = message.clearOutput;
    }
    if (message.executeReply !== void 0) {
      obj.executeReply = NotebookKernelPublishResultsRequest_ExecuteReply.toJSON(message.executeReply);
    }
    return obj;
  },
  create(base) {
    return NotebookKernelPublishResultsRequest_CellResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookKernelPublishResultsRequest_CellResult();
    message.cellId = object.cellId ?? "";
    message.output = object.output !== void 0 && object.output !== null ? NotebookOutput.fromPartial(object.output) : void 0;
    message.clearOutput = object.clearOutput ?? void 0;
    message.executeReply = object.executeReply !== void 0 && object.executeReply !== null ? NotebookKernelPublishResultsRequest_ExecuteReply.fromPartial(object.executeReply) : void 0;
    return message;
  }
};
function createBaseNotebookOutput() {
  return { executeResult: void 0, displayData: void 0, stream: void 0, error: void 0 };
}
var NotebookOutput = {
  encode(message, writer = new BinaryWriter()) {
    if (message.executeResult !== void 0) {
      NotebookOutput_ExecuteResult.encode(message.executeResult, writer.uint32(10).fork()).join();
    }
    if (message.displayData !== void 0) {
      NotebookOutput_DisplayData.encode(message.displayData, writer.uint32(18).fork()).join();
    }
    if (message.stream !== void 0) {
      NotebookOutput_Stream.encode(message.stream, writer.uint32(26).fork()).join();
    }
    if (message.error !== void 0) {
      NotebookOutput_Error.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.executeResult = NotebookOutput_ExecuteResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.displayData = NotebookOutput_DisplayData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.stream = NotebookOutput_Stream.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.error = NotebookOutput_Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      executeResult: isSet3(object.executeResult) ? NotebookOutput_ExecuteResult.fromJSON(object.executeResult) : void 0,
      displayData: isSet3(object.displayData) ? NotebookOutput_DisplayData.fromJSON(object.displayData) : void 0,
      stream: isSet3(object.stream) ? NotebookOutput_Stream.fromJSON(object.stream) : void 0,
      error: isSet3(object.error) ? NotebookOutput_Error.fromJSON(object.error) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.executeResult !== void 0) {
      obj.executeResult = NotebookOutput_ExecuteResult.toJSON(message.executeResult);
    }
    if (message.displayData !== void 0) {
      obj.displayData = NotebookOutput_DisplayData.toJSON(message.displayData);
    }
    if (message.stream !== void 0) {
      obj.stream = NotebookOutput_Stream.toJSON(message.stream);
    }
    if (message.error !== void 0) {
      obj.error = NotebookOutput_Error.toJSON(message.error);
    }
    return obj;
  },
  create(base) {
    return NotebookOutput.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookOutput();
    message.executeResult = object.executeResult !== void 0 && object.executeResult !== null ? NotebookOutput_ExecuteResult.fromPartial(object.executeResult) : void 0;
    message.displayData = object.displayData !== void 0 && object.displayData !== null ? NotebookOutput_DisplayData.fromPartial(object.displayData) : void 0;
    message.stream = object.stream !== void 0 && object.stream !== null ? NotebookOutput_Stream.fromPartial(object.stream) : void 0;
    message.error = object.error !== void 0 && object.error !== null ? NotebookOutput_Error.fromPartial(object.error) : void 0;
    return message;
  }
};
function createBaseNotebookOutput_ExecuteResult() {
  return { executionCount: 0, data: void 0, metadata: void 0 };
}
var NotebookOutput_ExecuteResult = {
  encode(message, writer = new BinaryWriter()) {
    if (message.executionCount !== 0) {
      writer.uint32(8).uint32(message.executionCount);
    }
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).join();
    }
    if (message.metadata !== void 0) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookOutput_ExecuteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.executionCount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      executionCount: isSet3(object.executionCount) ? globalThis.Number(object.executionCount) : 0,
      data: isObject2(object.data) ? object.data : void 0,
      metadata: isObject2(object.metadata) ? object.metadata : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.executionCount !== 0) {
      obj.executionCount = Math.round(message.executionCount);
    }
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    if (message.metadata !== void 0) {
      obj.metadata = message.metadata;
    }
    return obj;
  },
  create(base) {
    return NotebookOutput_ExecuteResult.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookOutput_ExecuteResult();
    message.executionCount = object.executionCount ?? 0;
    message.data = object.data ?? void 0;
    message.metadata = object.metadata ?? void 0;
    return message;
  }
};
function createBaseNotebookOutput_DisplayData() {
  return { data: void 0, metadata: void 0, transientDisplayId: void 0 };
}
var NotebookOutput_DisplayData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.data !== void 0) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).join();
    }
    if (message.metadata !== void 0) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(18).fork()).join();
    }
    if (message.transientDisplayId !== void 0) {
      writer.uint32(26).string(message.transientDisplayId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookOutput_DisplayData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.transientDisplayId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isObject2(object.data) ? object.data : void 0,
      metadata: isObject2(object.metadata) ? object.metadata : void 0,
      transientDisplayId: isSet3(object.transientDisplayId) ? globalThis.String(object.transientDisplayId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.data !== void 0) {
      obj.data = message.data;
    }
    if (message.metadata !== void 0) {
      obj.metadata = message.metadata;
    }
    if (message.transientDisplayId !== void 0) {
      obj.transientDisplayId = message.transientDisplayId;
    }
    return obj;
  },
  create(base) {
    return NotebookOutput_DisplayData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookOutput_DisplayData();
    message.data = object.data ?? void 0;
    message.metadata = object.metadata ?? void 0;
    message.transientDisplayId = object.transientDisplayId ?? void 0;
    return message;
  }
};
function createBaseNotebookOutput_Stream() {
  return { name: "", text: "" };
}
var NotebookOutput_Stream = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookOutput_Stream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      text: isSet3(object.text) ? globalThis.String(object.text) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },
  create(base) {
    return NotebookOutput_Stream.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookOutput_Stream();
    message.name = object.name ?? "";
    message.text = object.text ?? "";
    return message;
  }
};
function createBaseNotebookOutput_Error() {
  return { ename: "", evalue: "", traceback: [] };
}
var NotebookOutput_Error = {
  encode(message, writer = new BinaryWriter()) {
    if (message.ename !== "") {
      writer.uint32(10).string(message.ename);
    }
    if (message.evalue !== "") {
      writer.uint32(18).string(message.evalue);
    }
    for (const v of message.traceback) {
      writer.uint32(26).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseNotebookOutput_Error();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.evalue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.traceback.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      ename: isSet3(object.ename) ? globalThis.String(object.ename) : "",
      evalue: isSet3(object.evalue) ? globalThis.String(object.evalue) : "",
      traceback: globalThis.Array.isArray(object?.traceback) ? object.traceback.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.ename !== "") {
      obj.ename = message.ename;
    }
    if (message.evalue !== "") {
      obj.evalue = message.evalue;
    }
    if (message.traceback?.length) {
      obj.traceback = message.traceback;
    }
    return obj;
  },
  create(base) {
    return NotebookOutput_Error.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseNotebookOutput_Error();
    message.ename = object.ename ?? "";
    message.evalue = object.evalue ?? "";
    message.traceback = object.traceback?.map((e) => e) || [];
    return message;
  }
};
function createBaseObject() {
  return {
    objectId: "",
    functionHandleMetadata: void 0,
    mountHandleMetadata: void 0,
    classHandleMetadata: void 0,
    sandboxHandleMetadata: void 0,
    volumeMetadata: void 0
  };
}
var Object_ = {
  encode(message, writer = new BinaryWriter()) {
    if (message.objectId !== "") {
      writer.uint32(10).string(message.objectId);
    }
    if (message.functionHandleMetadata !== void 0) {
      FunctionHandleMetadata.encode(message.functionHandleMetadata, writer.uint32(26).fork()).join();
    }
    if (message.mountHandleMetadata !== void 0) {
      MountHandleMetadata.encode(message.mountHandleMetadata, writer.uint32(34).fork()).join();
    }
    if (message.classHandleMetadata !== void 0) {
      ClassHandleMetadata.encode(message.classHandleMetadata, writer.uint32(42).fork()).join();
    }
    if (message.sandboxHandleMetadata !== void 0) {
      SandboxHandleMetadata.encode(message.sandboxHandleMetadata, writer.uint32(50).fork()).join();
    }
    if (message.volumeMetadata !== void 0) {
      VolumeMetadata.encode(message.volumeMetadata, writer.uint32(58).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.objectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.functionHandleMetadata = FunctionHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.mountHandleMetadata = MountHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.classHandleMetadata = ClassHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.sandboxHandleMetadata = SandboxHandleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.volumeMetadata = VolumeMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      objectId: isSet3(object.objectId) ? globalThis.String(object.objectId) : "",
      functionHandleMetadata: isSet3(object.functionHandleMetadata) ? FunctionHandleMetadata.fromJSON(object.functionHandleMetadata) : void 0,
      mountHandleMetadata: isSet3(object.mountHandleMetadata) ? MountHandleMetadata.fromJSON(object.mountHandleMetadata) : void 0,
      classHandleMetadata: isSet3(object.classHandleMetadata) ? ClassHandleMetadata.fromJSON(object.classHandleMetadata) : void 0,
      sandboxHandleMetadata: isSet3(object.sandboxHandleMetadata) ? SandboxHandleMetadata.fromJSON(object.sandboxHandleMetadata) : void 0,
      volumeMetadata: isSet3(object.volumeMetadata) ? VolumeMetadata.fromJSON(object.volumeMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.functionHandleMetadata !== void 0) {
      obj.functionHandleMetadata = FunctionHandleMetadata.toJSON(message.functionHandleMetadata);
    }
    if (message.mountHandleMetadata !== void 0) {
      obj.mountHandleMetadata = MountHandleMetadata.toJSON(message.mountHandleMetadata);
    }
    if (message.classHandleMetadata !== void 0) {
      obj.classHandleMetadata = ClassHandleMetadata.toJSON(message.classHandleMetadata);
    }
    if (message.sandboxHandleMetadata !== void 0) {
      obj.sandboxHandleMetadata = SandboxHandleMetadata.toJSON(message.sandboxHandleMetadata);
    }
    if (message.volumeMetadata !== void 0) {
      obj.volumeMetadata = VolumeMetadata.toJSON(message.volumeMetadata);
    }
    return obj;
  },
  create(base) {
    return Object_.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseObject();
    message.objectId = object.objectId ?? "";
    message.functionHandleMetadata = object.functionHandleMetadata !== void 0 && object.functionHandleMetadata !== null ? FunctionHandleMetadata.fromPartial(object.functionHandleMetadata) : void 0;
    message.mountHandleMetadata = object.mountHandleMetadata !== void 0 && object.mountHandleMetadata !== null ? MountHandleMetadata.fromPartial(object.mountHandleMetadata) : void 0;
    message.classHandleMetadata = object.classHandleMetadata !== void 0 && object.classHandleMetadata !== null ? ClassHandleMetadata.fromPartial(object.classHandleMetadata) : void 0;
    message.sandboxHandleMetadata = object.sandboxHandleMetadata !== void 0 && object.sandboxHandleMetadata !== null ? SandboxHandleMetadata.fromPartial(object.sandboxHandleMetadata) : void 0;
    message.volumeMetadata = object.volumeMetadata !== void 0 && object.volumeMetadata !== null ? VolumeMetadata.fromPartial(object.volumeMetadata) : void 0;
    return message;
  }
};
function createBaseObjectDependency() {
  return { objectId: "" };
}
var ObjectDependency = {
  encode(message, writer = new BinaryWriter()) {
    if (message.objectId !== "") {
      writer.uint32(10).string(message.objectId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseObjectDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.objectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { objectId: isSet3(object.objectId) ? globalThis.String(object.objectId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    return obj;
  },
  create(base) {
    return ObjectDependency.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseObjectDependency();
    message.objectId = object.objectId ?? "";
    return message;
  }
};
function createBasePTYInfo() {
  return {
    enabled: false,
    winszRows: 0,
    winszCols: 0,
    envTerm: "",
    envColorterm: "",
    envTermProgram: "",
    ptyType: 0,
    noTerminateOnIdleStdin: false
  };
}
var PTYInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.winszRows !== 0) {
      writer.uint32(16).uint32(message.winszRows);
    }
    if (message.winszCols !== 0) {
      writer.uint32(24).uint32(message.winszCols);
    }
    if (message.envTerm !== "") {
      writer.uint32(34).string(message.envTerm);
    }
    if (message.envColorterm !== "") {
      writer.uint32(42).string(message.envColorterm);
    }
    if (message.envTermProgram !== "") {
      writer.uint32(50).string(message.envTermProgram);
    }
    if (message.ptyType !== 0) {
      writer.uint32(56).int32(message.ptyType);
    }
    if (message.noTerminateOnIdleStdin !== false) {
      writer.uint32(64).bool(message.noTerminateOnIdleStdin);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePTYInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.winszRows = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.winszCols = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.envTerm = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.envColorterm = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.envTermProgram = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.ptyType = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.noTerminateOnIdleStdin = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      enabled: isSet3(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      winszRows: isSet3(object.winszRows) ? globalThis.Number(object.winszRows) : 0,
      winszCols: isSet3(object.winszCols) ? globalThis.Number(object.winszCols) : 0,
      envTerm: isSet3(object.envTerm) ? globalThis.String(object.envTerm) : "",
      envColorterm: isSet3(object.envColorterm) ? globalThis.String(object.envColorterm) : "",
      envTermProgram: isSet3(object.envTermProgram) ? globalThis.String(object.envTermProgram) : "",
      ptyType: isSet3(object.ptyType) ? pTYInfo_PTYTypeFromJSON(object.ptyType) : 0,
      noTerminateOnIdleStdin: isSet3(object.noTerminateOnIdleStdin) ? globalThis.Boolean(object.noTerminateOnIdleStdin) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.winszRows !== 0) {
      obj.winszRows = Math.round(message.winszRows);
    }
    if (message.winszCols !== 0) {
      obj.winszCols = Math.round(message.winszCols);
    }
    if (message.envTerm !== "") {
      obj.envTerm = message.envTerm;
    }
    if (message.envColorterm !== "") {
      obj.envColorterm = message.envColorterm;
    }
    if (message.envTermProgram !== "") {
      obj.envTermProgram = message.envTermProgram;
    }
    if (message.ptyType !== 0) {
      obj.ptyType = pTYInfo_PTYTypeToJSON(message.ptyType);
    }
    if (message.noTerminateOnIdleStdin !== false) {
      obj.noTerminateOnIdleStdin = message.noTerminateOnIdleStdin;
    }
    return obj;
  },
  create(base) {
    return PTYInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePTYInfo();
    message.enabled = object.enabled ?? false;
    message.winszRows = object.winszRows ?? 0;
    message.winszCols = object.winszCols ?? 0;
    message.envTerm = object.envTerm ?? "";
    message.envColorterm = object.envColorterm ?? "";
    message.envTermProgram = object.envTermProgram ?? "";
    message.ptyType = object.ptyType ?? 0;
    message.noTerminateOnIdleStdin = object.noTerminateOnIdleStdin ?? false;
    return message;
  }
};
function createBasePortSpec() {
  return { port: 0, unencrypted: false, tunnelType: void 0 };
}
var PortSpec = {
  encode(message, writer = new BinaryWriter()) {
    if (message.port !== 0) {
      writer.uint32(8).uint32(message.port);
    }
    if (message.unencrypted !== false) {
      writer.uint32(16).bool(message.unencrypted);
    }
    if (message.tunnelType !== void 0) {
      writer.uint32(24).int32(message.tunnelType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePortSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.unencrypted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.tunnelType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      port: isSet3(object.port) ? globalThis.Number(object.port) : 0,
      unencrypted: isSet3(object.unencrypted) ? globalThis.Boolean(object.unencrypted) : false,
      tunnelType: isSet3(object.tunnelType) ? tunnelTypeFromJSON(object.tunnelType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.unencrypted !== false) {
      obj.unencrypted = message.unencrypted;
    }
    if (message.tunnelType !== void 0) {
      obj.tunnelType = tunnelTypeToJSON(message.tunnelType);
    }
    return obj;
  },
  create(base) {
    return PortSpec.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePortSpec();
    message.port = object.port ?? 0;
    message.unencrypted = object.unencrypted ?? false;
    message.tunnelType = object.tunnelType ?? void 0;
    return message;
  }
};
function createBasePortSpecs() {
  return { ports: [] };
}
var PortSpecs = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.ports) {
      PortSpec.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePortSpecs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ports.push(PortSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e) => PortSpec.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => PortSpec.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return PortSpecs.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBasePortSpecs();
    message.ports = object.ports?.map((e) => PortSpec.fromPartial(e)) || [];
    return message;
  }
};
function createBaseProxy() {
  return { name: "", createdAt: 0, environmentName: "", proxyId: "", proxyIps: [] };
}
var Proxy = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createdAt !== 0) {
      writer.uint32(17).double(message.createdAt);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.proxyId !== "") {
      writer.uint32(42).string(message.proxyId);
    }
    for (const v of message.proxyIps) {
      ProxyIp.encode(v, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.proxyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.proxyIps.push(ProxyIp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      proxyId: isSet3(object.proxyId) ? globalThis.String(object.proxyId) : "",
      proxyIps: globalThis.Array.isArray(object?.proxyIps) ? object.proxyIps.map((e) => ProxyIp.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.proxyId !== "") {
      obj.proxyId = message.proxyId;
    }
    if (message.proxyIps?.length) {
      obj.proxyIps = message.proxyIps.map((e) => ProxyIp.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return Proxy.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxy();
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.environmentName = object.environmentName ?? "";
    message.proxyId = object.proxyId ?? "";
    message.proxyIps = object.proxyIps?.map((e) => ProxyIp.fromPartial(e)) || [];
    return message;
  }
};
function createBaseProxyAddIpRequest() {
  return { proxyId: "" };
}
var ProxyAddIpRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxyId !== "") {
      writer.uint32(10).string(message.proxyId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyAddIpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxyId: isSet3(object.proxyId) ? globalThis.String(object.proxyId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxyId !== "") {
      obj.proxyId = message.proxyId;
    }
    return obj;
  },
  create(base) {
    return ProxyAddIpRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyAddIpRequest();
    message.proxyId = object.proxyId ?? "";
    return message;
  }
};
function createBaseProxyAddIpResponse() {
  return { proxyIp: void 0 };
}
var ProxyAddIpResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxyIp !== void 0) {
      ProxyIp.encode(message.proxyIp, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyAddIpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxyIp = ProxyIp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxyIp: isSet3(object.proxyIp) ? ProxyIp.fromJSON(object.proxyIp) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxyIp !== void 0) {
      obj.proxyIp = ProxyIp.toJSON(message.proxyIp);
    }
    return obj;
  },
  create(base) {
    return ProxyAddIpResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyAddIpResponse();
    message.proxyIp = object.proxyIp !== void 0 && object.proxyIp !== null ? ProxyIp.fromPartial(object.proxyIp) : void 0;
    return message;
  }
};
function createBaseProxyCreateRequest() {
  return { name: "", environmentName: "" };
}
var ProxyCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return ProxyCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyCreateRequest();
    message.name = object.name ?? "";
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseProxyCreateResponse() {
  return { proxy: void 0 };
}
var ProxyCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxy !== void 0) {
      Proxy.encode(message.proxy, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxy = Proxy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxy: isSet3(object.proxy) ? Proxy.fromJSON(object.proxy) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxy !== void 0) {
      obj.proxy = Proxy.toJSON(message.proxy);
    }
    return obj;
  },
  create(base) {
    return ProxyCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyCreateResponse();
    message.proxy = object.proxy !== void 0 && object.proxy !== null ? Proxy.fromPartial(object.proxy) : void 0;
    return message;
  }
};
function createBaseProxyDeleteRequest() {
  return { proxyId: "" };
}
var ProxyDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxyId !== "") {
      writer.uint32(10).string(message.proxyId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxyId: isSet3(object.proxyId) ? globalThis.String(object.proxyId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxyId !== "") {
      obj.proxyId = message.proxyId;
    }
    return obj;
  },
  create(base) {
    return ProxyDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyDeleteRequest();
    message.proxyId = object.proxyId ?? "";
    return message;
  }
};
function createBaseProxyGetOrCreateRequest() {
  return { deploymentName: "", environmentName: "", objectCreationType: 0 };
}
var ProxyGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    return obj;
  },
  create(base) {
    return ProxyGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    return message;
  }
};
function createBaseProxyGetOrCreateResponse() {
  return { proxyId: "" };
}
var ProxyGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxyId !== "") {
      writer.uint32(10).string(message.proxyId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxyId: isSet3(object.proxyId) ? globalThis.String(object.proxyId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxyId !== "") {
      obj.proxyId = message.proxyId;
    }
    return obj;
  },
  create(base) {
    return ProxyGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyGetOrCreateResponse();
    message.proxyId = object.proxyId ?? "";
    return message;
  }
};
function createBaseProxyGetRequest() {
  return { name: "", environmentName: "" };
}
var ProxyGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return ProxyGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyGetRequest();
    message.name = object.name ?? "";
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseProxyGetResponse() {
  return { proxy: void 0 };
}
var ProxyGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxy !== void 0) {
      Proxy.encode(message.proxy, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxy = Proxy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxy: isSet3(object.proxy) ? Proxy.fromJSON(object.proxy) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxy !== void 0) {
      obj.proxy = Proxy.toJSON(message.proxy);
    }
    return obj;
  },
  create(base) {
    return ProxyGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyGetResponse();
    message.proxy = object.proxy !== void 0 && object.proxy !== null ? Proxy.fromPartial(object.proxy) : void 0;
    return message;
  }
};
function createBaseProxyIp() {
  return { proxyIp: "", status: 0, createdAt: 0, environmentName: "" };
}
var ProxyIp = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxyIp !== "") {
      writer.uint32(10).string(message.proxyIp);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.createdAt !== 0) {
      writer.uint32(25).double(message.createdAt);
    }
    if (message.environmentName !== "") {
      writer.uint32(34).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyIp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxyIp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.status = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      proxyIp: isSet3(object.proxyIp) ? globalThis.String(object.proxyIp) : "",
      status: isSet3(object.status) ? proxyIpStatusFromJSON(object.status) : 0,
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxyIp !== "") {
      obj.proxyIp = message.proxyIp;
    }
    if (message.status !== 0) {
      obj.status = proxyIpStatusToJSON(message.status);
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return ProxyIp.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyIp();
    message.proxyIp = object.proxyIp ?? "";
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? 0;
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseProxyListResponse() {
  return { proxies: [] };
}
var ProxyListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.proxies) {
      Proxy.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxies.push(Proxy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      proxies: globalThis.Array.isArray(object?.proxies) ? object.proxies.map((e) => Proxy.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxies?.length) {
      obj.proxies = message.proxies.map((e) => Proxy.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ProxyListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyListResponse();
    message.proxies = object.proxies?.map((e) => Proxy.fromPartial(e)) || [];
    return message;
  }
};
function createBaseProxyRemoveIpRequest() {
  return { proxyIp: "" };
}
var ProxyRemoveIpRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.proxyIp !== "") {
      writer.uint32(10).string(message.proxyIp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseProxyRemoveIpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.proxyIp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { proxyIp: isSet3(object.proxyIp) ? globalThis.String(object.proxyIp) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.proxyIp !== "") {
      obj.proxyIp = message.proxyIp;
    }
    return obj;
  },
  create(base) {
    return ProxyRemoveIpRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseProxyRemoveIpRequest();
    message.proxyIp = object.proxyIp ?? "";
    return message;
  }
};
function createBaseQueueClearRequest() {
  return { queueId: "", partitionKey: new Uint8Array(0), allPartitions: false };
}
var QueueClearRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    if (message.partitionKey.length !== 0) {
      writer.uint32(18).bytes(message.partitionKey);
    }
    if (message.allPartitions !== false) {
      writer.uint32(24).bool(message.allPartitions);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueClearRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.partitionKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.allPartitions = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      partitionKey: isSet3(object.partitionKey) ? bytesFromBase64(object.partitionKey) : new Uint8Array(0),
      allPartitions: isSet3(object.allPartitions) ? globalThis.Boolean(object.allPartitions) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.partitionKey.length !== 0) {
      obj.partitionKey = base64FromBytes(message.partitionKey);
    }
    if (message.allPartitions !== false) {
      obj.allPartitions = message.allPartitions;
    }
    return obj;
  },
  create(base) {
    return QueueClearRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueClearRequest();
    message.queueId = object.queueId ?? "";
    message.partitionKey = object.partitionKey ?? new Uint8Array(0);
    message.allPartitions = object.allPartitions ?? false;
    return message;
  }
};
function createBaseQueueDeleteRequest() {
  return { queueId: "" };
}
var QueueDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    return obj;
  },
  create(base) {
    return QueueDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueDeleteRequest();
    message.queueId = object.queueId ?? "";
    return message;
  }
};
function createBaseQueueGetOrCreateRequest() {
  return { deploymentName: "", environmentName: "", objectCreationType: 0 };
}
var QueueGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    return obj;
  },
  create(base) {
    return QueueGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    return message;
  }
};
function createBaseQueueGetOrCreateResponse() {
  return { queueId: "", metadata: void 0 };
}
var QueueGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    if (message.metadata !== void 0) {
      QueueMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = QueueMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      metadata: isSet3(object.metadata) ? QueueMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = QueueMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return QueueGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueGetOrCreateResponse();
    message.queueId = object.queueId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? QueueMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseQueueGetRequest() {
  return { queueId: "", timeout: 0, nValues: 0, partitionKey: new Uint8Array(0) };
}
var QueueGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    if (message.timeout !== 0) {
      writer.uint32(29).float(message.timeout);
    }
    if (message.nValues !== 0) {
      writer.uint32(32).int32(message.nValues);
    }
    if (message.partitionKey.length !== 0) {
      writer.uint32(42).bytes(message.partitionKey);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.nValues = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.partitionKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      nValues: isSet3(object.nValues) ? globalThis.Number(object.nValues) : 0,
      partitionKey: isSet3(object.partitionKey) ? bytesFromBase64(object.partitionKey) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.nValues !== 0) {
      obj.nValues = Math.round(message.nValues);
    }
    if (message.partitionKey.length !== 0) {
      obj.partitionKey = base64FromBytes(message.partitionKey);
    }
    return obj;
  },
  create(base) {
    return QueueGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueGetRequest();
    message.queueId = object.queueId ?? "";
    message.timeout = object.timeout ?? 0;
    message.nValues = object.nValues ?? 0;
    message.partitionKey = object.partitionKey ?? new Uint8Array(0);
    return message;
  }
};
function createBaseQueueGetResponse() {
  return { values: [] };
}
var QueueGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.values) {
      writer.uint32(18).bytes(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.values.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => bytesFromBase64(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => base64FromBytes(e));
    }
    return obj;
  },
  create(base) {
    return QueueGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueGetResponse();
    message.values = object.values?.map((e) => e) || [];
    return message;
  }
};
function createBaseQueueHeartbeatRequest() {
  return { queueId: "" };
}
var QueueHeartbeatRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    return obj;
  },
  create(base) {
    return QueueHeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueHeartbeatRequest();
    message.queueId = object.queueId ?? "";
    return message;
  }
};
function createBaseQueueItem() {
  return { value: new Uint8Array(0), entryId: "" };
}
var QueueItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    if (message.entryId !== "") {
      writer.uint32(18).string(message.entryId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.entryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      value: isSet3(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      entryId: isSet3(object.entryId) ? globalThis.String(object.entryId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    return obj;
  },
  create(base) {
    return QueueItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueItem();
    message.value = object.value ?? new Uint8Array(0);
    message.entryId = object.entryId ?? "";
    return message;
  }
};
function createBaseQueueLenRequest() {
  return { queueId: "", partitionKey: new Uint8Array(0), total: false };
}
var QueueLenRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    if (message.partitionKey.length !== 0) {
      writer.uint32(18).bytes(message.partitionKey);
    }
    if (message.total !== false) {
      writer.uint32(24).bool(message.total);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueLenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.partitionKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.total = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      partitionKey: isSet3(object.partitionKey) ? bytesFromBase64(object.partitionKey) : new Uint8Array(0),
      total: isSet3(object.total) ? globalThis.Boolean(object.total) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.partitionKey.length !== 0) {
      obj.partitionKey = base64FromBytes(message.partitionKey);
    }
    if (message.total !== false) {
      obj.total = message.total;
    }
    return obj;
  },
  create(base) {
    return QueueLenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueLenRequest();
    message.queueId = object.queueId ?? "";
    message.partitionKey = object.partitionKey ?? new Uint8Array(0);
    message.total = object.total ?? false;
    return message;
  }
};
function createBaseQueueLenResponse() {
  return { len: 0 };
}
var QueueLenResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.len !== 0) {
      writer.uint32(8).int32(message.len);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueLenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.len = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { len: isSet3(object.len) ? globalThis.Number(object.len) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },
  create(base) {
    return QueueLenResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueLenResponse();
    message.len = object.len ?? 0;
    return message;
  }
};
function createBaseQueueListRequest() {
  return { environmentName: "", totalSizeLimit: 0, pagination: void 0 };
}
var QueueListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    if (message.totalSizeLimit !== 0) {
      writer.uint32(16).int32(message.totalSizeLimit);
    }
    if (message.pagination !== void 0) {
      ListPagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.totalSizeLimit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      totalSizeLimit: isSet3(object.totalSizeLimit) ? globalThis.Number(object.totalSizeLimit) : 0,
      pagination: isSet3(object.pagination) ? ListPagination.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.totalSizeLimit !== 0) {
      obj.totalSizeLimit = Math.round(message.totalSizeLimit);
    }
    if (message.pagination !== void 0) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },
  create(base) {
    return QueueListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueListRequest();
    message.environmentName = object.environmentName ?? "";
    message.totalSizeLimit = object.totalSizeLimit ?? 0;
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? ListPagination.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueueListResponse() {
  return { queues: [], environmentName: "" };
}
var QueueListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.queues) {
      QueueListResponse_QueueInfo.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queues.push(QueueListResponse_QueueInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queues: globalThis.Array.isArray(object?.queues) ? object.queues.map((e) => QueueListResponse_QueueInfo.fromJSON(e)) : [],
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queues?.length) {
      obj.queues = message.queues.map((e) => QueueListResponse_QueueInfo.toJSON(e));
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return QueueListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueListResponse();
    message.queues = object.queues?.map((e) => QueueListResponse_QueueInfo.fromPartial(e)) || [];
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseQueueListResponse_QueueInfo() {
  return { name: "", createdAt: 0, numPartitions: 0, totalSize: 0, queueId: "", metadata: void 0 };
}
var QueueListResponse_QueueInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createdAt !== 0) {
      writer.uint32(17).double(message.createdAt);
    }
    if (message.numPartitions !== 0) {
      writer.uint32(24).int32(message.numPartitions);
    }
    if (message.totalSize !== 0) {
      writer.uint32(32).int32(message.totalSize);
    }
    if (message.queueId !== "") {
      writer.uint32(42).string(message.queueId);
    }
    if (message.metadata !== void 0) {
      QueueMetadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueListResponse_QueueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.numPartitions = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.totalSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.metadata = QueueMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      numPartitions: isSet3(object.numPartitions) ? globalThis.Number(object.numPartitions) : 0,
      totalSize: isSet3(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      metadata: isSet3(object.metadata) ? QueueMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.numPartitions !== 0) {
      obj.numPartitions = Math.round(message.numPartitions);
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = QueueMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return QueueListResponse_QueueInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueListResponse_QueueInfo();
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.numPartitions = object.numPartitions ?? 0;
    message.totalSize = object.totalSize ?? 0;
    message.queueId = object.queueId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? QueueMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseQueueMetadata() {
  return { name: "", creationInfo: void 0 };
}
var QueueMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creationInfo !== void 0) {
      CreationInfo.encode(message.creationInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.creationInfo = CreationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      creationInfo: isSet3(object.creationInfo) ? CreationInfo.fromJSON(object.creationInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creationInfo !== void 0) {
      obj.creationInfo = CreationInfo.toJSON(message.creationInfo);
    }
    return obj;
  },
  create(base) {
    return QueueMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueMetadata();
    message.name = object.name ?? "";
    message.creationInfo = object.creationInfo !== void 0 && object.creationInfo !== null ? CreationInfo.fromPartial(object.creationInfo) : void 0;
    return message;
  }
};
function createBaseQueueNextItemsRequest() {
  return { queueId: "", partitionKey: new Uint8Array(0), lastEntryId: "", itemPollTimeout: 0 };
}
var QueueNextItemsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    if (message.partitionKey.length !== 0) {
      writer.uint32(18).bytes(message.partitionKey);
    }
    if (message.lastEntryId !== "") {
      writer.uint32(26).string(message.lastEntryId);
    }
    if (message.itemPollTimeout !== 0) {
      writer.uint32(37).float(message.itemPollTimeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueNextItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.partitionKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }
          message.itemPollTimeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      partitionKey: isSet3(object.partitionKey) ? bytesFromBase64(object.partitionKey) : new Uint8Array(0),
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : "",
      itemPollTimeout: isSet3(object.itemPollTimeout) ? globalThis.Number(object.itemPollTimeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.partitionKey.length !== 0) {
      obj.partitionKey = base64FromBytes(message.partitionKey);
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    if (message.itemPollTimeout !== 0) {
      obj.itemPollTimeout = message.itemPollTimeout;
    }
    return obj;
  },
  create(base) {
    return QueueNextItemsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueNextItemsRequest();
    message.queueId = object.queueId ?? "";
    message.partitionKey = object.partitionKey ?? new Uint8Array(0);
    message.lastEntryId = object.lastEntryId ?? "";
    message.itemPollTimeout = object.itemPollTimeout ?? 0;
    return message;
  }
};
function createBaseQueueNextItemsResponse() {
  return { items: [] };
}
var QueueNextItemsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      QueueItem.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueueNextItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(QueueItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => QueueItem.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => QueueItem.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return QueueNextItemsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueueNextItemsResponse();
    message.items = object.items?.map((e) => QueueItem.fromPartial(e)) || [];
    return message;
  }
};
function createBaseQueuePutRequest() {
  return { queueId: "", values: [], partitionKey: new Uint8Array(0), partitionTtlSeconds: 0 };
}
var QueuePutRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.queueId !== "") {
      writer.uint32(10).string(message.queueId);
    }
    for (const v of message.values) {
      writer.uint32(34).bytes(v);
    }
    if (message.partitionKey.length !== 0) {
      writer.uint32(42).bytes(message.partitionKey);
    }
    if (message.partitionTtlSeconds !== 0) {
      writer.uint32(48).int32(message.partitionTtlSeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseQueuePutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.queueId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.values.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.partitionKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.partitionTtlSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      queueId: isSet3(object.queueId) ? globalThis.String(object.queueId) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e) => bytesFromBase64(e)) : [],
      partitionKey: isSet3(object.partitionKey) ? bytesFromBase64(object.partitionKey) : new Uint8Array(0),
      partitionTtlSeconds: isSet3(object.partitionTtlSeconds) ? globalThis.Number(object.partitionTtlSeconds) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.queueId !== "") {
      obj.queueId = message.queueId;
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => base64FromBytes(e));
    }
    if (message.partitionKey.length !== 0) {
      obj.partitionKey = base64FromBytes(message.partitionKey);
    }
    if (message.partitionTtlSeconds !== 0) {
      obj.partitionTtlSeconds = Math.round(message.partitionTtlSeconds);
    }
    return obj;
  },
  create(base) {
    return QueuePutRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseQueuePutRequest();
    message.queueId = object.queueId ?? "";
    message.values = object.values?.map((e) => e) || [];
    message.partitionKey = object.partitionKey ?? new Uint8Array(0);
    message.partitionTtlSeconds = object.partitionTtlSeconds ?? 0;
    return message;
  }
};
function createBaseRateLimit() {
  return { limit: 0, interval: 0 };
}
var RateLimit = {
  encode(message, writer = new BinaryWriter()) {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.interval !== 0) {
      writer.uint32(16).int32(message.interval);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.limit = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.interval = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      limit: isSet3(object.limit) ? globalThis.Number(object.limit) : 0,
      interval: isSet3(object.interval) ? rateLimitIntervalFromJSON(object.interval) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.interval !== 0) {
      obj.interval = rateLimitIntervalToJSON(message.interval);
    }
    return obj;
  },
  create(base) {
    return RateLimit.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRateLimit();
    message.limit = object.limit ?? 0;
    message.interval = object.interval ?? 0;
    return message;
  }
};
function createBaseResources() {
  return {
    memoryMb: 0,
    milliCpu: 0,
    gpuConfig: void 0,
    memoryMbMax: 0,
    ephemeralDiskMb: 0,
    milliCpuMax: 0,
    rdma: false
  };
}
var Resources = {
  encode(message, writer = new BinaryWriter()) {
    if (message.memoryMb !== 0) {
      writer.uint32(16).uint32(message.memoryMb);
    }
    if (message.milliCpu !== 0) {
      writer.uint32(24).uint32(message.milliCpu);
    }
    if (message.gpuConfig !== void 0) {
      GPUConfig.encode(message.gpuConfig, writer.uint32(34).fork()).join();
    }
    if (message.memoryMbMax !== 0) {
      writer.uint32(40).uint32(message.memoryMbMax);
    }
    if (message.ephemeralDiskMb !== 0) {
      writer.uint32(48).uint32(message.ephemeralDiskMb);
    }
    if (message.milliCpuMax !== 0) {
      writer.uint32(56).uint32(message.milliCpuMax);
    }
    if (message.rdma !== false) {
      writer.uint32(64).bool(message.rdma);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.memoryMb = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.milliCpu = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.gpuConfig = GPUConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.memoryMbMax = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.ephemeralDiskMb = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.milliCpuMax = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.rdma = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      memoryMb: isSet3(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      milliCpu: isSet3(object.milliCpu) ? globalThis.Number(object.milliCpu) : 0,
      gpuConfig: isSet3(object.gpuConfig) ? GPUConfig.fromJSON(object.gpuConfig) : void 0,
      memoryMbMax: isSet3(object.memoryMbMax) ? globalThis.Number(object.memoryMbMax) : 0,
      ephemeralDiskMb: isSet3(object.ephemeralDiskMb) ? globalThis.Number(object.ephemeralDiskMb) : 0,
      milliCpuMax: isSet3(object.milliCpuMax) ? globalThis.Number(object.milliCpuMax) : 0,
      rdma: isSet3(object.rdma) ? globalThis.Boolean(object.rdma) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.milliCpu !== 0) {
      obj.milliCpu = Math.round(message.milliCpu);
    }
    if (message.gpuConfig !== void 0) {
      obj.gpuConfig = GPUConfig.toJSON(message.gpuConfig);
    }
    if (message.memoryMbMax !== 0) {
      obj.memoryMbMax = Math.round(message.memoryMbMax);
    }
    if (message.ephemeralDiskMb !== 0) {
      obj.ephemeralDiskMb = Math.round(message.ephemeralDiskMb);
    }
    if (message.milliCpuMax !== 0) {
      obj.milliCpuMax = Math.round(message.milliCpuMax);
    }
    if (message.rdma !== false) {
      obj.rdma = message.rdma;
    }
    return obj;
  },
  create(base) {
    return Resources.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseResources();
    message.memoryMb = object.memoryMb ?? 0;
    message.milliCpu = object.milliCpu ?? 0;
    message.gpuConfig = object.gpuConfig !== void 0 && object.gpuConfig !== null ? GPUConfig.fromPartial(object.gpuConfig) : void 0;
    message.memoryMbMax = object.memoryMbMax ?? 0;
    message.ephemeralDiskMb = object.ephemeralDiskMb ?? 0;
    message.milliCpuMax = object.milliCpuMax ?? 0;
    message.rdma = object.rdma ?? false;
    return message;
  }
};
function createBaseRuntimeInputMessage() {
  return { message: new Uint8Array(0), messageIndex: 0, eof: false };
}
var RuntimeInputMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.message.length !== 0) {
      writer.uint32(10).bytes(message.message);
    }
    if (message.messageIndex !== 0) {
      writer.uint32(16).uint64(message.messageIndex);
    }
    if (message.eof !== false) {
      writer.uint32(24).bool(message.eof);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRuntimeInputMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.message = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.messageIndex = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.eof = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      message: isSet3(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      messageIndex: isSet3(object.messageIndex) ? globalThis.Number(object.messageIndex) : 0,
      eof: isSet3(object.eof) ? globalThis.Boolean(object.eof) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.messageIndex !== 0) {
      obj.messageIndex = Math.round(message.messageIndex);
    }
    if (message.eof !== false) {
      obj.eof = message.eof;
    }
    return obj;
  },
  create(base) {
    return RuntimeInputMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRuntimeInputMessage();
    message.message = object.message ?? new Uint8Array(0);
    message.messageIndex = object.messageIndex ?? 0;
    message.eof = object.eof ?? false;
    return message;
  }
};
function createBaseRuntimeOutputBatch() {
  return { items: [], batchIndex: 0, exitCode: void 0, stdout: [], stderr: [], info: [] };
}
var RuntimeOutputBatch = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      RuntimeOutputMessage.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.batchIndex !== 0) {
      writer.uint32(16).uint64(message.batchIndex);
    }
    if (message.exitCode !== void 0) {
      writer.uint32(24).int32(message.exitCode);
    }
    for (const v of message.stdout) {
      RuntimeOutputMessage.encode(v, writer.uint32(34).fork()).join();
    }
    for (const v of message.stderr) {
      RuntimeOutputMessage.encode(v, writer.uint32(42).fork()).join();
    }
    for (const v of message.info) {
      RuntimeOutputMessage.encode(v, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRuntimeOutputBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(RuntimeOutputMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.batchIndex = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.exitCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.stdout.push(RuntimeOutputMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.stderr.push(RuntimeOutputMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.info.push(RuntimeOutputMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => RuntimeOutputMessage.fromJSON(e)) : [],
      batchIndex: isSet3(object.batchIndex) ? globalThis.Number(object.batchIndex) : 0,
      exitCode: isSet3(object.exitCode) ? globalThis.Number(object.exitCode) : void 0,
      stdout: globalThis.Array.isArray(object?.stdout) ? object.stdout.map((e) => RuntimeOutputMessage.fromJSON(e)) : [],
      stderr: globalThis.Array.isArray(object?.stderr) ? object.stderr.map((e) => RuntimeOutputMessage.fromJSON(e)) : [],
      info: globalThis.Array.isArray(object?.info) ? object.info.map((e) => RuntimeOutputMessage.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => RuntimeOutputMessage.toJSON(e));
    }
    if (message.batchIndex !== 0) {
      obj.batchIndex = Math.round(message.batchIndex);
    }
    if (message.exitCode !== void 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.stdout?.length) {
      obj.stdout = message.stdout.map((e) => RuntimeOutputMessage.toJSON(e));
    }
    if (message.stderr?.length) {
      obj.stderr = message.stderr.map((e) => RuntimeOutputMessage.toJSON(e));
    }
    if (message.info?.length) {
      obj.info = message.info.map((e) => RuntimeOutputMessage.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return RuntimeOutputBatch.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRuntimeOutputBatch();
    message.items = object.items?.map((e) => RuntimeOutputMessage.fromPartial(e)) || [];
    message.batchIndex = object.batchIndex ?? 0;
    message.exitCode = object.exitCode ?? void 0;
    message.stdout = object.stdout?.map((e) => RuntimeOutputMessage.fromPartial(e)) || [];
    message.stderr = object.stderr?.map((e) => RuntimeOutputMessage.fromPartial(e)) || [];
    message.info = object.info?.map((e) => RuntimeOutputMessage.fromPartial(e)) || [];
    return message;
  }
};
function createBaseRuntimeOutputMessage() {
  return { fileDescriptor: 0, message: "", messageBytes: new Uint8Array(0) };
}
var RuntimeOutputMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileDescriptor !== 0) {
      writer.uint32(8).int32(message.fileDescriptor);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.messageBytes.length !== 0) {
      writer.uint32(26).bytes(message.messageBytes);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRuntimeOutputMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.fileDescriptor = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.messageBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileDescriptor: isSet3(object.fileDescriptor) ? fileDescriptorFromJSON(object.fileDescriptor) : 0,
      message: isSet3(object.message) ? globalThis.String(object.message) : "",
      messageBytes: isSet3(object.messageBytes) ? bytesFromBase64(object.messageBytes) : new Uint8Array(0)
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileDescriptor !== 0) {
      obj.fileDescriptor = fileDescriptorToJSON(message.fileDescriptor);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.messageBytes.length !== 0) {
      obj.messageBytes = base64FromBytes(message.messageBytes);
    }
    return obj;
  },
  create(base) {
    return RuntimeOutputMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseRuntimeOutputMessage();
    message.fileDescriptor = object.fileDescriptor ?? 0;
    message.message = object.message ?? "";
    message.messageBytes = object.messageBytes ?? new Uint8Array(0);
    return message;
  }
};
function createBaseS3Mount() {
  return { bucketName: "", mountPath: "", credentialsSecretId: "", readOnly: false };
}
var S3Mount = {
  encode(message, writer = new BinaryWriter()) {
    if (message.bucketName !== "") {
      writer.uint32(10).string(message.bucketName);
    }
    if (message.mountPath !== "") {
      writer.uint32(18).string(message.mountPath);
    }
    if (message.credentialsSecretId !== "") {
      writer.uint32(26).string(message.credentialsSecretId);
    }
    if (message.readOnly !== false) {
      writer.uint32(32).bool(message.readOnly);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseS3Mount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.bucketName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mountPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.credentialsSecretId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.readOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      bucketName: isSet3(object.bucketName) ? globalThis.String(object.bucketName) : "",
      mountPath: isSet3(object.mountPath) ? globalThis.String(object.mountPath) : "",
      credentialsSecretId: isSet3(object.credentialsSecretId) ? globalThis.String(object.credentialsSecretId) : "",
      readOnly: isSet3(object.readOnly) ? globalThis.Boolean(object.readOnly) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    if (message.credentialsSecretId !== "") {
      obj.credentialsSecretId = message.credentialsSecretId;
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    return obj;
  },
  create(base) {
    return S3Mount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseS3Mount();
    message.bucketName = object.bucketName ?? "";
    message.mountPath = object.mountPath ?? "";
    message.credentialsSecretId = object.credentialsSecretId ?? "";
    message.readOnly = object.readOnly ?? false;
    return message;
  }
};
function createBaseSandbox() {
  return {
    entrypointArgs: [],
    mountIds: [],
    imageId: "",
    secretIds: [],
    resources: void 0,
    cloudProvider: 0,
    timeoutSecs: 0,
    workdir: void 0,
    nfsMounts: [],
    runtimeDebug: false,
    blockNetwork: false,
    s3Mounts: [],
    cloudBucketMounts: [],
    volumeMounts: [],
    ptyInfo: void 0,
    schedulerPlacement: void 0,
    workerId: "",
    openPorts: void 0,
    i6pnEnabled: false,
    networkAccess: void 0,
    proxyId: void 0,
    enableSnapshot: false,
    snapshotVersion: void 0,
    cloudProviderStr: "",
    runscRuntimeVersion: void 0,
    runtime: void 0,
    verbose: false,
    name: void 0,
    experimentalOptions: {},
    preloadPathPrefixes: [],
    idleTimeoutSecs: void 0
  };
}
var Sandbox = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.entrypointArgs) {
      writer.uint32(10).string(v);
    }
    for (const v of message.mountIds) {
      writer.uint32(18).string(v);
    }
    if (message.imageId !== "") {
      writer.uint32(26).string(message.imageId);
    }
    for (const v of message.secretIds) {
      writer.uint32(34).string(v);
    }
    if (message.resources !== void 0) {
      Resources.encode(message.resources, writer.uint32(42).fork()).join();
    }
    if (message.cloudProvider !== 0) {
      writer.uint32(48).int32(message.cloudProvider);
    }
    if (message.timeoutSecs !== 0) {
      writer.uint32(56).uint32(message.timeoutSecs);
    }
    if (message.workdir !== void 0) {
      writer.uint32(66).string(message.workdir);
    }
    for (const v of message.nfsMounts) {
      SharedVolumeMount.encode(v, writer.uint32(74).fork()).join();
    }
    if (message.runtimeDebug !== false) {
      writer.uint32(80).bool(message.runtimeDebug);
    }
    if (message.blockNetwork !== false) {
      writer.uint32(88).bool(message.blockNetwork);
    }
    for (const v of message.s3Mounts) {
      S3Mount.encode(v, writer.uint32(98).fork()).join();
    }
    for (const v of message.cloudBucketMounts) {
      CloudBucketMount.encode(v, writer.uint32(114).fork()).join();
    }
    for (const v of message.volumeMounts) {
      VolumeMount.encode(v, writer.uint32(106).fork()).join();
    }
    if (message.ptyInfo !== void 0) {
      PTYInfo.encode(message.ptyInfo, writer.uint32(122).fork()).join();
    }
    if (message.schedulerPlacement !== void 0) {
      SchedulerPlacement.encode(message.schedulerPlacement, writer.uint32(138).fork()).join();
    }
    if (message.workerId !== "") {
      writer.uint32(154).string(message.workerId);
    }
    if (message.openPorts !== void 0) {
      PortSpecs.encode(message.openPorts, writer.uint32(162).fork()).join();
    }
    if (message.i6pnEnabled !== false) {
      writer.uint32(168).bool(message.i6pnEnabled);
    }
    if (message.networkAccess !== void 0) {
      NetworkAccess.encode(message.networkAccess, writer.uint32(178).fork()).join();
    }
    if (message.proxyId !== void 0) {
      writer.uint32(186).string(message.proxyId);
    }
    if (message.enableSnapshot !== false) {
      writer.uint32(192).bool(message.enableSnapshot);
    }
    if (message.snapshotVersion !== void 0) {
      writer.uint32(200).uint32(message.snapshotVersion);
    }
    if (message.cloudProviderStr !== "") {
      writer.uint32(210).string(message.cloudProviderStr);
    }
    if (message.runscRuntimeVersion !== void 0) {
      writer.uint32(218).string(message.runscRuntimeVersion);
    }
    if (message.runtime !== void 0) {
      writer.uint32(226).string(message.runtime);
    }
    if (message.verbose !== false) {
      writer.uint32(232).bool(message.verbose);
    }
    if (message.name !== void 0) {
      writer.uint32(242).string(message.name);
    }
    Object.entries(message.experimentalOptions).forEach(([key, value]) => {
      Sandbox_ExperimentalOptionsEntry.encode({ key, value }, writer.uint32(250).fork()).join();
    });
    for (const v of message.preloadPathPrefixes) {
      writer.uint32(258).string(v);
    }
    if (message.idleTimeoutSecs !== void 0) {
      writer.uint32(264).uint32(message.idleTimeoutSecs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandbox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.entrypointArgs.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mountIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.secretIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.resources = Resources.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.cloudProvider = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.timeoutSecs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.workdir = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.nfsMounts.push(SharedVolumeMount.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.runtimeDebug = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.blockNetwork = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.s3Mounts.push(S3Mount.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.cloudBucketMounts.push(CloudBucketMount.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.volumeMounts.push(VolumeMount.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.ptyInfo = PTYInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.schedulerPlacement = SchedulerPlacement.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }
          message.workerId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }
          message.openPorts = PortSpecs.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }
          message.i6pnEnabled = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }
          message.networkAccess = NetworkAccess.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }
          message.proxyId = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }
          message.enableSnapshot = reader.bool();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }
          message.snapshotVersion = reader.uint32();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }
          message.cloudProviderStr = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }
          message.runscRuntimeVersion = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }
          message.runtime = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }
          message.verbose = reader.bool();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }
          const entry31 = Sandbox_ExperimentalOptionsEntry.decode(reader, reader.uint32());
          if (entry31.value !== void 0) {
            message.experimentalOptions[entry31.key] = entry31.value;
          }
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }
          message.preloadPathPrefixes.push(reader.string());
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }
          message.idleTimeoutSecs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      entrypointArgs: globalThis.Array.isArray(object?.entrypointArgs) ? object.entrypointArgs.map((e) => globalThis.String(e)) : [],
      mountIds: globalThis.Array.isArray(object?.mountIds) ? object.mountIds.map((e) => globalThis.String(e)) : [],
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      secretIds: globalThis.Array.isArray(object?.secretIds) ? object.secretIds.map((e) => globalThis.String(e)) : [],
      resources: isSet3(object.resources) ? Resources.fromJSON(object.resources) : void 0,
      cloudProvider: isSet3(object.cloudProvider) ? cloudProviderFromJSON(object.cloudProvider) : 0,
      timeoutSecs: isSet3(object.timeoutSecs) ? globalThis.Number(object.timeoutSecs) : 0,
      workdir: isSet3(object.workdir) ? globalThis.String(object.workdir) : void 0,
      nfsMounts: globalThis.Array.isArray(object?.nfsMounts) ? object.nfsMounts.map((e) => SharedVolumeMount.fromJSON(e)) : [],
      runtimeDebug: isSet3(object.runtimeDebug) ? globalThis.Boolean(object.runtimeDebug) : false,
      blockNetwork: isSet3(object.blockNetwork) ? globalThis.Boolean(object.blockNetwork) : false,
      s3Mounts: globalThis.Array.isArray(object?.s3Mounts) ? object.s3Mounts.map((e) => S3Mount.fromJSON(e)) : [],
      cloudBucketMounts: globalThis.Array.isArray(object?.cloudBucketMounts) ? object.cloudBucketMounts.map((e) => CloudBucketMount.fromJSON(e)) : [],
      volumeMounts: globalThis.Array.isArray(object?.volumeMounts) ? object.volumeMounts.map((e) => VolumeMount.fromJSON(e)) : [],
      ptyInfo: isSet3(object.ptyInfo) ? PTYInfo.fromJSON(object.ptyInfo) : void 0,
      schedulerPlacement: isSet3(object.schedulerPlacement) ? SchedulerPlacement.fromJSON(object.schedulerPlacement) : void 0,
      workerId: isSet3(object.workerId) ? globalThis.String(object.workerId) : "",
      openPorts: isSet3(object.openPorts) ? PortSpecs.fromJSON(object.openPorts) : void 0,
      i6pnEnabled: isSet3(object.i6pnEnabled) ? globalThis.Boolean(object.i6pnEnabled) : false,
      networkAccess: isSet3(object.networkAccess) ? NetworkAccess.fromJSON(object.networkAccess) : void 0,
      proxyId: isSet3(object.proxyId) ? globalThis.String(object.proxyId) : void 0,
      enableSnapshot: isSet3(object.enableSnapshot) ? globalThis.Boolean(object.enableSnapshot) : false,
      snapshotVersion: isSet3(object.snapshotVersion) ? globalThis.Number(object.snapshotVersion) : void 0,
      cloudProviderStr: isSet3(object.cloudProviderStr) ? globalThis.String(object.cloudProviderStr) : "",
      runscRuntimeVersion: isSet3(object.runscRuntimeVersion) ? globalThis.String(object.runscRuntimeVersion) : void 0,
      runtime: isSet3(object.runtime) ? globalThis.String(object.runtime) : void 0,
      verbose: isSet3(object.verbose) ? globalThis.Boolean(object.verbose) : false,
      name: isSet3(object.name) ? globalThis.String(object.name) : void 0,
      experimentalOptions: isObject2(object.experimentalOptions) ? Object.entries(object.experimentalOptions).reduce((acc, [key, value]) => {
        acc[key] = Boolean(value);
        return acc;
      }, {}) : {},
      preloadPathPrefixes: globalThis.Array.isArray(object?.preloadPathPrefixes) ? object.preloadPathPrefixes.map((e) => globalThis.String(e)) : [],
      idleTimeoutSecs: isSet3(object.idleTimeoutSecs) ? globalThis.Number(object.idleTimeoutSecs) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.entrypointArgs?.length) {
      obj.entrypointArgs = message.entrypointArgs;
    }
    if (message.mountIds?.length) {
      obj.mountIds = message.mountIds;
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.secretIds?.length) {
      obj.secretIds = message.secretIds;
    }
    if (message.resources !== void 0) {
      obj.resources = Resources.toJSON(message.resources);
    }
    if (message.cloudProvider !== 0) {
      obj.cloudProvider = cloudProviderToJSON(message.cloudProvider);
    }
    if (message.timeoutSecs !== 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    if (message.workdir !== void 0) {
      obj.workdir = message.workdir;
    }
    if (message.nfsMounts?.length) {
      obj.nfsMounts = message.nfsMounts.map((e) => SharedVolumeMount.toJSON(e));
    }
    if (message.runtimeDebug !== false) {
      obj.runtimeDebug = message.runtimeDebug;
    }
    if (message.blockNetwork !== false) {
      obj.blockNetwork = message.blockNetwork;
    }
    if (message.s3Mounts?.length) {
      obj.s3Mounts = message.s3Mounts.map((e) => S3Mount.toJSON(e));
    }
    if (message.cloudBucketMounts?.length) {
      obj.cloudBucketMounts = message.cloudBucketMounts.map((e) => CloudBucketMount.toJSON(e));
    }
    if (message.volumeMounts?.length) {
      obj.volumeMounts = message.volumeMounts.map((e) => VolumeMount.toJSON(e));
    }
    if (message.ptyInfo !== void 0) {
      obj.ptyInfo = PTYInfo.toJSON(message.ptyInfo);
    }
    if (message.schedulerPlacement !== void 0) {
      obj.schedulerPlacement = SchedulerPlacement.toJSON(message.schedulerPlacement);
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.openPorts !== void 0) {
      obj.openPorts = PortSpecs.toJSON(message.openPorts);
    }
    if (message.i6pnEnabled !== false) {
      obj.i6pnEnabled = message.i6pnEnabled;
    }
    if (message.networkAccess !== void 0) {
      obj.networkAccess = NetworkAccess.toJSON(message.networkAccess);
    }
    if (message.proxyId !== void 0) {
      obj.proxyId = message.proxyId;
    }
    if (message.enableSnapshot !== false) {
      obj.enableSnapshot = message.enableSnapshot;
    }
    if (message.snapshotVersion !== void 0) {
      obj.snapshotVersion = Math.round(message.snapshotVersion);
    }
    if (message.cloudProviderStr !== "") {
      obj.cloudProviderStr = message.cloudProviderStr;
    }
    if (message.runscRuntimeVersion !== void 0) {
      obj.runscRuntimeVersion = message.runscRuntimeVersion;
    }
    if (message.runtime !== void 0) {
      obj.runtime = message.runtime;
    }
    if (message.verbose !== false) {
      obj.verbose = message.verbose;
    }
    if (message.name !== void 0) {
      obj.name = message.name;
    }
    if (message.experimentalOptions) {
      const entries = Object.entries(message.experimentalOptions);
      if (entries.length > 0) {
        obj.experimentalOptions = {};
        entries.forEach(([k, v]) => {
          obj.experimentalOptions[k] = v;
        });
      }
    }
    if (message.preloadPathPrefixes?.length) {
      obj.preloadPathPrefixes = message.preloadPathPrefixes;
    }
    if (message.idleTimeoutSecs !== void 0) {
      obj.idleTimeoutSecs = Math.round(message.idleTimeoutSecs);
    }
    return obj;
  },
  create(base) {
    return Sandbox.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandbox();
    message.entrypointArgs = object.entrypointArgs?.map((e) => e) || [];
    message.mountIds = object.mountIds?.map((e) => e) || [];
    message.imageId = object.imageId ?? "";
    message.secretIds = object.secretIds?.map((e) => e) || [];
    message.resources = object.resources !== void 0 && object.resources !== null ? Resources.fromPartial(object.resources) : void 0;
    message.cloudProvider = object.cloudProvider ?? 0;
    message.timeoutSecs = object.timeoutSecs ?? 0;
    message.workdir = object.workdir ?? void 0;
    message.nfsMounts = object.nfsMounts?.map((e) => SharedVolumeMount.fromPartial(e)) || [];
    message.runtimeDebug = object.runtimeDebug ?? false;
    message.blockNetwork = object.blockNetwork ?? false;
    message.s3Mounts = object.s3Mounts?.map((e) => S3Mount.fromPartial(e)) || [];
    message.cloudBucketMounts = object.cloudBucketMounts?.map((e) => CloudBucketMount.fromPartial(e)) || [];
    message.volumeMounts = object.volumeMounts?.map((e) => VolumeMount.fromPartial(e)) || [];
    message.ptyInfo = object.ptyInfo !== void 0 && object.ptyInfo !== null ? PTYInfo.fromPartial(object.ptyInfo) : void 0;
    message.schedulerPlacement = object.schedulerPlacement !== void 0 && object.schedulerPlacement !== null ? SchedulerPlacement.fromPartial(object.schedulerPlacement) : void 0;
    message.workerId = object.workerId ?? "";
    message.openPorts = object.openPorts !== void 0 && object.openPorts !== null ? PortSpecs.fromPartial(object.openPorts) : void 0;
    message.i6pnEnabled = object.i6pnEnabled ?? false;
    message.networkAccess = object.networkAccess !== void 0 && object.networkAccess !== null ? NetworkAccess.fromPartial(object.networkAccess) : void 0;
    message.proxyId = object.proxyId ?? void 0;
    message.enableSnapshot = object.enableSnapshot ?? false;
    message.snapshotVersion = object.snapshotVersion ?? void 0;
    message.cloudProviderStr = object.cloudProviderStr ?? "";
    message.runscRuntimeVersion = object.runscRuntimeVersion ?? void 0;
    message.runtime = object.runtime ?? void 0;
    message.verbose = object.verbose ?? false;
    message.name = object.name ?? void 0;
    message.experimentalOptions = Object.entries(object.experimentalOptions ?? {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = globalThis.Boolean(value);
        }
        return acc;
      },
      {}
    );
    message.preloadPathPrefixes = object.preloadPathPrefixes?.map((e) => e) || [];
    message.idleTimeoutSecs = object.idleTimeoutSecs ?? void 0;
    return message;
  }
};
function createBaseSandbox_ExperimentalOptionsEntry() {
  return { key: "", value: false };
}
var Sandbox_ExperimentalOptionsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandbox_ExperimentalOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.Boolean(object.value) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return Sandbox_ExperimentalOptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandbox_ExperimentalOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? false;
    return message;
  }
};
function createBaseSandboxCreateConnectTokenRequest() {
  return { sandboxId: "", metadata: "" };
}
var SandboxCreateConnectTokenRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.metadata !== "") {
      writer.uint32(18).string(message.metadata);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxCreateConnectTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      metadata: isSet3(object.metadata) ? globalThis.String(object.metadata) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },
  create(base) {
    return SandboxCreateConnectTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxCreateConnectTokenRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.metadata = object.metadata ?? "";
    return message;
  }
};
function createBaseSandboxCreateConnectTokenResponse() {
  return { url: "", token: "" };
}
var SandboxCreateConnectTokenResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxCreateConnectTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      url: isSet3(object.url) ? globalThis.String(object.url) : "",
      token: isSet3(object.token) ? globalThis.String(object.token) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },
  create(base) {
    return SandboxCreateConnectTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxCreateConnectTokenResponse();
    message.url = object.url ?? "";
    message.token = object.token ?? "";
    return message;
  }
};
function createBaseSandboxCreateRequest() {
  return { appId: "", definition: void 0, environmentName: "" };
}
var SandboxCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.definition !== void 0) {
      Sandbox.encode(message.definition, writer.uint32(18).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.definition = Sandbox.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      definition: isSet3(object.definition) ? Sandbox.fromJSON(object.definition) : void 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.definition !== void 0) {
      obj.definition = Sandbox.toJSON(message.definition);
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return SandboxCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxCreateRequest();
    message.appId = object.appId ?? "";
    message.definition = object.definition !== void 0 && object.definition !== null ? Sandbox.fromPartial(object.definition) : void 0;
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseSandboxCreateResponse() {
  return { sandboxId: "" };
}
var SandboxCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxCreateResponse();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxGetFromNameRequest() {
  return { sandboxName: "", environmentName: "", appName: "" };
}
var SandboxGetFromNameRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxName !== "") {
      writer.uint32(10).string(message.sandboxName);
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    if (message.appName !== "") {
      writer.uint32(26).string(message.appName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetFromNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.appName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxName: isSet3(object.sandboxName) ? globalThis.String(object.sandboxName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      appName: isSet3(object.appName) ? globalThis.String(object.appName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxName !== "") {
      obj.sandboxName = message.sandboxName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.appName !== "") {
      obj.appName = message.appName;
    }
    return obj;
  },
  create(base) {
    return SandboxGetFromNameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetFromNameRequest();
    message.sandboxName = object.sandboxName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.appName = object.appName ?? "";
    return message;
  }
};
function createBaseSandboxGetFromNameResponse() {
  return { sandboxId: "" };
}
var SandboxGetFromNameResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetFromNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxGetFromNameResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetFromNameResponse();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxGetLogsRequest() {
  return { sandboxId: "", fileDescriptor: 0, timeout: 0, lastEntryId: "" };
}
var SandboxGetLogsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.fileDescriptor !== 0) {
      writer.uint32(16).int32(message.fileDescriptor);
    }
    if (message.timeout !== 0) {
      writer.uint32(29).float(message.timeout);
    }
    if (message.lastEntryId !== "") {
      writer.uint32(34).string(message.lastEntryId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.fileDescriptor = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.lastEntryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      fileDescriptor: isSet3(object.fileDescriptor) ? fileDescriptorFromJSON(object.fileDescriptor) : 0,
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      lastEntryId: isSet3(object.lastEntryId) ? globalThis.String(object.lastEntryId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.fileDescriptor !== 0) {
      obj.fileDescriptor = fileDescriptorToJSON(message.fileDescriptor);
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.lastEntryId !== "") {
      obj.lastEntryId = message.lastEntryId;
    }
    return obj;
  },
  create(base) {
    return SandboxGetLogsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetLogsRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.fileDescriptor = object.fileDescriptor ?? 0;
    message.timeout = object.timeout ?? 0;
    message.lastEntryId = object.lastEntryId ?? "";
    return message;
  }
};
function createBaseSandboxGetResourceUsageRequest() {
  return { sandboxId: "" };
}
var SandboxGetResourceUsageRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetResourceUsageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxGetResourceUsageRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetResourceUsageRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxGetResourceUsageResponse() {
  return { cpuCoreNanosecs: 0, memGibNanosecs: 0, gpuNanosecs: 0, gpuType: void 0 };
}
var SandboxGetResourceUsageResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cpuCoreNanosecs !== 0) {
      writer.uint32(8).uint64(message.cpuCoreNanosecs);
    }
    if (message.memGibNanosecs !== 0) {
      writer.uint32(16).uint64(message.memGibNanosecs);
    }
    if (message.gpuNanosecs !== 0) {
      writer.uint32(24).uint64(message.gpuNanosecs);
    }
    if (message.gpuType !== void 0) {
      writer.uint32(34).string(message.gpuType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetResourceUsageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.cpuCoreNanosecs = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.memGibNanosecs = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.gpuNanosecs = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.gpuType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cpuCoreNanosecs: isSet3(object.cpuCoreNanosecs) ? globalThis.Number(object.cpuCoreNanosecs) : 0,
      memGibNanosecs: isSet3(object.memGibNanosecs) ? globalThis.Number(object.memGibNanosecs) : 0,
      gpuNanosecs: isSet3(object.gpuNanosecs) ? globalThis.Number(object.gpuNanosecs) : 0,
      gpuType: isSet3(object.gpuType) ? globalThis.String(object.gpuType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cpuCoreNanosecs !== 0) {
      obj.cpuCoreNanosecs = Math.round(message.cpuCoreNanosecs);
    }
    if (message.memGibNanosecs !== 0) {
      obj.memGibNanosecs = Math.round(message.memGibNanosecs);
    }
    if (message.gpuNanosecs !== 0) {
      obj.gpuNanosecs = Math.round(message.gpuNanosecs);
    }
    if (message.gpuType !== void 0) {
      obj.gpuType = message.gpuType;
    }
    return obj;
  },
  create(base) {
    return SandboxGetResourceUsageResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetResourceUsageResponse();
    message.cpuCoreNanosecs = object.cpuCoreNanosecs ?? 0;
    message.memGibNanosecs = object.memGibNanosecs ?? 0;
    message.gpuNanosecs = object.gpuNanosecs ?? 0;
    message.gpuType = object.gpuType ?? void 0;
    return message;
  }
};
function createBaseSandboxGetTaskIdRequest() {
  return { sandboxId: "", timeout: void 0, waitUntilReady: false };
}
var SandboxGetTaskIdRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.timeout !== void 0) {
      writer.uint32(21).float(message.timeout);
    }
    if (message.waitUntilReady !== false) {
      writer.uint32(24).bool(message.waitUntilReady);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetTaskIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.waitUntilReady = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : void 0,
      waitUntilReady: isSet3(object.waitUntilReady) ? globalThis.Boolean(object.waitUntilReady) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.timeout !== void 0) {
      obj.timeout = message.timeout;
    }
    if (message.waitUntilReady !== false) {
      obj.waitUntilReady = message.waitUntilReady;
    }
    return obj;
  },
  create(base) {
    return SandboxGetTaskIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetTaskIdRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.timeout = object.timeout ?? void 0;
    message.waitUntilReady = object.waitUntilReady ?? false;
    return message;
  }
};
function createBaseSandboxGetTaskIdResponse() {
  return { taskId: void 0, taskResult: void 0 };
}
var SandboxGetTaskIdResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== void 0) {
      writer.uint32(10).string(message.taskId);
    }
    if (message.taskResult !== void 0) {
      GenericResult.encode(message.taskResult, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetTaskIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.taskResult = GenericResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : void 0,
      taskResult: isSet3(object.taskResult) ? GenericResult.fromJSON(object.taskResult) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== void 0) {
      obj.taskId = message.taskId;
    }
    if (message.taskResult !== void 0) {
      obj.taskResult = GenericResult.toJSON(message.taskResult);
    }
    return obj;
  },
  create(base) {
    return SandboxGetTaskIdResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetTaskIdResponse();
    message.taskId = object.taskId ?? void 0;
    message.taskResult = object.taskResult !== void 0 && object.taskResult !== null ? GenericResult.fromPartial(object.taskResult) : void 0;
    return message;
  }
};
function createBaseSandboxGetTunnelsRequest() {
  return { sandboxId: "", timeout: 0 };
}
var SandboxGetTunnelsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetTunnelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return SandboxGetTunnelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetTunnelsRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseSandboxGetTunnelsResponse() {
  return { result: void 0, tunnels: [] };
}
var SandboxGetTunnelsResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    for (const v of message.tunnels) {
      TunnelData.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxGetTunnelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.tunnels.push(TunnelData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      tunnels: globalThis.Array.isArray(object?.tunnels) ? object.tunnels.map((e) => TunnelData.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.tunnels?.length) {
      obj.tunnels = message.tunnels.map((e) => TunnelData.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SandboxGetTunnelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxGetTunnelsResponse();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.tunnels = object.tunnels?.map((e) => TunnelData.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSandboxHandleMetadata() {
  return { result: void 0 };
}
var SandboxHandleMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxHandleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    return obj;
  },
  create(base) {
    return SandboxHandleMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxHandleMetadata();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    return message;
  }
};
function createBaseSandboxInfo() {
  return { id: "", createdAt: 0, taskInfo: void 0, appId: "", tags: [], name: "" };
}
var SandboxInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.createdAt !== 0) {
      writer.uint32(25).double(message.createdAt);
    }
    if (message.taskInfo !== void 0) {
      TaskInfo.encode(message.taskInfo, writer.uint32(34).fork()).join();
    }
    if (message.appId !== "") {
      writer.uint32(42).string(message.appId);
    }
    for (const v of message.tags) {
      SandboxTag.encode(v, writer.uint32(50).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.taskInfo = TaskInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.tags.push(SandboxTag.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet3(object.id) ? globalThis.String(object.id) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      taskInfo: isSet3(object.taskInfo) ? TaskInfo.fromJSON(object.taskInfo) : void 0,
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => SandboxTag.fromJSON(e)) : [],
      name: isSet3(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.taskInfo !== void 0) {
      obj.taskInfo = TaskInfo.toJSON(message.taskInfo);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => SandboxTag.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return SandboxInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxInfo();
    message.id = object.id ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.taskInfo = object.taskInfo !== void 0 && object.taskInfo !== null ? TaskInfo.fromPartial(object.taskInfo) : void 0;
    message.appId = object.appId ?? "";
    message.tags = object.tags?.map((e) => SandboxTag.fromPartial(e)) || [];
    message.name = object.name ?? "";
    return message;
  }
};
function createBaseSandboxListRequest() {
  return { appId: "", beforeTimestamp: 0, environmentName: "", includeFinished: false, tags: [] };
}
var SandboxListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.beforeTimestamp !== 0) {
      writer.uint32(17).double(message.beforeTimestamp);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.includeFinished !== false) {
      writer.uint32(32).bool(message.includeFinished);
    }
    for (const v of message.tags) {
      SandboxTag.encode(v, writer.uint32(42).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.beforeTimestamp = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.includeFinished = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.tags.push(SandboxTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      beforeTimestamp: isSet3(object.beforeTimestamp) ? globalThis.Number(object.beforeTimestamp) : 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      includeFinished: isSet3(object.includeFinished) ? globalThis.Boolean(object.includeFinished) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => SandboxTag.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.beforeTimestamp !== 0) {
      obj.beforeTimestamp = message.beforeTimestamp;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.includeFinished !== false) {
      obj.includeFinished = message.includeFinished;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => SandboxTag.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SandboxListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxListRequest();
    message.appId = object.appId ?? "";
    message.beforeTimestamp = object.beforeTimestamp ?? 0;
    message.environmentName = object.environmentName ?? "";
    message.includeFinished = object.includeFinished ?? false;
    message.tags = object.tags?.map((e) => SandboxTag.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSandboxListResponse() {
  return { sandboxes: [] };
}
var SandboxListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.sandboxes) {
      SandboxInfo.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxes.push(SandboxInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxes: globalThis.Array.isArray(object?.sandboxes) ? object.sandboxes.map((e) => SandboxInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxes?.length) {
      obj.sandboxes = message.sandboxes.map((e) => SandboxInfo.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SandboxListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxListResponse();
    message.sandboxes = object.sandboxes?.map((e) => SandboxInfo.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSandboxRestoreRequest() {
  return { snapshotId: "", sandboxNameOverride: "", sandboxNameOverrideType: 0 };
}
var SandboxRestoreRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    if (message.sandboxNameOverride !== "") {
      writer.uint32(18).string(message.sandboxNameOverride);
    }
    if (message.sandboxNameOverrideType !== 0) {
      writer.uint32(24).int32(message.sandboxNameOverrideType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxRestoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.sandboxNameOverride = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.sandboxNameOverrideType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      snapshotId: isSet3(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      sandboxNameOverride: isSet3(object.sandboxNameOverride) ? globalThis.String(object.sandboxNameOverride) : "",
      sandboxNameOverrideType: isSet3(object.sandboxNameOverrideType) ? sandboxRestoreRequest_SandboxNameOverrideTypeFromJSON(object.sandboxNameOverrideType) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.sandboxNameOverride !== "") {
      obj.sandboxNameOverride = message.sandboxNameOverride;
    }
    if (message.sandboxNameOverrideType !== 0) {
      obj.sandboxNameOverrideType = sandboxRestoreRequest_SandboxNameOverrideTypeToJSON(
        message.sandboxNameOverrideType
      );
    }
    return obj;
  },
  create(base) {
    return SandboxRestoreRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxRestoreRequest();
    message.snapshotId = object.snapshotId ?? "";
    message.sandboxNameOverride = object.sandboxNameOverride ?? "";
    message.sandboxNameOverrideType = object.sandboxNameOverrideType ?? 0;
    return message;
  }
};
function createBaseSandboxRestoreResponse() {
  return { sandboxId: "" };
}
var SandboxRestoreResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxRestoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxRestoreResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxRestoreResponse();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotFsAsyncGetRequest() {
  return { imageId: "", timeout: 0 };
}
var SandboxSnapshotFsAsyncGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotFsAsyncGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotFsAsyncGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotFsAsyncGetRequest();
    message.imageId = object.imageId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseSandboxSnapshotFsAsyncRequest() {
  return { sandboxId: "" };
}
var SandboxSnapshotFsAsyncRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotFsAsyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotFsAsyncRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotFsAsyncRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotFsAsyncResponse() {
  return { imageId: "" };
}
var SandboxSnapshotFsAsyncResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotFsAsyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotFsAsyncResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotFsAsyncResponse();
    message.imageId = object.imageId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotFsRequest() {
  return { sandboxId: "", timeout: 0 };
}
var SandboxSnapshotFsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotFsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotFsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotFsRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseSandboxSnapshotFsResponse() {
  return { imageId: "", result: void 0, imageMetadata: void 0 };
}
var SandboxSnapshotFsResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageId !== "") {
      writer.uint32(10).string(message.imageId);
    }
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.imageMetadata !== void 0) {
      ImageMetadata.encode(message.imageMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotFsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.imageMetadata = ImageMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      imageMetadata: isSet3(object.imageMetadata) ? ImageMetadata.fromJSON(object.imageMetadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.imageMetadata !== void 0) {
      obj.imageMetadata = ImageMetadata.toJSON(message.imageMetadata);
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotFsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotFsResponse();
    message.imageId = object.imageId ?? "";
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.imageMetadata = object.imageMetadata !== void 0 && object.imageMetadata !== null ? ImageMetadata.fromPartial(object.imageMetadata) : void 0;
    return message;
  }
};
function createBaseSandboxSnapshotGetRequest() {
  return { snapshotId: "" };
}
var SandboxSnapshotGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { snapshotId: isSet3(object.snapshotId) ? globalThis.String(object.snapshotId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotGetRequest();
    message.snapshotId = object.snapshotId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotGetResponse() {
  return { snapshotId: "" };
}
var SandboxSnapshotGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { snapshotId: isSet3(object.snapshotId) ? globalThis.String(object.snapshotId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotGetResponse();
    message.snapshotId = object.snapshotId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotRequest() {
  return { sandboxId: "" };
}
var SandboxSnapshotRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotResponse() {
  return { snapshotId: "" };
}
var SandboxSnapshotResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { snapshotId: isSet3(object.snapshotId) ? globalThis.String(object.snapshotId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotResponse();
    message.snapshotId = object.snapshotId ?? "";
    return message;
  }
};
function createBaseSandboxSnapshotWaitRequest() {
  return { snapshotId: "", timeout: 0 };
}
var SandboxSnapshotWaitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotWaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapshotId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      snapshotId: isSet3(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotWaitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotWaitRequest();
    message.snapshotId = object.snapshotId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseSandboxSnapshotWaitResponse() {
  return { result: void 0 };
}
var SandboxSnapshotWaitResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxSnapshotWaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    return obj;
  },
  create(base) {
    return SandboxSnapshotWaitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxSnapshotWaitResponse();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    return message;
  }
};
function createBaseSandboxStdinWriteRequest() {
  return { sandboxId: "", input: new Uint8Array(0), index: 0, eof: false };
}
var SandboxStdinWriteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.input.length !== 0) {
      writer.uint32(18).bytes(message.input);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    if (message.eof !== false) {
      writer.uint32(32).bool(message.eof);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxStdinWriteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.input = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.index = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.eof = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      input: isSet3(object.input) ? bytesFromBase64(object.input) : new Uint8Array(0),
      index: isSet3(object.index) ? globalThis.Number(object.index) : 0,
      eof: isSet3(object.eof) ? globalThis.Boolean(object.eof) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.input.length !== 0) {
      obj.input = base64FromBytes(message.input);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.eof !== false) {
      obj.eof = message.eof;
    }
    return obj;
  },
  create(base) {
    return SandboxStdinWriteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxStdinWriteRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.input = object.input ?? new Uint8Array(0);
    message.index = object.index ?? 0;
    message.eof = object.eof ?? false;
    return message;
  }
};
function createBaseSandboxStdinWriteResponse() {
  return {};
}
var SandboxStdinWriteResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxStdinWriteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  create(base) {
    return SandboxStdinWriteResponse.fromPartial(base ?? {});
  },
  fromPartial(_) {
    const message = createBaseSandboxStdinWriteResponse();
    return message;
  }
};
function createBaseSandboxTag() {
  return { tagName: "", tagValue: "" };
}
var SandboxTag = {
  encode(message, writer = new BinaryWriter()) {
    if (message.tagName !== "") {
      writer.uint32(10).string(message.tagName);
    }
    if (message.tagValue !== "") {
      writer.uint32(18).string(message.tagValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tagName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.tagValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tagName: isSet3(object.tagName) ? globalThis.String(object.tagName) : "",
      tagValue: isSet3(object.tagValue) ? globalThis.String(object.tagValue) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tagName !== "") {
      obj.tagName = message.tagName;
    }
    if (message.tagValue !== "") {
      obj.tagValue = message.tagValue;
    }
    return obj;
  },
  create(base) {
    return SandboxTag.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxTag();
    message.tagName = object.tagName ?? "";
    message.tagValue = object.tagValue ?? "";
    return message;
  }
};
function createBaseSandboxTagsGetRequest() {
  return { sandboxId: "" };
}
var SandboxTagsGetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxTagsGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxTagsGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxTagsGetRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxTagsGetResponse() {
  return { tags: [] };
}
var SandboxTagsGetResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.tags) {
      SandboxTag.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxTagsGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tags.push(SandboxTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => SandboxTag.fromJSON(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => SandboxTag.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SandboxTagsGetResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxTagsGetResponse();
    message.tags = object.tags?.map((e) => SandboxTag.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSandboxTagsSetRequest() {
  return { environmentName: "", sandboxId: "", tags: [] };
}
var SandboxTagsSetRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    if (message.sandboxId !== "") {
      writer.uint32(18).string(message.sandboxId);
    }
    for (const v of message.tags) {
      SandboxTag.encode(v, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxTagsSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.tags.push(SandboxTag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => SandboxTag.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => SandboxTag.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SandboxTagsSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxTagsSetRequest();
    message.environmentName = object.environmentName ?? "";
    message.sandboxId = object.sandboxId ?? "";
    message.tags = object.tags?.map((e) => SandboxTag.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSandboxTerminateRequest() {
  return { sandboxId: "" };
}
var SandboxTerminateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxTerminateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    return obj;
  },
  create(base) {
    return SandboxTerminateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxTerminateRequest();
    message.sandboxId = object.sandboxId ?? "";
    return message;
  }
};
function createBaseSandboxTerminateResponse() {
  return { existingResult: void 0 };
}
var SandboxTerminateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.existingResult !== void 0) {
      GenericResult.encode(message.existingResult, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxTerminateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.existingResult = GenericResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { existingResult: isSet3(object.existingResult) ? GenericResult.fromJSON(object.existingResult) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.existingResult !== void 0) {
      obj.existingResult = GenericResult.toJSON(message.existingResult);
    }
    return obj;
  },
  create(base) {
    return SandboxTerminateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxTerminateResponse();
    message.existingResult = object.existingResult !== void 0 && object.existingResult !== null ? GenericResult.fromPartial(object.existingResult) : void 0;
    return message;
  }
};
function createBaseSandboxWaitRequest() {
  return { sandboxId: "", timeout: 0 };
}
var SandboxWaitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sandboxId !== "") {
      writer.uint32(10).string(message.sandboxId);
    }
    if (message.timeout !== 0) {
      writer.uint32(21).float(message.timeout);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxWaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    return obj;
  },
  create(base) {
    return SandboxWaitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxWaitRequest();
    message.sandboxId = object.sandboxId ?? "";
    message.timeout = object.timeout ?? 0;
    return message;
  }
};
function createBaseSandboxWaitResponse() {
  return { result: void 0 };
}
var SandboxWaitResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSandboxWaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    return obj;
  },
  create(base) {
    return SandboxWaitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSandboxWaitResponse();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    return message;
  }
};
function createBaseSchedule() {
  return { cron: void 0, period: void 0 };
}
var Schedule = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cron !== void 0) {
      Schedule_Cron.encode(message.cron, writer.uint32(10).fork()).join();
    }
    if (message.period !== void 0) {
      Schedule_Period.encode(message.period, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cron = Schedule_Cron.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.period = Schedule_Period.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cron: isSet3(object.cron) ? Schedule_Cron.fromJSON(object.cron) : void 0,
      period: isSet3(object.period) ? Schedule_Period.fromJSON(object.period) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cron !== void 0) {
      obj.cron = Schedule_Cron.toJSON(message.cron);
    }
    if (message.period !== void 0) {
      obj.period = Schedule_Period.toJSON(message.period);
    }
    return obj;
  },
  create(base) {
    return Schedule.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSchedule();
    message.cron = object.cron !== void 0 && object.cron !== null ? Schedule_Cron.fromPartial(object.cron) : void 0;
    message.period = object.period !== void 0 && object.period !== null ? Schedule_Period.fromPartial(object.period) : void 0;
    return message;
  }
};
function createBaseSchedule_Cron() {
  return { cronString: "", timezone: "" };
}
var Schedule_Cron = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cronString !== "") {
      writer.uint32(10).string(message.cronString);
    }
    if (message.timezone !== "") {
      writer.uint32(18).string(message.timezone);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSchedule_Cron();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cronString = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      cronString: isSet3(object.cronString) ? globalThis.String(object.cronString) : "",
      timezone: isSet3(object.timezone) ? globalThis.String(object.timezone) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.cronString !== "") {
      obj.cronString = message.cronString;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    return obj;
  },
  create(base) {
    return Schedule_Cron.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSchedule_Cron();
    message.cronString = object.cronString ?? "";
    message.timezone = object.timezone ?? "";
    return message;
  }
};
function createBaseSchedule_Period() {
  return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0 };
}
var Schedule_Period = {
  encode(message, writer = new BinaryWriter()) {
    if (message.years !== 0) {
      writer.uint32(8).int32(message.years);
    }
    if (message.months !== 0) {
      writer.uint32(16).int32(message.months);
    }
    if (message.weeks !== 0) {
      writer.uint32(24).int32(message.weeks);
    }
    if (message.days !== 0) {
      writer.uint32(32).int32(message.days);
    }
    if (message.hours !== 0) {
      writer.uint32(40).int32(message.hours);
    }
    if (message.minutes !== 0) {
      writer.uint32(48).int32(message.minutes);
    }
    if (message.seconds !== 0) {
      writer.uint32(61).float(message.seconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSchedule_Period();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.years = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.months = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.weeks = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.days = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.hours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.minutes = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }
          message.seconds = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      years: isSet3(object.years) ? globalThis.Number(object.years) : 0,
      months: isSet3(object.months) ? globalThis.Number(object.months) : 0,
      weeks: isSet3(object.weeks) ? globalThis.Number(object.weeks) : 0,
      days: isSet3(object.days) ? globalThis.Number(object.days) : 0,
      hours: isSet3(object.hours) ? globalThis.Number(object.hours) : 0,
      minutes: isSet3(object.minutes) ? globalThis.Number(object.minutes) : 0,
      seconds: isSet3(object.seconds) ? globalThis.Number(object.seconds) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.years !== 0) {
      obj.years = Math.round(message.years);
    }
    if (message.months !== 0) {
      obj.months = Math.round(message.months);
    }
    if (message.weeks !== 0) {
      obj.weeks = Math.round(message.weeks);
    }
    if (message.days !== 0) {
      obj.days = Math.round(message.days);
    }
    if (message.hours !== 0) {
      obj.hours = Math.round(message.hours);
    }
    if (message.minutes !== 0) {
      obj.minutes = Math.round(message.minutes);
    }
    if (message.seconds !== 0) {
      obj.seconds = message.seconds;
    }
    return obj;
  },
  create(base) {
    return Schedule_Period.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSchedule_Period();
    message.years = object.years ?? 0;
    message.months = object.months ?? 0;
    message.weeks = object.weeks ?? 0;
    message.days = object.days ?? 0;
    message.hours = object.hours ?? 0;
    message.minutes = object.minutes ?? 0;
    message.seconds = object.seconds ?? 0;
    return message;
  }
};
function createBaseSchedulerPlacement() {
  return { regions: [], Zone: void 0, Lifecycle: void 0, InstanceTypes: [] };
}
var SchedulerPlacement = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.regions) {
      writer.uint32(34).string(v);
    }
    if (message.Zone !== void 0) {
      writer.uint32(18).string(message.Zone);
    }
    if (message.Lifecycle !== void 0) {
      writer.uint32(26).string(message.Lifecycle);
    }
    for (const v of message.InstanceTypes) {
      writer.uint32(42).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSchedulerPlacement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.regions.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.Zone = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.Lifecycle = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.InstanceTypes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e) => globalThis.String(e)) : [],
      Zone: isSet3(object.Zone) ? globalThis.String(object.Zone) : void 0,
      Lifecycle: isSet3(object.Lifecycle) ? globalThis.String(object.Lifecycle) : void 0,
      InstanceTypes: globalThis.Array.isArray(object?.InstanceTypes) ? object.InstanceTypes.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.regions?.length) {
      obj.regions = message.regions;
    }
    if (message.Zone !== void 0) {
      obj.Zone = message.Zone;
    }
    if (message.Lifecycle !== void 0) {
      obj.Lifecycle = message.Lifecycle;
    }
    if (message.InstanceTypes?.length) {
      obj.InstanceTypes = message.InstanceTypes;
    }
    return obj;
  },
  create(base) {
    return SchedulerPlacement.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSchedulerPlacement();
    message.regions = object.regions?.map((e) => e) || [];
    message.Zone = object.Zone ?? void 0;
    message.Lifecycle = object.Lifecycle ?? void 0;
    message.InstanceTypes = object.InstanceTypes?.map((e) => e) || [];
    return message;
  }
};
function createBaseSecretDeleteRequest() {
  return { secretId: "" };
}
var SecretDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.secretId !== "") {
      writer.uint32(10).string(message.secretId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.secretId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { secretId: isSet3(object.secretId) ? globalThis.String(object.secretId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    return obj;
  },
  create(base) {
    return SecretDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretDeleteRequest();
    message.secretId = object.secretId ?? "";
    return message;
  }
};
function createBaseSecretGetOrCreateRequest() {
  return { deploymentName: "", environmentName: "", objectCreationType: 0, envDict: {}, appId: "", requiredKeys: [] };
}
var SecretGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    Object.entries(message.envDict).forEach(([key, value]) => {
      SecretGetOrCreateRequest_EnvDictEntry.encode({ key, value }, writer.uint32(42).fork()).join();
    });
    if (message.appId !== "") {
      writer.uint32(50).string(message.appId);
    }
    for (const v of message.requiredKeys) {
      writer.uint32(58).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          const entry5 = SecretGetOrCreateRequest_EnvDictEntry.decode(reader, reader.uint32());
          if (entry5.value !== void 0) {
            message.envDict[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.requiredKeys.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0,
      envDict: isObject2(object.envDict) ? Object.entries(object.envDict).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {}) : {},
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      requiredKeys: globalThis.Array.isArray(object?.requiredKeys) ? object.requiredKeys.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    if (message.envDict) {
      const entries = Object.entries(message.envDict);
      if (entries.length > 0) {
        obj.envDict = {};
        entries.forEach(([k, v]) => {
          obj.envDict[k] = v;
        });
      }
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.requiredKeys?.length) {
      obj.requiredKeys = message.requiredKeys;
    }
    return obj;
  },
  create(base) {
    return SecretGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    message.envDict = Object.entries(object.envDict ?? {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.appId = object.appId ?? "";
    message.requiredKeys = object.requiredKeys?.map((e) => e) || [];
    return message;
  }
};
function createBaseSecretGetOrCreateRequest_EnvDictEntry() {
  return { key: "", value: "" };
}
var SecretGetOrCreateRequest_EnvDictEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretGetOrCreateRequest_EnvDictEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet3(object.key) ? globalThis.String(object.key) : "",
      value: isSet3(object.value) ? globalThis.String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  create(base) {
    return SecretGetOrCreateRequest_EnvDictEntry.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretGetOrCreateRequest_EnvDictEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseSecretGetOrCreateResponse() {
  return { secretId: "", metadata: void 0 };
}
var SecretGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.secretId !== "") {
      writer.uint32(10).string(message.secretId);
    }
    if (message.metadata !== void 0) {
      SecretMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.secretId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.metadata = SecretMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      secretId: isSet3(object.secretId) ? globalThis.String(object.secretId) : "",
      metadata: isSet3(object.metadata) ? SecretMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = SecretMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return SecretGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretGetOrCreateResponse();
    message.secretId = object.secretId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? SecretMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseSecretListItem() {
  return { label: "", createdAt: 0, lastUsedAt: 0, environmentName: "", secretId: "", metadata: void 0 };
}
var SecretListItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.createdAt !== 0) {
      writer.uint32(17).double(message.createdAt);
    }
    if (message.lastUsedAt !== 0) {
      writer.uint32(25).double(message.lastUsedAt);
    }
    if (message.environmentName !== "") {
      writer.uint32(34).string(message.environmentName);
    }
    if (message.secretId !== "") {
      writer.uint32(42).string(message.secretId);
    }
    if (message.metadata !== void 0) {
      SecretMetadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.lastUsedAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.secretId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.metadata = SecretMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet3(object.label) ? globalThis.String(object.label) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      lastUsedAt: isSet3(object.lastUsedAt) ? globalThis.Number(object.lastUsedAt) : 0,
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      secretId: isSet3(object.secretId) ? globalThis.String(object.secretId) : "",
      metadata: isSet3(object.metadata) ? SecretMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.lastUsedAt !== 0) {
      obj.lastUsedAt = message.lastUsedAt;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.secretId !== "") {
      obj.secretId = message.secretId;
    }
    if (message.metadata !== void 0) {
      obj.metadata = SecretMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return SecretListItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretListItem();
    message.label = object.label ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.lastUsedAt = object.lastUsedAt ?? 0;
    message.environmentName = object.environmentName ?? "";
    message.secretId = object.secretId ?? "";
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? SecretMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseSecretListRequest() {
  return { environmentName: "", pagination: void 0 };
}
var SecretListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    if (message.pagination !== void 0) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      pagination: isSet3(object.pagination) ? ListPagination.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.pagination !== void 0) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },
  create(base) {
    return SecretListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretListRequest();
    message.environmentName = object.environmentName ?? "";
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? ListPagination.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseSecretListResponse() {
  return { items: [], environmentName: "" };
}
var SecretListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      SecretListItem.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(SecretListItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => SecretListItem.fromJSON(e)) : [],
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SecretListItem.toJSON(e));
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return SecretListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretListResponse();
    message.items = object.items?.map((e) => SecretListItem.fromPartial(e)) || [];
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseSecretMetadata() {
  return { name: "", creationInfo: void 0 };
}
var SecretMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.creationInfo !== void 0) {
      CreationInfo.encode(message.creationInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSecretMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.creationInfo = CreationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      creationInfo: isSet3(object.creationInfo) ? CreationInfo.fromJSON(object.creationInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creationInfo !== void 0) {
      obj.creationInfo = CreationInfo.toJSON(message.creationInfo);
    }
    return obj;
  },
  create(base) {
    return SecretMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSecretMetadata();
    message.name = object.name ?? "";
    message.creationInfo = object.creationInfo !== void 0 && object.creationInfo !== null ? CreationInfo.fromPartial(object.creationInfo) : void 0;
    return message;
  }
};
function createBaseSharedVolumeDeleteRequest() {
  return { sharedVolumeId: "" };
}
var SharedVolumeDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeDeleteRequest();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    return message;
  }
};
function createBaseSharedVolumeGetFileRequest() {
  return { sharedVolumeId: "", path: "" };
}
var SharedVolumeGetFileRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeGetFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeGetFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeGetFileRequest();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    message.path = object.path ?? "";
    return message;
  }
};
function createBaseSharedVolumeGetFileResponse() {
  return { data: void 0, dataBlobId: void 0 };
}
var SharedVolumeGetFileResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.data !== void 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      writer.uint32(18).string(message.dataBlobId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeGetFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dataBlobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isSet3(object.data) ? bytesFromBase64(object.data) : void 0,
      dataBlobId: isSet3(object.dataBlobId) ? globalThis.String(object.dataBlobId) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.data !== void 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      obj.dataBlobId = message.dataBlobId;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeGetFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeGetFileResponse();
    message.data = object.data ?? void 0;
    message.dataBlobId = object.dataBlobId ?? void 0;
    return message;
  }
};
function createBaseSharedVolumeGetOrCreateRequest() {
  return { deploymentName: "", environmentName: "", objectCreationType: 0, appId: "" };
}
var SharedVolumeGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    if (message.appId !== "") {
      writer.uint32(42).string(message.appId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0,
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    message.appId = object.appId ?? "";
    return message;
  }
};
function createBaseSharedVolumeGetOrCreateResponse() {
  return { sharedVolumeId: "" };
}
var SharedVolumeGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeGetOrCreateResponse();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    return message;
  }
};
function createBaseSharedVolumeHeartbeatRequest() {
  return { sharedVolumeId: "" };
}
var SharedVolumeHeartbeatRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeHeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeHeartbeatRequest();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    return message;
  }
};
function createBaseSharedVolumeListFilesRequest() {
  return { sharedVolumeId: "", path: "" };
}
var SharedVolumeListFilesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeListFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeListFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeListFilesRequest();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    message.path = object.path ?? "";
    return message;
  }
};
function createBaseSharedVolumeListFilesResponse() {
  return { entries: [] };
}
var SharedVolumeListFilesResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.entries) {
      FileEntry.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeListFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.entries.push(FileEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e) => FileEntry.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => FileEntry.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return SharedVolumeListFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeListFilesResponse();
    message.entries = object.entries?.map((e) => FileEntry.fromPartial(e)) || [];
    return message;
  }
};
function createBaseSharedVolumeListItem() {
  return { label: "", sharedVolumeId: "", createdAt: 0, cloudProvider: 0 };
}
var SharedVolumeListItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.sharedVolumeId !== "") {
      writer.uint32(18).string(message.sharedVolumeId);
    }
    if (message.createdAt !== 0) {
      writer.uint32(25).double(message.createdAt);
    }
    if (message.cloudProvider !== 0) {
      writer.uint32(32).int32(message.cloudProvider);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.cloudProvider = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet3(object.label) ? globalThis.String(object.label) : "",
      sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      cloudProvider: isSet3(object.cloudProvider) ? cloudProviderFromJSON(object.cloudProvider) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.cloudProvider !== 0) {
      obj.cloudProvider = cloudProviderToJSON(message.cloudProvider);
    }
    return obj;
  },
  create(base) {
    return SharedVolumeListItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeListItem();
    message.label = object.label ?? "";
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.cloudProvider = object.cloudProvider ?? 0;
    return message;
  }
};
function createBaseSharedVolumeListRequest() {
  return { environmentName: "" };
}
var SharedVolumeListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeListRequest();
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseSharedVolumeListResponse() {
  return { items: [], environmentName: "" };
}
var SharedVolumeListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      SharedVolumeListItem.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(SharedVolumeListItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => SharedVolumeListItem.fromJSON(e)) : [],
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SharedVolumeListItem.toJSON(e));
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeListResponse();
    message.items = object.items?.map((e) => SharedVolumeListItem.fromPartial(e)) || [];
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseSharedVolumeMount() {
  return { mountPath: "", sharedVolumeId: "", cloudProvider: 0, allowCrossRegion: false };
}
var SharedVolumeMount = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mountPath !== "") {
      writer.uint32(10).string(message.mountPath);
    }
    if (message.sharedVolumeId !== "") {
      writer.uint32(18).string(message.sharedVolumeId);
    }
    if (message.cloudProvider !== 0) {
      writer.uint32(24).int32(message.cloudProvider);
    }
    if (message.allowCrossRegion !== false) {
      writer.uint32(32).bool(message.allowCrossRegion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeMount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.mountPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.cloudProvider = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.allowCrossRegion = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      mountPath: isSet3(object.mountPath) ? globalThis.String(object.mountPath) : "",
      sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "",
      cloudProvider: isSet3(object.cloudProvider) ? cloudProviderFromJSON(object.cloudProvider) : 0,
      allowCrossRegion: isSet3(object.allowCrossRegion) ? globalThis.Boolean(object.allowCrossRegion) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    if (message.cloudProvider !== 0) {
      obj.cloudProvider = cloudProviderToJSON(message.cloudProvider);
    }
    if (message.allowCrossRegion !== false) {
      obj.allowCrossRegion = message.allowCrossRegion;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeMount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeMount();
    message.mountPath = object.mountPath ?? "";
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    message.cloudProvider = object.cloudProvider ?? 0;
    message.allowCrossRegion = object.allowCrossRegion ?? false;
    return message;
  }
};
function createBaseSharedVolumePutFileRequest() {
  return { sharedVolumeId: "", path: "", sha256Hex: "", data: void 0, dataBlobId: void 0, resumable: false };
}
var SharedVolumePutFileRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.sha256Hex !== "") {
      writer.uint32(26).string(message.sha256Hex);
    }
    if (message.data !== void 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      writer.uint32(42).string(message.dataBlobId);
    }
    if (message.resumable !== false) {
      writer.uint32(48).bool(message.resumable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumePutFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.sha256Hex = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.dataBlobId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.resumable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      sha256Hex: isSet3(object.sha256Hex) ? globalThis.String(object.sha256Hex) : "",
      data: isSet3(object.data) ? bytesFromBase64(object.data) : void 0,
      dataBlobId: isSet3(object.dataBlobId) ? globalThis.String(object.dataBlobId) : void 0,
      resumable: isSet3(object.resumable) ? globalThis.Boolean(object.resumable) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.sha256Hex !== "") {
      obj.sha256Hex = message.sha256Hex;
    }
    if (message.data !== void 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      obj.dataBlobId = message.dataBlobId;
    }
    if (message.resumable !== false) {
      obj.resumable = message.resumable;
    }
    return obj;
  },
  create(base) {
    return SharedVolumePutFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumePutFileRequest();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    message.path = object.path ?? "";
    message.sha256Hex = object.sha256Hex ?? "";
    message.data = object.data ?? void 0;
    message.dataBlobId = object.dataBlobId ?? void 0;
    message.resumable = object.resumable ?? false;
    return message;
  }
};
function createBaseSharedVolumePutFileResponse() {
  return { exists: false };
}
var SharedVolumePutFileResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumePutFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { exists: isSet3(object.exists) ? globalThis.Boolean(object.exists) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },
  create(base) {
    return SharedVolumePutFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumePutFileResponse();
    message.exists = object.exists ?? false;
    return message;
  }
};
function createBaseSharedVolumeRemoveFileRequest() {
  return { sharedVolumeId: "", path: "", recursive: false };
}
var SharedVolumeRemoveFileRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sharedVolumeId !== "") {
      writer.uint32(10).string(message.sharedVolumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(24).bool(message.recursive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSharedVolumeRemoveFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sharedVolumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      sharedVolumeId: isSet3(object.sharedVolumeId) ? globalThis.String(object.sharedVolumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sharedVolumeId !== "") {
      obj.sharedVolumeId = message.sharedVolumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },
  create(base) {
    return SharedVolumeRemoveFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSharedVolumeRemoveFileRequest();
    message.sharedVolumeId = object.sharedVolumeId ?? "";
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  }
};
function createBaseSystemErrorMessage() {
  return { errorCode: 0, errorMessage: "" };
}
var SystemErrorMessage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSystemErrorMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.errorCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      errorCode: isSet3(object.errorCode) ? systemErrorCodeFromJSON(object.errorCode) : 0,
      errorMessage: isSet3(object.errorMessage) ? globalThis.String(object.errorMessage) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.errorCode !== 0) {
      obj.errorCode = systemErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },
  create(base) {
    return SystemErrorMessage.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseSystemErrorMessage();
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  }
};
function createBaseTaskClusterHelloRequest() {
  return { taskId: "", containerIp: "" };
}
var TaskClusterHelloRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.containerIp !== "") {
      writer.uint32(18).string(message.containerIp);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskClusterHelloRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.containerIp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      containerIp: isSet3(object.containerIp) ? globalThis.String(object.containerIp) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.containerIp !== "") {
      obj.containerIp = message.containerIp;
    }
    return obj;
  },
  create(base) {
    return TaskClusterHelloRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskClusterHelloRequest();
    message.taskId = object.taskId ?? "";
    message.containerIp = object.containerIp ?? "";
    return message;
  }
};
function createBaseTaskClusterHelloResponse() {
  return { clusterId: "", clusterRank: 0, containerIps: [], containerIpv4Ips: [] };
}
var TaskClusterHelloResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    if (message.clusterRank !== 0) {
      writer.uint32(16).uint32(message.clusterRank);
    }
    for (const v of message.containerIps) {
      writer.uint32(26).string(v);
    }
    for (const v of message.containerIpv4Ips) {
      writer.uint32(34).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskClusterHelloResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.clusterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.clusterRank = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.containerIps.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.containerIpv4Ips.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      clusterId: isSet3(object.clusterId) ? globalThis.String(object.clusterId) : "",
      clusterRank: isSet3(object.clusterRank) ? globalThis.Number(object.clusterRank) : 0,
      containerIps: globalThis.Array.isArray(object?.containerIps) ? object.containerIps.map((e) => globalThis.String(e)) : [],
      containerIpv4Ips: globalThis.Array.isArray(object?.containerIpv4Ips) ? object.containerIpv4Ips.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.clusterRank !== 0) {
      obj.clusterRank = Math.round(message.clusterRank);
    }
    if (message.containerIps?.length) {
      obj.containerIps = message.containerIps;
    }
    if (message.containerIpv4Ips?.length) {
      obj.containerIpv4Ips = message.containerIpv4Ips;
    }
    return obj;
  },
  create(base) {
    return TaskClusterHelloResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskClusterHelloResponse();
    message.clusterId = object.clusterId ?? "";
    message.clusterRank = object.clusterRank ?? 0;
    message.containerIps = object.containerIps?.map((e) => e) || [];
    message.containerIpv4Ips = object.containerIpv4Ips?.map((e) => e) || [];
    return message;
  }
};
function createBaseTaskCurrentInputsResponse() {
  return { inputIds: [] };
}
var TaskCurrentInputsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.inputIds) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskCurrentInputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.inputIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      inputIds: globalThis.Array.isArray(object?.inputIds) ? object.inputIds.map((e) => globalThis.String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.inputIds?.length) {
      obj.inputIds = message.inputIds;
    }
    return obj;
  },
  create(base) {
    return TaskCurrentInputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskCurrentInputsResponse();
    message.inputIds = object.inputIds?.map((e) => e) || [];
    return message;
  }
};
function createBaseTaskGetAutoscalingMetricsRequest() {
  return { taskId: "" };
}
var TaskGetAutoscalingMetricsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskGetAutoscalingMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },
  create(base) {
    return TaskGetAutoscalingMetricsRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskGetAutoscalingMetricsRequest();
    message.taskId = object.taskId ?? "";
    return message;
  }
};
function createBaseTaskGetAutoscalingMetricsResponse() {
  return { metrics: void 0 };
}
var TaskGetAutoscalingMetricsResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.metrics !== void 0) {
      AutoscalingMetrics.encode(message.metrics, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskGetAutoscalingMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.metrics = AutoscalingMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { metrics: isSet3(object.metrics) ? AutoscalingMetrics.fromJSON(object.metrics) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.metrics !== void 0) {
      obj.metrics = AutoscalingMetrics.toJSON(message.metrics);
    }
    return obj;
  },
  create(base) {
    return TaskGetAutoscalingMetricsResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskGetAutoscalingMetricsResponse();
    message.metrics = object.metrics !== void 0 && object.metrics !== null ? AutoscalingMetrics.fromPartial(object.metrics) : void 0;
    return message;
  }
};
function createBaseTaskInfo() {
  return {
    id: "",
    startedAt: 0,
    finishedAt: 0,
    result: void 0,
    enqueuedAt: 0,
    gpuType: "",
    sandboxId: "",
    snapshotBehavior: 0,
    gpuConfig: void 0
  };
}
var TaskInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.startedAt !== 0) {
      writer.uint32(17).double(message.startedAt);
    }
    if (message.finishedAt !== 0) {
      writer.uint32(25).double(message.finishedAt);
    }
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(34).fork()).join();
    }
    if (message.enqueuedAt !== 0) {
      writer.uint32(41).double(message.enqueuedAt);
    }
    if (message.gpuType !== "") {
      writer.uint32(50).string(message.gpuType);
    }
    if (message.sandboxId !== "") {
      writer.uint32(58).string(message.sandboxId);
    }
    if (message.snapshotBehavior !== 0) {
      writer.uint32(64).int32(message.snapshotBehavior);
    }
    if (message.gpuConfig !== void 0) {
      GPUConfig.encode(message.gpuConfig, writer.uint32(74).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.startedAt = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.finishedAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }
          message.enqueuedAt = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.gpuType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.sandboxId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.snapshotBehavior = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.gpuConfig = GPUConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet3(object.id) ? globalThis.String(object.id) : "",
      startedAt: isSet3(object.startedAt) ? globalThis.Number(object.startedAt) : 0,
      finishedAt: isSet3(object.finishedAt) ? globalThis.Number(object.finishedAt) : 0,
      result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0,
      enqueuedAt: isSet3(object.enqueuedAt) ? globalThis.Number(object.enqueuedAt) : 0,
      gpuType: isSet3(object.gpuType) ? globalThis.String(object.gpuType) : "",
      sandboxId: isSet3(object.sandboxId) ? globalThis.String(object.sandboxId) : "",
      snapshotBehavior: isSet3(object.snapshotBehavior) ? taskSnapshotBehaviorFromJSON(object.snapshotBehavior) : 0,
      gpuConfig: isSet3(object.gpuConfig) ? GPUConfig.fromJSON(object.gpuConfig) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.startedAt !== 0) {
      obj.startedAt = message.startedAt;
    }
    if (message.finishedAt !== 0) {
      obj.finishedAt = message.finishedAt;
    }
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    if (message.enqueuedAt !== 0) {
      obj.enqueuedAt = message.enqueuedAt;
    }
    if (message.gpuType !== "") {
      obj.gpuType = message.gpuType;
    }
    if (message.sandboxId !== "") {
      obj.sandboxId = message.sandboxId;
    }
    if (message.snapshotBehavior !== 0) {
      obj.snapshotBehavior = taskSnapshotBehaviorToJSON(message.snapshotBehavior);
    }
    if (message.gpuConfig !== void 0) {
      obj.gpuConfig = GPUConfig.toJSON(message.gpuConfig);
    }
    return obj;
  },
  create(base) {
    return TaskInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskInfo();
    message.id = object.id ?? "";
    message.startedAt = object.startedAt ?? 0;
    message.finishedAt = object.finishedAt ?? 0;
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    message.enqueuedAt = object.enqueuedAt ?? 0;
    message.gpuType = object.gpuType ?? "";
    message.sandboxId = object.sandboxId ?? "";
    message.snapshotBehavior = object.snapshotBehavior ?? 0;
    message.gpuConfig = object.gpuConfig !== void 0 && object.gpuConfig !== null ? GPUConfig.fromPartial(object.gpuConfig) : void 0;
    return message;
  }
};
function createBaseTaskListRequest() {
  return { environmentName: "" };
}
var TaskListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return TaskListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskListRequest();
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseTaskListResponse() {
  return { tasks: [] };
}
var TaskListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.tasks) {
      TaskStats.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tasks.push(TaskStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e) => TaskStats.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => TaskStats.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return TaskListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskListResponse();
    message.tasks = object.tasks?.map((e) => TaskStats.fromPartial(e)) || [];
    return message;
  }
};
function createBaseTaskLogs() {
  return {
    data: "",
    taskState: 0,
    timestamp: 0,
    fileDescriptor: 0,
    taskProgress: void 0,
    functionCallId: "",
    inputId: "",
    timestampNs: 0
  };
}
var TaskLogs = {
  encode(message, writer = new BinaryWriter()) {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.taskState !== 0) {
      writer.uint32(48).int32(message.taskState);
    }
    if (message.timestamp !== 0) {
      writer.uint32(57).double(message.timestamp);
    }
    if (message.fileDescriptor !== 0) {
      writer.uint32(64).int32(message.fileDescriptor);
    }
    if (message.taskProgress !== void 0) {
      TaskProgress.encode(message.taskProgress, writer.uint32(74).fork()).join();
    }
    if (message.functionCallId !== "") {
      writer.uint32(82).string(message.functionCallId);
    }
    if (message.inputId !== "") {
      writer.uint32(90).string(message.inputId);
    }
    if (message.timestampNs !== 0) {
      writer.uint32(96).uint64(message.timestampNs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.data = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.taskState = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }
          message.timestamp = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.fileDescriptor = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.taskProgress = TaskProgress.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.functionCallId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.timestampNs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isSet3(object.data) ? globalThis.String(object.data) : "",
      taskState: isSet3(object.taskState) ? taskStateFromJSON(object.taskState) : 0,
      timestamp: isSet3(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      fileDescriptor: isSet3(object.fileDescriptor) ? fileDescriptorFromJSON(object.fileDescriptor) : 0,
      taskProgress: isSet3(object.taskProgress) ? TaskProgress.fromJSON(object.taskProgress) : void 0,
      functionCallId: isSet3(object.functionCallId) ? globalThis.String(object.functionCallId) : "",
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      timestampNs: isSet3(object.timestampNs) ? globalThis.Number(object.timestampNs) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.taskState !== 0) {
      obj.taskState = taskStateToJSON(message.taskState);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = message.timestamp;
    }
    if (message.fileDescriptor !== 0) {
      obj.fileDescriptor = fileDescriptorToJSON(message.fileDescriptor);
    }
    if (message.taskProgress !== void 0) {
      obj.taskProgress = TaskProgress.toJSON(message.taskProgress);
    }
    if (message.functionCallId !== "") {
      obj.functionCallId = message.functionCallId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.timestampNs !== 0) {
      obj.timestampNs = Math.round(message.timestampNs);
    }
    return obj;
  },
  create(base) {
    return TaskLogs.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskLogs();
    message.data = object.data ?? "";
    message.taskState = object.taskState ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.fileDescriptor = object.fileDescriptor ?? 0;
    message.taskProgress = object.taskProgress !== void 0 && object.taskProgress !== null ? TaskProgress.fromPartial(object.taskProgress) : void 0;
    message.functionCallId = object.functionCallId ?? "";
    message.inputId = object.inputId ?? "";
    message.timestampNs = object.timestampNs ?? 0;
    return message;
  }
};
function createBaseTaskLogsBatch() {
  return {
    taskId: "",
    items: [],
    entryId: "",
    appDone: false,
    functionId: "",
    inputId: "",
    imageId: "",
    eof: false,
    ptyExecId: "",
    rootFunctionId: "",
    ttlDays: 0
  };
}
var TaskLogsBatch = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    for (const v of message.items) {
      TaskLogs.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.entryId !== "") {
      writer.uint32(42).string(message.entryId);
    }
    if (message.appDone !== false) {
      writer.uint32(80).bool(message.appDone);
    }
    if (message.functionId !== "") {
      writer.uint32(90).string(message.functionId);
    }
    if (message.inputId !== "") {
      writer.uint32(98).string(message.inputId);
    }
    if (message.imageId !== "") {
      writer.uint32(106).string(message.imageId);
    }
    if (message.eof !== false) {
      writer.uint32(112).bool(message.eof);
    }
    if (message.ptyExecId !== "") {
      writer.uint32(122).string(message.ptyExecId);
    }
    if (message.rootFunctionId !== "") {
      writer.uint32(130).string(message.rootFunctionId);
    }
    if (message.ttlDays !== 0) {
      writer.uint32(136).uint32(message.ttlDays);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskLogsBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.items.push(TaskLogs.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.entryId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.appDone = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.functionId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.inputId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.imageId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }
          message.eof = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.ptyExecId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.rootFunctionId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }
          message.ttlDays = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => TaskLogs.fromJSON(e)) : [],
      entryId: isSet3(object.entryId) ? globalThis.String(object.entryId) : "",
      appDone: isSet3(object.appDone) ? globalThis.Boolean(object.appDone) : false,
      functionId: isSet3(object.functionId) ? globalThis.String(object.functionId) : "",
      inputId: isSet3(object.inputId) ? globalThis.String(object.inputId) : "",
      imageId: isSet3(object.imageId) ? globalThis.String(object.imageId) : "",
      eof: isSet3(object.eof) ? globalThis.Boolean(object.eof) : false,
      ptyExecId: isSet3(object.ptyExecId) ? globalThis.String(object.ptyExecId) : "",
      rootFunctionId: isSet3(object.rootFunctionId) ? globalThis.String(object.rootFunctionId) : "",
      ttlDays: isSet3(object.ttlDays) ? globalThis.Number(object.ttlDays) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => TaskLogs.toJSON(e));
    }
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.appDone !== false) {
      obj.appDone = message.appDone;
    }
    if (message.functionId !== "") {
      obj.functionId = message.functionId;
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    if (message.eof !== false) {
      obj.eof = message.eof;
    }
    if (message.ptyExecId !== "") {
      obj.ptyExecId = message.ptyExecId;
    }
    if (message.rootFunctionId !== "") {
      obj.rootFunctionId = message.rootFunctionId;
    }
    if (message.ttlDays !== 0) {
      obj.ttlDays = Math.round(message.ttlDays);
    }
    return obj;
  },
  create(base) {
    return TaskLogsBatch.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskLogsBatch();
    message.taskId = object.taskId ?? "";
    message.items = object.items?.map((e) => TaskLogs.fromPartial(e)) || [];
    message.entryId = object.entryId ?? "";
    message.appDone = object.appDone ?? false;
    message.functionId = object.functionId ?? "";
    message.inputId = object.inputId ?? "";
    message.imageId = object.imageId ?? "";
    message.eof = object.eof ?? false;
    message.ptyExecId = object.ptyExecId ?? "";
    message.rootFunctionId = object.rootFunctionId ?? "";
    message.ttlDays = object.ttlDays ?? 0;
    return message;
  }
};
function createBaseTaskProgress() {
  return { len: 0, pos: 0, progressType: 0, description: "" };
}
var TaskProgress = {
  encode(message, writer = new BinaryWriter()) {
    if (message.len !== 0) {
      writer.uint32(8).uint64(message.len);
    }
    if (message.pos !== 0) {
      writer.uint32(16).uint64(message.pos);
    }
    if (message.progressType !== 0) {
      writer.uint32(24).int32(message.progressType);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.len = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.pos = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.progressType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      len: isSet3(object.len) ? globalThis.Number(object.len) : 0,
      pos: isSet3(object.pos) ? globalThis.Number(object.pos) : 0,
      progressType: isSet3(object.progressType) ? progressTypeFromJSON(object.progressType) : 0,
      description: isSet3(object.description) ? globalThis.String(object.description) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    if (message.pos !== 0) {
      obj.pos = Math.round(message.pos);
    }
    if (message.progressType !== 0) {
      obj.progressType = progressTypeToJSON(message.progressType);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },
  create(base) {
    return TaskProgress.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskProgress();
    message.len = object.len ?? 0;
    message.pos = object.pos ?? 0;
    message.progressType = object.progressType ?? 0;
    message.description = object.description ?? "";
    return message;
  }
};
function createBaseTaskResultRequest() {
  return { result: void 0 };
}
var TaskResultRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.result !== void 0) {
      GenericResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.result = GenericResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { result: isSet3(object.result) ? GenericResult.fromJSON(object.result) : void 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.result !== void 0) {
      obj.result = GenericResult.toJSON(message.result);
    }
    return obj;
  },
  create(base) {
    return TaskResultRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskResultRequest();
    message.result = object.result !== void 0 && object.result !== null ? GenericResult.fromPartial(object.result) : void 0;
    return message;
  }
};
function createBaseTaskStats() {
  return { taskId: "", appId: "", appDescription: "", startedAt: 0 };
}
var TaskStats = {
  encode(message, writer = new BinaryWriter()) {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.appId !== "") {
      writer.uint32(18).string(message.appId);
    }
    if (message.appDescription !== "") {
      writer.uint32(26).string(message.appDescription);
    }
    if (message.startedAt !== 0) {
      writer.uint32(33).double(message.startedAt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.appDescription = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }
          message.startedAt = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      taskId: isSet3(object.taskId) ? globalThis.String(object.taskId) : "",
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      appDescription: isSet3(object.appDescription) ? globalThis.String(object.appDescription) : "",
      startedAt: isSet3(object.startedAt) ? globalThis.Number(object.startedAt) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.appDescription !== "") {
      obj.appDescription = message.appDescription;
    }
    if (message.startedAt !== 0) {
      obj.startedAt = message.startedAt;
    }
    return obj;
  },
  create(base) {
    return TaskStats.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskStats();
    message.taskId = object.taskId ?? "";
    message.appId = object.appId ?? "";
    message.appDescription = object.appDescription ?? "";
    message.startedAt = object.startedAt ?? 0;
    return message;
  }
};
function createBaseTaskTemplate() {
  return { rank: 0, resources: void 0, targetConcurrentInputs: 0, maxConcurrentInputs: 0, index: 0 };
}
var TaskTemplate = {
  encode(message, writer = new BinaryWriter()) {
    if (message.rank !== 0) {
      writer.uint32(8).uint32(message.rank);
    }
    if (message.resources !== void 0) {
      Resources.encode(message.resources, writer.uint32(18).fork()).join();
    }
    if (message.targetConcurrentInputs !== 0) {
      writer.uint32(24).uint32(message.targetConcurrentInputs);
    }
    if (message.maxConcurrentInputs !== 0) {
      writer.uint32(32).uint32(message.maxConcurrentInputs);
    }
    if (message.index !== 0) {
      writer.uint32(40).uint32(message.index);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTaskTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.rank = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.resources = Resources.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.targetConcurrentInputs = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.maxConcurrentInputs = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.index = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      rank: isSet3(object.rank) ? globalThis.Number(object.rank) : 0,
      resources: isSet3(object.resources) ? Resources.fromJSON(object.resources) : void 0,
      targetConcurrentInputs: isSet3(object.targetConcurrentInputs) ? globalThis.Number(object.targetConcurrentInputs) : 0,
      maxConcurrentInputs: isSet3(object.maxConcurrentInputs) ? globalThis.Number(object.maxConcurrentInputs) : 0,
      index: isSet3(object.index) ? globalThis.Number(object.index) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.resources !== void 0) {
      obj.resources = Resources.toJSON(message.resources);
    }
    if (message.targetConcurrentInputs !== 0) {
      obj.targetConcurrentInputs = Math.round(message.targetConcurrentInputs);
    }
    if (message.maxConcurrentInputs !== 0) {
      obj.maxConcurrentInputs = Math.round(message.maxConcurrentInputs);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },
  create(base) {
    return TaskTemplate.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTaskTemplate();
    message.rank = object.rank ?? 0;
    message.resources = object.resources !== void 0 && object.resources !== null ? Resources.fromPartial(object.resources) : void 0;
    message.targetConcurrentInputs = object.targetConcurrentInputs ?? 0;
    message.maxConcurrentInputs = object.maxConcurrentInputs ?? 0;
    message.index = object.index ?? 0;
    return message;
  }
};
function createBaseTokenFlowCreateRequest() {
  return { utmSource: "", localhostPort: 0, nextUrl: "" };
}
var TokenFlowCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.utmSource !== "") {
      writer.uint32(26).string(message.utmSource);
    }
    if (message.localhostPort !== 0) {
      writer.uint32(32).int32(message.localhostPort);
    }
    if (message.nextUrl !== "") {
      writer.uint32(42).string(message.nextUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTokenFlowCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.utmSource = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.localhostPort = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.nextUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      utmSource: isSet3(object.utmSource) ? globalThis.String(object.utmSource) : "",
      localhostPort: isSet3(object.localhostPort) ? globalThis.Number(object.localhostPort) : 0,
      nextUrl: isSet3(object.nextUrl) ? globalThis.String(object.nextUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.utmSource !== "") {
      obj.utmSource = message.utmSource;
    }
    if (message.localhostPort !== 0) {
      obj.localhostPort = Math.round(message.localhostPort);
    }
    if (message.nextUrl !== "") {
      obj.nextUrl = message.nextUrl;
    }
    return obj;
  },
  create(base) {
    return TokenFlowCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTokenFlowCreateRequest();
    message.utmSource = object.utmSource ?? "";
    message.localhostPort = object.localhostPort ?? 0;
    message.nextUrl = object.nextUrl ?? "";
    return message;
  }
};
function createBaseTokenFlowCreateResponse() {
  return { tokenFlowId: "", webUrl: "", code: "", waitSecret: "" };
}
var TokenFlowCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.tokenFlowId !== "") {
      writer.uint32(10).string(message.tokenFlowId);
    }
    if (message.webUrl !== "") {
      writer.uint32(18).string(message.webUrl);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.waitSecret !== "") {
      writer.uint32(34).string(message.waitSecret);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTokenFlowCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tokenFlowId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.webUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.waitSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tokenFlowId: isSet3(object.tokenFlowId) ? globalThis.String(object.tokenFlowId) : "",
      webUrl: isSet3(object.webUrl) ? globalThis.String(object.webUrl) : "",
      code: isSet3(object.code) ? globalThis.String(object.code) : "",
      waitSecret: isSet3(object.waitSecret) ? globalThis.String(object.waitSecret) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokenFlowId !== "") {
      obj.tokenFlowId = message.tokenFlowId;
    }
    if (message.webUrl !== "") {
      obj.webUrl = message.webUrl;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.waitSecret !== "") {
      obj.waitSecret = message.waitSecret;
    }
    return obj;
  },
  create(base) {
    return TokenFlowCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTokenFlowCreateResponse();
    message.tokenFlowId = object.tokenFlowId ?? "";
    message.webUrl = object.webUrl ?? "";
    message.code = object.code ?? "";
    message.waitSecret = object.waitSecret ?? "";
    return message;
  }
};
function createBaseTokenFlowWaitRequest() {
  return { timeout: 0, tokenFlowId: "", waitSecret: "" };
}
var TokenFlowWaitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.timeout !== 0) {
      writer.uint32(13).float(message.timeout);
    }
    if (message.tokenFlowId !== "") {
      writer.uint32(18).string(message.tokenFlowId);
    }
    if (message.waitSecret !== "") {
      writer.uint32(26).string(message.waitSecret);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTokenFlowWaitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }
          message.timeout = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.tokenFlowId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.waitSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      timeout: isSet3(object.timeout) ? globalThis.Number(object.timeout) : 0,
      tokenFlowId: isSet3(object.tokenFlowId) ? globalThis.String(object.tokenFlowId) : "",
      waitSecret: isSet3(object.waitSecret) ? globalThis.String(object.waitSecret) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.timeout !== 0) {
      obj.timeout = message.timeout;
    }
    if (message.tokenFlowId !== "") {
      obj.tokenFlowId = message.tokenFlowId;
    }
    if (message.waitSecret !== "") {
      obj.waitSecret = message.waitSecret;
    }
    return obj;
  },
  create(base) {
    return TokenFlowWaitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTokenFlowWaitRequest();
    message.timeout = object.timeout ?? 0;
    message.tokenFlowId = object.tokenFlowId ?? "";
    message.waitSecret = object.waitSecret ?? "";
    return message;
  }
};
function createBaseTokenFlowWaitResponse() {
  return { tokenId: "", tokenSecret: "", timeout: false, workspaceUsername: "" };
}
var TokenFlowWaitResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.tokenId !== "") {
      writer.uint32(10).string(message.tokenId);
    }
    if (message.tokenSecret !== "") {
      writer.uint32(18).string(message.tokenSecret);
    }
    if (message.timeout !== false) {
      writer.uint32(24).bool(message.timeout);
    }
    if (message.workspaceUsername !== "") {
      writer.uint32(34).string(message.workspaceUsername);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTokenFlowWaitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.tokenId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.tokenSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.timeout = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.workspaceUsername = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      tokenId: isSet3(object.tokenId) ? globalThis.String(object.tokenId) : "",
      tokenSecret: isSet3(object.tokenSecret) ? globalThis.String(object.tokenSecret) : "",
      timeout: isSet3(object.timeout) ? globalThis.Boolean(object.timeout) : false,
      workspaceUsername: isSet3(object.workspaceUsername) ? globalThis.String(object.workspaceUsername) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.tokenSecret !== "") {
      obj.tokenSecret = message.tokenSecret;
    }
    if (message.timeout !== false) {
      obj.timeout = message.timeout;
    }
    if (message.workspaceUsername !== "") {
      obj.workspaceUsername = message.workspaceUsername;
    }
    return obj;
  },
  create(base) {
    return TokenFlowWaitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTokenFlowWaitResponse();
    message.tokenId = object.tokenId ?? "";
    message.tokenSecret = object.tokenSecret ?? "";
    message.timeout = object.timeout ?? false;
    message.workspaceUsername = object.workspaceUsername ?? "";
    return message;
  }
};
function createBaseTunnelData() {
  return { host: "", port: 0, unencryptedHost: void 0, unencryptedPort: void 0, containerPort: 0 };
}
var TunnelData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.unencryptedHost !== void 0) {
      writer.uint32(26).string(message.unencryptedHost);
    }
    if (message.unencryptedPort !== void 0) {
      writer.uint32(32).uint32(message.unencryptedPort);
    }
    if (message.containerPort !== 0) {
      writer.uint32(40).uint32(message.containerPort);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTunnelData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.unencryptedHost = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.unencryptedPort = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.containerPort = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      host: isSet3(object.host) ? globalThis.String(object.host) : "",
      port: isSet3(object.port) ? globalThis.Number(object.port) : 0,
      unencryptedHost: isSet3(object.unencryptedHost) ? globalThis.String(object.unencryptedHost) : void 0,
      unencryptedPort: isSet3(object.unencryptedPort) ? globalThis.Number(object.unencryptedPort) : void 0,
      containerPort: isSet3(object.containerPort) ? globalThis.Number(object.containerPort) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.unencryptedHost !== void 0) {
      obj.unencryptedHost = message.unencryptedHost;
    }
    if (message.unencryptedPort !== void 0) {
      obj.unencryptedPort = Math.round(message.unencryptedPort);
    }
    if (message.containerPort !== 0) {
      obj.containerPort = Math.round(message.containerPort);
    }
    return obj;
  },
  create(base) {
    return TunnelData.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTunnelData();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.unencryptedHost = object.unencryptedHost ?? void 0;
    message.unencryptedPort = object.unencryptedPort ?? void 0;
    message.containerPort = object.containerPort ?? 0;
    return message;
  }
};
function createBaseTunnelStartRequest() {
  return { port: 0, unencrypted: false, tunnelType: void 0 };
}
var TunnelStartRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.port !== 0) {
      writer.uint32(8).uint32(message.port);
    }
    if (message.unencrypted !== false) {
      writer.uint32(16).bool(message.unencrypted);
    }
    if (message.tunnelType !== void 0) {
      writer.uint32(24).int32(message.tunnelType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTunnelStartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.unencrypted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.tunnelType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      port: isSet3(object.port) ? globalThis.Number(object.port) : 0,
      unencrypted: isSet3(object.unencrypted) ? globalThis.Boolean(object.unencrypted) : false,
      tunnelType: isSet3(object.tunnelType) ? tunnelTypeFromJSON(object.tunnelType) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.unencrypted !== false) {
      obj.unencrypted = message.unencrypted;
    }
    if (message.tunnelType !== void 0) {
      obj.tunnelType = tunnelTypeToJSON(message.tunnelType);
    }
    return obj;
  },
  create(base) {
    return TunnelStartRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTunnelStartRequest();
    message.port = object.port ?? 0;
    message.unencrypted = object.unencrypted ?? false;
    message.tunnelType = object.tunnelType ?? void 0;
    return message;
  }
};
function createBaseTunnelStartResponse() {
  return { host: "", port: 0, unencryptedHost: void 0, unencryptedPort: void 0 };
}
var TunnelStartResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.unencryptedHost !== void 0) {
      writer.uint32(26).string(message.unencryptedHost);
    }
    if (message.unencryptedPort !== void 0) {
      writer.uint32(32).uint32(message.unencryptedPort);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTunnelStartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.unencryptedHost = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.unencryptedPort = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      host: isSet3(object.host) ? globalThis.String(object.host) : "",
      port: isSet3(object.port) ? globalThis.Number(object.port) : 0,
      unencryptedHost: isSet3(object.unencryptedHost) ? globalThis.String(object.unencryptedHost) : void 0,
      unencryptedPort: isSet3(object.unencryptedPort) ? globalThis.Number(object.unencryptedPort) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.unencryptedHost !== void 0) {
      obj.unencryptedHost = message.unencryptedHost;
    }
    if (message.unencryptedPort !== void 0) {
      obj.unencryptedPort = Math.round(message.unencryptedPort);
    }
    return obj;
  },
  create(base) {
    return TunnelStartResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTunnelStartResponse();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.unencryptedHost = object.unencryptedHost ?? void 0;
    message.unencryptedPort = object.unencryptedPort ?? void 0;
    return message;
  }
};
function createBaseTunnelStopRequest() {
  return { port: 0 };
}
var TunnelStopRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.port !== 0) {
      writer.uint32(8).uint32(message.port);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTunnelStopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.port = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { port: isSet3(object.port) ? globalThis.Number(object.port) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },
  create(base) {
    return TunnelStopRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTunnelStopRequest();
    message.port = object.port ?? 0;
    return message;
  }
};
function createBaseTunnelStopResponse() {
  return { exists: false };
}
var TunnelStopResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTunnelStopResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { exists: isSet3(object.exists) ? globalThis.Boolean(object.exists) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },
  create(base) {
    return TunnelStopResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseTunnelStopResponse();
    message.exists = object.exists ?? false;
    return message;
  }
};
function createBaseUploadUrlList() {
  return { items: [] };
}
var UploadUrlList = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      writer.uint32(10).string(v);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadUrlList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => globalThis.String(e)) : [] };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items;
    }
    return obj;
  },
  create(base) {
    return UploadUrlList.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUploadUrlList();
    message.items = object.items?.map((e) => e) || [];
    return message;
  }
};
function createBaseVolumeCommitRequest() {
  return { volumeId: "" };
}
var VolumeCommitRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeCommitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    return obj;
  },
  create(base) {
    return VolumeCommitRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeCommitRequest();
    message.volumeId = object.volumeId ?? "";
    return message;
  }
};
function createBaseVolumeCommitResponse() {
  return { skipReload: false };
}
var VolumeCommitResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.skipReload !== false) {
      writer.uint32(8).bool(message.skipReload);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeCommitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.skipReload = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { skipReload: isSet3(object.skipReload) ? globalThis.Boolean(object.skipReload) : false };
  },
  toJSON(message) {
    const obj = {};
    if (message.skipReload !== false) {
      obj.skipReload = message.skipReload;
    }
    return obj;
  },
  create(base) {
    return VolumeCommitResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeCommitResponse();
    message.skipReload = object.skipReload ?? false;
    return message;
  }
};
function createBaseVolumeCopyFiles2Request() {
  return { volumeId: "", srcPaths: [], dstPath: "", recursive: false };
}
var VolumeCopyFiles2Request = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    for (const v of message.srcPaths) {
      writer.uint32(18).string(v);
    }
    if (message.dstPath !== "") {
      writer.uint32(26).string(message.dstPath);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeCopyFiles2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.srcPaths.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.dstPath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      srcPaths: globalThis.Array.isArray(object?.srcPaths) ? object.srcPaths.map((e) => globalThis.String(e)) : [],
      dstPath: isSet3(object.dstPath) ? globalThis.String(object.dstPath) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.srcPaths?.length) {
      obj.srcPaths = message.srcPaths;
    }
    if (message.dstPath !== "") {
      obj.dstPath = message.dstPath;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },
  create(base) {
    return VolumeCopyFiles2Request.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeCopyFiles2Request();
    message.volumeId = object.volumeId ?? "";
    message.srcPaths = object.srcPaths?.map((e) => e) || [];
    message.dstPath = object.dstPath ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  }
};
function createBaseVolumeCopyFilesRequest() {
  return { volumeId: "", srcPaths: [], dstPath: "", recursive: false };
}
var VolumeCopyFilesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    for (const v of message.srcPaths) {
      writer.uint32(18).string(v);
    }
    if (message.dstPath !== "") {
      writer.uint32(26).string(message.dstPath);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeCopyFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.srcPaths.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.dstPath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      srcPaths: globalThis.Array.isArray(object?.srcPaths) ? object.srcPaths.map((e) => globalThis.String(e)) : [],
      dstPath: isSet3(object.dstPath) ? globalThis.String(object.dstPath) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.srcPaths?.length) {
      obj.srcPaths = message.srcPaths;
    }
    if (message.dstPath !== "") {
      obj.dstPath = message.dstPath;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },
  create(base) {
    return VolumeCopyFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeCopyFilesRequest();
    message.volumeId = object.volumeId ?? "";
    message.srcPaths = object.srcPaths?.map((e) => e) || [];
    message.dstPath = object.dstPath ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  }
};
function createBaseVolumeDeleteRequest() {
  return { volumeId: "", environmentName: "" };
}
var VolumeDeleteRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return VolumeDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeDeleteRequest();
    message.volumeId = object.volumeId ?? "";
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseVolumeGetFile2Request() {
  return { volumeId: "", path: "", start: 0, len: 0 };
}
var VolumeGetFile2Request = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.start !== 0) {
      writer.uint32(24).uint64(message.start);
    }
    if (message.len !== 0) {
      writer.uint32(32).uint64(message.len);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeGetFile2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.start = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.len = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      start: isSet3(object.start) ? globalThis.Number(object.start) : 0,
      len: isSet3(object.len) ? globalThis.Number(object.len) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },
  create(base) {
    return VolumeGetFile2Request.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeGetFile2Request();
    message.volumeId = object.volumeId ?? "";
    message.path = object.path ?? "";
    message.start = object.start ?? 0;
    message.len = object.len ?? 0;
    return message;
  }
};
function createBaseVolumeGetFile2Response() {
  return { getUrls: [], size: 0, start: 0, len: 0 };
}
var VolumeGetFile2Response = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.getUrls) {
      writer.uint32(10).string(v);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint64(message.size);
    }
    if (message.start !== 0) {
      writer.uint32(24).uint64(message.start);
    }
    if (message.len !== 0) {
      writer.uint32(32).uint64(message.len);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeGetFile2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.getUrls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.start = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.len = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      getUrls: globalThis.Array.isArray(object?.getUrls) ? object.getUrls.map((e) => globalThis.String(e)) : [],
      size: isSet3(object.size) ? globalThis.Number(object.size) : 0,
      start: isSet3(object.start) ? globalThis.Number(object.start) : 0,
      len: isSet3(object.len) ? globalThis.Number(object.len) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.getUrls?.length) {
      obj.getUrls = message.getUrls;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },
  create(base) {
    return VolumeGetFile2Response.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeGetFile2Response();
    message.getUrls = object.getUrls?.map((e) => e) || [];
    message.size = object.size ?? 0;
    message.start = object.start ?? 0;
    message.len = object.len ?? 0;
    return message;
  }
};
function createBaseVolumeGetFileRequest() {
  return { volumeId: "", path: "", start: 0, len: 0 };
}
var VolumeGetFileRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.start !== 0) {
      writer.uint32(24).uint64(message.start);
    }
    if (message.len !== 0) {
      writer.uint32(32).uint64(message.len);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeGetFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.start = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.len = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      start: isSet3(object.start) ? globalThis.Number(object.start) : 0,
      len: isSet3(object.len) ? globalThis.Number(object.len) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },
  create(base) {
    return VolumeGetFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeGetFileRequest();
    message.volumeId = object.volumeId ?? "";
    message.path = object.path ?? "";
    message.start = object.start ?? 0;
    message.len = object.len ?? 0;
    return message;
  }
};
function createBaseVolumeGetFileResponse() {
  return { data: void 0, dataBlobId: void 0, size: 0, start: 0, len: 0 };
}
var VolumeGetFileResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.data !== void 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      writer.uint32(18).string(message.dataBlobId);
    }
    if (message.size !== 0) {
      writer.uint32(24).uint64(message.size);
    }
    if (message.start !== 0) {
      writer.uint32(32).uint64(message.start);
    }
    if (message.len !== 0) {
      writer.uint32(40).uint64(message.len);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeGetFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.dataBlobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.start = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.len = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isSet3(object.data) ? bytesFromBase64(object.data) : void 0,
      dataBlobId: isSet3(object.dataBlobId) ? globalThis.String(object.dataBlobId) : void 0,
      size: isSet3(object.size) ? globalThis.Number(object.size) : 0,
      start: isSet3(object.start) ? globalThis.Number(object.start) : 0,
      len: isSet3(object.len) ? globalThis.Number(object.len) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.data !== void 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataBlobId !== void 0) {
      obj.dataBlobId = message.dataBlobId;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.len !== 0) {
      obj.len = Math.round(message.len);
    }
    return obj;
  },
  create(base) {
    return VolumeGetFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeGetFileResponse();
    message.data = object.data ?? void 0;
    message.dataBlobId = object.dataBlobId ?? void 0;
    message.size = object.size ?? 0;
    message.start = object.start ?? 0;
    message.len = object.len ?? 0;
    return message;
  }
};
function createBaseVolumeGetOrCreateRequest() {
  return { deploymentName: "", environmentName: "", objectCreationType: 0, appId: "", version: 0 };
}
var VolumeGetOrCreateRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.deploymentName !== "") {
      writer.uint32(10).string(message.deploymentName);
    }
    if (message.environmentName !== "") {
      writer.uint32(26).string(message.environmentName);
    }
    if (message.objectCreationType !== 0) {
      writer.uint32(32).int32(message.objectCreationType);
    }
    if (message.appId !== "") {
      writer.uint32(42).string(message.appId);
    }
    if (message.version !== 0) {
      writer.uint32(48).int32(message.version);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeGetOrCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.deploymentName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.objectCreationType = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.version = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      deploymentName: isSet3(object.deploymentName) ? globalThis.String(object.deploymentName) : "",
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      objectCreationType: isSet3(object.objectCreationType) ? objectCreationTypeFromJSON(object.objectCreationType) : 0,
      appId: isSet3(object.appId) ? globalThis.String(object.appId) : "",
      version: isSet3(object.version) ? volumeFsVersionFromJSON(object.version) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.deploymentName !== "") {
      obj.deploymentName = message.deploymentName;
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.objectCreationType !== 0) {
      obj.objectCreationType = objectCreationTypeToJSON(message.objectCreationType);
    }
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.version !== 0) {
      obj.version = volumeFsVersionToJSON(message.version);
    }
    return obj;
  },
  create(base) {
    return VolumeGetOrCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeGetOrCreateRequest();
    message.deploymentName = object.deploymentName ?? "";
    message.environmentName = object.environmentName ?? "";
    message.objectCreationType = object.objectCreationType ?? 0;
    message.appId = object.appId ?? "";
    message.version = object.version ?? 0;
    return message;
  }
};
function createBaseVolumeGetOrCreateResponse() {
  return { volumeId: "", version: 0, metadata: void 0 };
}
var VolumeGetOrCreateResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.metadata !== void 0) {
      VolumeMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeGetOrCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.version = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.metadata = VolumeMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      version: isSet3(object.version) ? volumeFsVersionFromJSON(object.version) : 0,
      metadata: isSet3(object.metadata) ? VolumeMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.version !== 0) {
      obj.version = volumeFsVersionToJSON(message.version);
    }
    if (message.metadata !== void 0) {
      obj.metadata = VolumeMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return VolumeGetOrCreateResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeGetOrCreateResponse();
    message.volumeId = object.volumeId ?? "";
    message.version = object.version ?? 0;
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? VolumeMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseVolumeHeartbeatRequest() {
  return { volumeId: "" };
}
var VolumeHeartbeatRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    return obj;
  },
  create(base) {
    return VolumeHeartbeatRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeHeartbeatRequest();
    message.volumeId = object.volumeId ?? "";
    return message;
  }
};
function createBaseVolumeListFiles2Request() {
  return { volumeId: "", path: "", recursive: false, maxEntries: void 0 };
}
var VolumeListFiles2Request = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    if (message.maxEntries !== void 0) {
      writer.uint32(24).uint32(message.maxEntries);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListFiles2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxEntries = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false,
      maxEntries: isSet3(object.maxEntries) ? globalThis.Number(object.maxEntries) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    if (message.maxEntries !== void 0) {
      obj.maxEntries = Math.round(message.maxEntries);
    }
    return obj;
  },
  create(base) {
    return VolumeListFiles2Request.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListFiles2Request();
    message.volumeId = object.volumeId ?? "";
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    message.maxEntries = object.maxEntries ?? void 0;
    return message;
  }
};
function createBaseVolumeListFiles2Response() {
  return { entries: [] };
}
var VolumeListFiles2Response = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.entries) {
      FileEntry.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListFiles2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.entries.push(FileEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e) => FileEntry.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => FileEntry.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return VolumeListFiles2Response.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListFiles2Response();
    message.entries = object.entries?.map((e) => FileEntry.fromPartial(e)) || [];
    return message;
  }
};
function createBaseVolumeListFilesRequest() {
  return { volumeId: "", path: "", recursive: false, maxEntries: void 0 };
}
var VolumeListFilesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    if (message.maxEntries !== void 0) {
      writer.uint32(24).uint32(message.maxEntries);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxEntries = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false,
      maxEntries: isSet3(object.maxEntries) ? globalThis.Number(object.maxEntries) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    if (message.maxEntries !== void 0) {
      obj.maxEntries = Math.round(message.maxEntries);
    }
    return obj;
  },
  create(base) {
    return VolumeListFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListFilesRequest();
    message.volumeId = object.volumeId ?? "";
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    message.maxEntries = object.maxEntries ?? void 0;
    return message;
  }
};
function createBaseVolumeListFilesResponse() {
  return { entries: [] };
}
var VolumeListFilesResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.entries) {
      FileEntry.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.entries.push(FileEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e) => FileEntry.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => FileEntry.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return VolumeListFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListFilesResponse();
    message.entries = object.entries?.map((e) => FileEntry.fromPartial(e)) || [];
    return message;
  }
};
function createBaseVolumeListItem() {
  return { label: "", volumeId: "", createdAt: 0, metadata: void 0 };
}
var VolumeListItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.volumeId !== "") {
      writer.uint32(18).string(message.volumeId);
    }
    if (message.createdAt !== 0) {
      writer.uint32(25).double(message.createdAt);
    }
    if (message.metadata !== void 0) {
      VolumeMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.createdAt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.metadata = VolumeMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      label: isSet3(object.label) ? globalThis.String(object.label) : "",
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      createdAt: isSet3(object.createdAt) ? globalThis.Number(object.createdAt) : 0,
      metadata: isSet3(object.metadata) ? VolumeMetadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.createdAt !== 0) {
      obj.createdAt = message.createdAt;
    }
    if (message.metadata !== void 0) {
      obj.metadata = VolumeMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  create(base) {
    return VolumeListItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListItem();
    message.label = object.label ?? "";
    message.volumeId = object.volumeId ?? "";
    message.createdAt = object.createdAt ?? 0;
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? VolumeMetadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
function createBaseVolumeListRequest() {
  return { environmentName: "", pagination: void 0 };
}
var VolumeListRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.environmentName !== "") {
      writer.uint32(10).string(message.environmentName);
    }
    if (message.pagination !== void 0) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : "",
      pagination: isSet3(object.pagination) ? ListPagination.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    if (message.pagination !== void 0) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },
  create(base) {
    return VolumeListRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListRequest();
    message.environmentName = object.environmentName ?? "";
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? ListPagination.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseVolumeListResponse() {
  return { items: [], environmentName: "" };
}
var VolumeListResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.items) {
      VolumeListItem.encode(v, writer.uint32(10).fork()).join();
    }
    if (message.environmentName !== "") {
      writer.uint32(18).string(message.environmentName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.items.push(VolumeListItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.environmentName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e) => VolumeListItem.fromJSON(e)) : [],
      environmentName: isSet3(object.environmentName) ? globalThis.String(object.environmentName) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => VolumeListItem.toJSON(e));
    }
    if (message.environmentName !== "") {
      obj.environmentName = message.environmentName;
    }
    return obj;
  },
  create(base) {
    return VolumeListResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeListResponse();
    message.items = object.items?.map((e) => VolumeListItem.fromPartial(e)) || [];
    message.environmentName = object.environmentName ?? "";
    return message;
  }
};
function createBaseVolumeMetadata() {
  return { version: 0, name: "", creationInfo: void 0 };
}
var VolumeMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.creationInfo !== void 0) {
      CreationInfo.encode(message.creationInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.version = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.creationInfo = CreationInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      version: isSet3(object.version) ? volumeFsVersionFromJSON(object.version) : 0,
      name: isSet3(object.name) ? globalThis.String(object.name) : "",
      creationInfo: isSet3(object.creationInfo) ? CreationInfo.fromJSON(object.creationInfo) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.version !== 0) {
      obj.version = volumeFsVersionToJSON(message.version);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.creationInfo !== void 0) {
      obj.creationInfo = CreationInfo.toJSON(message.creationInfo);
    }
    return obj;
  },
  create(base) {
    return VolumeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeMetadata();
    message.version = object.version ?? 0;
    message.name = object.name ?? "";
    message.creationInfo = object.creationInfo !== void 0 && object.creationInfo !== null ? CreationInfo.fromPartial(object.creationInfo) : void 0;
    return message;
  }
};
function createBaseVolumeMount() {
  return { volumeId: "", mountPath: "", allowBackgroundCommits: false, readOnly: false };
}
var VolumeMount = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.mountPath !== "") {
      writer.uint32(18).string(message.mountPath);
    }
    if (message.allowBackgroundCommits !== false) {
      writer.uint32(24).bool(message.allowBackgroundCommits);
    }
    if (message.readOnly !== false) {
      writer.uint32(32).bool(message.readOnly);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeMount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mountPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.allowBackgroundCommits = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.readOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      mountPath: isSet3(object.mountPath) ? globalThis.String(object.mountPath) : "",
      allowBackgroundCommits: isSet3(object.allowBackgroundCommits) ? globalThis.Boolean(object.allowBackgroundCommits) : false,
      readOnly: isSet3(object.readOnly) ? globalThis.Boolean(object.readOnly) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.mountPath !== "") {
      obj.mountPath = message.mountPath;
    }
    if (message.allowBackgroundCommits !== false) {
      obj.allowBackgroundCommits = message.allowBackgroundCommits;
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    return obj;
  },
  create(base) {
    return VolumeMount.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeMount();
    message.volumeId = object.volumeId ?? "";
    message.mountPath = object.mountPath ?? "";
    message.allowBackgroundCommits = object.allowBackgroundCommits ?? false;
    message.readOnly = object.readOnly ?? false;
    return message;
  }
};
function createBaseVolumePutFiles2Request() {
  return { volumeId: "", files: [], disallowOverwriteExistingFiles: false };
}
var VolumePutFiles2Request = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    for (const v of message.files) {
      VolumePutFiles2Request_File.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.disallowOverwriteExistingFiles !== false) {
      writer.uint32(24).bool(message.disallowOverwriteExistingFiles);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumePutFiles2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.files.push(VolumePutFiles2Request_File.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.disallowOverwriteExistingFiles = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => VolumePutFiles2Request_File.fromJSON(e)) : [],
      disallowOverwriteExistingFiles: isSet3(object.disallowOverwriteExistingFiles) ? globalThis.Boolean(object.disallowOverwriteExistingFiles) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => VolumePutFiles2Request_File.toJSON(e));
    }
    if (message.disallowOverwriteExistingFiles !== false) {
      obj.disallowOverwriteExistingFiles = message.disallowOverwriteExistingFiles;
    }
    return obj;
  },
  create(base) {
    return VolumePutFiles2Request.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumePutFiles2Request();
    message.volumeId = object.volumeId ?? "";
    message.files = object.files?.map((e) => VolumePutFiles2Request_File.fromPartial(e)) || [];
    message.disallowOverwriteExistingFiles = object.disallowOverwriteExistingFiles ?? false;
    return message;
  }
};
function createBaseVolumePutFiles2Request_File() {
  return { path: "", size: 0, blocks: [], mode: void 0 };
}
var VolumePutFiles2Request_File = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint64(message.size);
    }
    for (const v of message.blocks) {
      VolumePutFiles2Request_Block.encode(v, writer.uint32(26).fork()).join();
    }
    if (message.mode !== void 0) {
      writer.uint32(32).uint32(message.mode);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumePutFiles2Request_File();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.size = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.blocks.push(VolumePutFiles2Request_Block.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.mode = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      size: isSet3(object.size) ? globalThis.Number(object.size) : 0,
      blocks: globalThis.Array.isArray(object?.blocks) ? object.blocks.map((e) => VolumePutFiles2Request_Block.fromJSON(e)) : [],
      mode: isSet3(object.mode) ? globalThis.Number(object.mode) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => VolumePutFiles2Request_Block.toJSON(e));
    }
    if (message.mode !== void 0) {
      obj.mode = Math.round(message.mode);
    }
    return obj;
  },
  create(base) {
    return VolumePutFiles2Request_File.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumePutFiles2Request_File();
    message.path = object.path ?? "";
    message.size = object.size ?? 0;
    message.blocks = object.blocks?.map((e) => VolumePutFiles2Request_Block.fromPartial(e)) || [];
    message.mode = object.mode ?? void 0;
    return message;
  }
};
function createBaseVolumePutFiles2Request_Block() {
  return { contentsSha256: new Uint8Array(0), putResponse: void 0 };
}
var VolumePutFiles2Request_Block = {
  encode(message, writer = new BinaryWriter()) {
    if (message.contentsSha256.length !== 0) {
      writer.uint32(10).bytes(message.contentsSha256);
    }
    if (message.putResponse !== void 0) {
      writer.uint32(18).bytes(message.putResponse);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumePutFiles2Request_Block();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.contentsSha256 = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.putResponse = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      contentsSha256: isSet3(object.contentsSha256) ? bytesFromBase64(object.contentsSha256) : new Uint8Array(0),
      putResponse: isSet3(object.putResponse) ? bytesFromBase64(object.putResponse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.contentsSha256.length !== 0) {
      obj.contentsSha256 = base64FromBytes(message.contentsSha256);
    }
    if (message.putResponse !== void 0) {
      obj.putResponse = base64FromBytes(message.putResponse);
    }
    return obj;
  },
  create(base) {
    return VolumePutFiles2Request_Block.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumePutFiles2Request_Block();
    message.contentsSha256 = object.contentsSha256 ?? new Uint8Array(0);
    message.putResponse = object.putResponse ?? void 0;
    return message;
  }
};
function createBaseVolumePutFiles2Response() {
  return { missingBlocks: [] };
}
var VolumePutFiles2Response = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.missingBlocks) {
      VolumePutFiles2Response_MissingBlock.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumePutFiles2Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.missingBlocks.push(VolumePutFiles2Response_MissingBlock.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      missingBlocks: globalThis.Array.isArray(object?.missingBlocks) ? object.missingBlocks.map((e) => VolumePutFiles2Response_MissingBlock.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.missingBlocks?.length) {
      obj.missingBlocks = message.missingBlocks.map((e) => VolumePutFiles2Response_MissingBlock.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return VolumePutFiles2Response.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumePutFiles2Response();
    message.missingBlocks = object.missingBlocks?.map((e) => VolumePutFiles2Response_MissingBlock.fromPartial(e)) || [];
    return message;
  }
};
function createBaseVolumePutFiles2Response_MissingBlock() {
  return { fileIndex: 0, blockIndex: 0, putUrl: "" };
}
var VolumePutFiles2Response_MissingBlock = {
  encode(message, writer = new BinaryWriter()) {
    if (message.fileIndex !== 0) {
      writer.uint32(8).uint64(message.fileIndex);
    }
    if (message.blockIndex !== 0) {
      writer.uint32(16).uint64(message.blockIndex);
    }
    if (message.putUrl !== "") {
      writer.uint32(26).string(message.putUrl);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumePutFiles2Response_MissingBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.fileIndex = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.blockIndex = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.putUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      fileIndex: isSet3(object.fileIndex) ? globalThis.Number(object.fileIndex) : 0,
      blockIndex: isSet3(object.blockIndex) ? globalThis.Number(object.blockIndex) : 0,
      putUrl: isSet3(object.putUrl) ? globalThis.String(object.putUrl) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.fileIndex !== 0) {
      obj.fileIndex = Math.round(message.fileIndex);
    }
    if (message.blockIndex !== 0) {
      obj.blockIndex = Math.round(message.blockIndex);
    }
    if (message.putUrl !== "") {
      obj.putUrl = message.putUrl;
    }
    return obj;
  },
  create(base) {
    return VolumePutFiles2Response_MissingBlock.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumePutFiles2Response_MissingBlock();
    message.fileIndex = object.fileIndex ?? 0;
    message.blockIndex = object.blockIndex ?? 0;
    message.putUrl = object.putUrl ?? "";
    return message;
  }
};
function createBaseVolumePutFilesRequest() {
  return { volumeId: "", files: [], disallowOverwriteExistingFiles: false };
}
var VolumePutFilesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    for (const v of message.files) {
      MountFile.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.disallowOverwriteExistingFiles !== false) {
      writer.uint32(24).bool(message.disallowOverwriteExistingFiles);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumePutFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.files.push(MountFile.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.disallowOverwriteExistingFiles = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => MountFile.fromJSON(e)) : [],
      disallowOverwriteExistingFiles: isSet3(object.disallowOverwriteExistingFiles) ? globalThis.Boolean(object.disallowOverwriteExistingFiles) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => MountFile.toJSON(e));
    }
    if (message.disallowOverwriteExistingFiles !== false) {
      obj.disallowOverwriteExistingFiles = message.disallowOverwriteExistingFiles;
    }
    return obj;
  },
  create(base) {
    return VolumePutFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumePutFilesRequest();
    message.volumeId = object.volumeId ?? "";
    message.files = object.files?.map((e) => MountFile.fromPartial(e)) || [];
    message.disallowOverwriteExistingFiles = object.disallowOverwriteExistingFiles ?? false;
    return message;
  }
};
function createBaseVolumeReloadRequest() {
  return { volumeId: "" };
}
var VolumeReloadRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeReloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "" };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    return obj;
  },
  create(base) {
    return VolumeReloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeReloadRequest();
    message.volumeId = object.volumeId ?? "";
    return message;
  }
};
function createBaseVolumeRemoveFile2Request() {
  return { volumeId: "", path: "", recursive: false };
}
var VolumeRemoveFile2Request = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(24).bool(message.recursive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeRemoveFile2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },
  create(base) {
    return VolumeRemoveFile2Request.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeRemoveFile2Request();
    message.volumeId = object.volumeId ?? "";
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  }
};
function createBaseVolumeRemoveFileRequest() {
  return { volumeId: "", path: "", recursive: false };
}
var VolumeRemoveFileRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.recursive !== false) {
      writer.uint32(24).bool(message.recursive);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeRemoveFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.recursive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      path: isSet3(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet3(object.recursive) ? globalThis.Boolean(object.recursive) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },
  create(base) {
    return VolumeRemoveFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeRemoveFileRequest();
    message.volumeId = object.volumeId ?? "";
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  }
};
function createBaseVolumeRenameRequest() {
  return { volumeId: "", name: "" };
}
var VolumeRenameRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.volumeId !== "") {
      writer.uint32(10).string(message.volumeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVolumeRenameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.volumeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      volumeId: isSet3(object.volumeId) ? globalThis.String(object.volumeId) : "",
      name: isSet3(object.name) ? globalThis.String(object.name) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },
  create(base) {
    return VolumeRenameRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseVolumeRenameRequest();
    message.volumeId = object.volumeId ?? "";
    message.name = object.name ?? "";
    return message;
  }
};
function createBaseWarning() {
  return { type: 0, message: "" };
}
var Warning = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet3(object.type) ? warning_WarningTypeFromJSON(object.type) : 0,
      message: isSet3(object.message) ? globalThis.String(object.message) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = warning_WarningTypeToJSON(message.type);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return Warning.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWarning();
    message.type = object.type ?? 0;
    message.message = object.message ?? "";
    return message;
  }
};
function createBaseWebUrlInfo() {
  return { truncated: false, hasUniqueHash: false, labelStolen: false };
}
var WebUrlInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.truncated !== false) {
      writer.uint32(8).bool(message.truncated);
    }
    if (message.hasUniqueHash !== false) {
      writer.uint32(16).bool(message.hasUniqueHash);
    }
    if (message.labelStolen !== false) {
      writer.uint32(24).bool(message.labelStolen);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWebUrlInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.truncated = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.hasUniqueHash = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.labelStolen = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      truncated: isSet3(object.truncated) ? globalThis.Boolean(object.truncated) : false,
      hasUniqueHash: isSet3(object.hasUniqueHash) ? globalThis.Boolean(object.hasUniqueHash) : false,
      labelStolen: isSet3(object.labelStolen) ? globalThis.Boolean(object.labelStolen) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.truncated !== false) {
      obj.truncated = message.truncated;
    }
    if (message.hasUniqueHash !== false) {
      obj.hasUniqueHash = message.hasUniqueHash;
    }
    if (message.labelStolen !== false) {
      obj.labelStolen = message.labelStolen;
    }
    return obj;
  },
  create(base) {
    return WebUrlInfo.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWebUrlInfo();
    message.truncated = object.truncated ?? false;
    message.hasUniqueHash = object.hasUniqueHash ?? false;
    message.labelStolen = object.labelStolen ?? false;
    return message;
  }
};
function createBaseWebhookConfig() {
  return {
    type: 0,
    method: "",
    requestedSuffix: "",
    asyncMode: 0,
    customDomains: [],
    webServerPort: 0,
    webServerStartupTimeout: 0,
    webEndpointDocs: false,
    requiresProxyAuth: false
  };
}
var WebhookConfig = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.method !== "") {
      writer.uint32(18).string(message.method);
    }
    if (message.requestedSuffix !== "") {
      writer.uint32(34).string(message.requestedSuffix);
    }
    if (message.asyncMode !== 0) {
      writer.uint32(40).int32(message.asyncMode);
    }
    for (const v of message.customDomains) {
      CustomDomainConfig.encode(v, writer.uint32(50).fork()).join();
    }
    if (message.webServerPort !== 0) {
      writer.uint32(56).uint32(message.webServerPort);
    }
    if (message.webServerStartupTimeout !== 0) {
      writer.uint32(69).float(message.webServerStartupTimeout);
    }
    if (message.webEndpointDocs !== false) {
      writer.uint32(72).bool(message.webEndpointDocs);
    }
    if (message.requiresProxyAuth !== false) {
      writer.uint32(80).bool(message.requiresProxyAuth);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWebhookConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.method = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.requestedSuffix = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.asyncMode = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.customDomains.push(CustomDomainConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.webServerPort = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }
          message.webServerStartupTimeout = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.webEndpointDocs = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.requiresProxyAuth = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet3(object.type) ? webhookTypeFromJSON(object.type) : 0,
      method: isSet3(object.method) ? globalThis.String(object.method) : "",
      requestedSuffix: isSet3(object.requestedSuffix) ? globalThis.String(object.requestedSuffix) : "",
      asyncMode: isSet3(object.asyncMode) ? webhookAsyncModeFromJSON(object.asyncMode) : 0,
      customDomains: globalThis.Array.isArray(object?.customDomains) ? object.customDomains.map((e) => CustomDomainConfig.fromJSON(e)) : [],
      webServerPort: isSet3(object.webServerPort) ? globalThis.Number(object.webServerPort) : 0,
      webServerStartupTimeout: isSet3(object.webServerStartupTimeout) ? globalThis.Number(object.webServerStartupTimeout) : 0,
      webEndpointDocs: isSet3(object.webEndpointDocs) ? globalThis.Boolean(object.webEndpointDocs) : false,
      requiresProxyAuth: isSet3(object.requiresProxyAuth) ? globalThis.Boolean(object.requiresProxyAuth) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.type !== 0) {
      obj.type = webhookTypeToJSON(message.type);
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.requestedSuffix !== "") {
      obj.requestedSuffix = message.requestedSuffix;
    }
    if (message.asyncMode !== 0) {
      obj.asyncMode = webhookAsyncModeToJSON(message.asyncMode);
    }
    if (message.customDomains?.length) {
      obj.customDomains = message.customDomains.map((e) => CustomDomainConfig.toJSON(e));
    }
    if (message.webServerPort !== 0) {
      obj.webServerPort = Math.round(message.webServerPort);
    }
    if (message.webServerStartupTimeout !== 0) {
      obj.webServerStartupTimeout = message.webServerStartupTimeout;
    }
    if (message.webEndpointDocs !== false) {
      obj.webEndpointDocs = message.webEndpointDocs;
    }
    if (message.requiresProxyAuth !== false) {
      obj.requiresProxyAuth = message.requiresProxyAuth;
    }
    return obj;
  },
  create(base) {
    return WebhookConfig.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWebhookConfig();
    message.type = object.type ?? 0;
    message.method = object.method ?? "";
    message.requestedSuffix = object.requestedSuffix ?? "";
    message.asyncMode = object.asyncMode ?? 0;
    message.customDomains = object.customDomains?.map((e) => CustomDomainConfig.fromPartial(e)) || [];
    message.webServerPort = object.webServerPort ?? 0;
    message.webServerStartupTimeout = object.webServerStartupTimeout ?? 0;
    message.webEndpointDocs = object.webEndpointDocs ?? false;
    message.requiresProxyAuth = object.requiresProxyAuth ?? false;
    return message;
  }
};
function createBaseWorkspaceNameLookupResponse() {
  return { workspaceName: "", username: "" };
}
var WorkspaceNameLookupResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.workspaceName !== "") {
      writer.uint32(10).string(message.workspaceName);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceNameLookupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.workspaceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      workspaceName: isSet3(object.workspaceName) ? globalThis.String(object.workspaceName) : "",
      username: isSet3(object.username) ? globalThis.String(object.username) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.workspaceName !== "") {
      obj.workspaceName = message.workspaceName;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },
  create(base) {
    return WorkspaceNameLookupResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseWorkspaceNameLookupResponse();
    message.workspaceName = object.workspaceName ?? "";
    message.username = object.username ?? "";
    return message;
  }
};
var ModalClientDefinition = {
  name: "ModalClient",
  fullName: "modal.client.ModalClient",
  methods: {
    /** Apps */
    appClientDisconnect: {
      name: "AppClientDisconnect",
      requestType: AppClientDisconnectRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    appCreate: {
      name: "AppCreate",
      requestType: AppCreateRequest,
      requestStream: false,
      responseType: AppCreateResponse,
      responseStream: false,
      options: {}
    },
    appDeploy: {
      name: "AppDeploy",
      requestType: AppDeployRequest,
      requestStream: false,
      responseType: AppDeployResponse,
      responseStream: false,
      options: {}
    },
    appDeploymentHistory: {
      name: "AppDeploymentHistory",
      requestType: AppDeploymentHistoryRequest,
      requestStream: false,
      responseType: AppDeploymentHistoryResponse,
      responseStream: false,
      options: {}
    },
    appGetByDeploymentName: {
      name: "AppGetByDeploymentName",
      requestType: AppGetByDeploymentNameRequest,
      requestStream: false,
      responseType: AppGetByDeploymentNameResponse,
      responseStream: false,
      options: {}
    },
    appGetLayout: {
      name: "AppGetLayout",
      requestType: AppGetLayoutRequest,
      requestStream: false,
      responseType: AppGetLayoutResponse,
      responseStream: false,
      options: {}
    },
    appGetLogs: {
      name: "AppGetLogs",
      requestType: AppGetLogsRequest,
      requestStream: false,
      responseType: TaskLogsBatch,
      responseStream: true,
      options: {}
    },
    appGetObjects: {
      name: "AppGetObjects",
      requestType: AppGetObjectsRequest,
      requestStream: false,
      responseType: AppGetObjectsResponse,
      responseStream: false,
      options: {}
    },
    appGetOrCreate: {
      name: "AppGetOrCreate",
      requestType: AppGetOrCreateRequest,
      requestStream: false,
      responseType: AppGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    appHeartbeat: {
      name: "AppHeartbeat",
      requestType: AppHeartbeatRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    appList: {
      name: "AppList",
      requestType: AppListRequest,
      requestStream: false,
      responseType: AppListResponse,
      responseStream: false,
      options: {}
    },
    appLookup: {
      name: "AppLookup",
      requestType: AppLookupRequest,
      requestStream: false,
      responseType: AppLookupResponse,
      responseStream: false,
      options: {}
    },
    appPublish: {
      name: "AppPublish",
      requestType: AppPublishRequest,
      requestStream: false,
      responseType: AppPublishResponse,
      responseStream: false,
      options: {}
    },
    appRollback: {
      name: "AppRollback",
      requestType: AppRollbackRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    appSetObjects: {
      name: "AppSetObjects",
      requestType: AppSetObjectsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    appStop: {
      name: "AppStop",
      requestType: AppStopRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Input Plane */
    attemptAwait: {
      name: "AttemptAwait",
      requestType: AttemptAwaitRequest,
      requestStream: false,
      responseType: AttemptAwaitResponse,
      responseStream: false,
      options: {}
    },
    attemptRetry: {
      name: "AttemptRetry",
      requestType: AttemptRetryRequest,
      requestStream: false,
      responseType: AttemptRetryResponse,
      responseStream: false,
      options: {}
    },
    attemptStart: {
      name: "AttemptStart",
      requestType: AttemptStartRequest,
      requestStream: false,
      responseType: AttemptStartResponse,
      responseStream: false,
      options: {}
    },
    /** Auth Token */
    authTokenGet: {
      name: "AuthTokenGet",
      requestType: AuthTokenGetRequest,
      requestStream: false,
      responseType: AuthTokenGetResponse,
      responseStream: false,
      options: {}
    },
    /** Blobs */
    blobCreate: {
      name: "BlobCreate",
      requestType: BlobCreateRequest,
      requestStream: false,
      responseType: BlobCreateResponse,
      responseStream: false,
      options: {}
    },
    blobGet: {
      name: "BlobGet",
      requestType: BlobGetRequest,
      requestStream: false,
      responseType: BlobGetResponse,
      responseStream: false,
      options: {}
    },
    /** Classes */
    classCreate: {
      name: "ClassCreate",
      requestType: ClassCreateRequest,
      requestStream: false,
      responseType: ClassCreateResponse,
      responseStream: false,
      options: {}
    },
    classGet: {
      name: "ClassGet",
      requestType: ClassGetRequest,
      requestStream: false,
      responseType: ClassGetResponse,
      responseStream: false,
      options: {}
    },
    /** Clients */
    clientHello: {
      name: "ClientHello",
      requestType: Empty,
      requestStream: false,
      responseType: ClientHelloResponse,
      responseStream: false,
      options: {}
    },
    /** Clusters */
    clusterGet: {
      name: "ClusterGet",
      requestType: ClusterGetRequest,
      requestStream: false,
      responseType: ClusterGetResponse,
      responseStream: false,
      options: {}
    },
    clusterList: {
      name: "ClusterList",
      requestType: ClusterListRequest,
      requestStream: false,
      responseType: ClusterListResponse,
      responseStream: false,
      options: {}
    },
    /** Container */
    containerCheckpoint: {
      name: "ContainerCheckpoint",
      requestType: ContainerCheckpointRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    containerExec: {
      name: "ContainerExec",
      requestType: ContainerExecRequest,
      requestStream: false,
      responseType: ContainerExecResponse,
      responseStream: false,
      options: {}
    },
    containerExecGetOutput: {
      name: "ContainerExecGetOutput",
      requestType: ContainerExecGetOutputRequest,
      requestStream: false,
      responseType: RuntimeOutputBatch,
      responseStream: true,
      options: {}
    },
    containerExecPutInput: {
      name: "ContainerExecPutInput",
      requestType: ContainerExecPutInputRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    containerExecWait: {
      name: "ContainerExecWait",
      requestType: ContainerExecWaitRequest,
      requestStream: false,
      responseType: ContainerExecWaitResponse,
      responseStream: false,
      options: {}
    },
    containerFilesystemExec: {
      name: "ContainerFilesystemExec",
      requestType: ContainerFilesystemExecRequest,
      requestStream: false,
      responseType: ContainerFilesystemExecResponse,
      responseStream: false,
      options: {}
    },
    containerFilesystemExecGetOutput: {
      name: "ContainerFilesystemExecGetOutput",
      requestType: ContainerFilesystemExecGetOutputRequest,
      requestStream: false,
      responseType: FilesystemRuntimeOutputBatch,
      responseStream: true,
      options: {}
    },
    containerHeartbeat: {
      name: "ContainerHeartbeat",
      requestType: ContainerHeartbeatRequest,
      requestStream: false,
      responseType: ContainerHeartbeatResponse,
      responseStream: false,
      options: {}
    },
    containerHello: {
      name: "ContainerHello",
      requestType: Empty,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    containerLog: {
      name: "ContainerLog",
      requestType: ContainerLogRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    containerReloadVolumes: {
      name: "ContainerReloadVolumes",
      requestType: ContainerReloadVolumesRequest,
      requestStream: false,
      responseType: ContainerReloadVolumesResponse,
      responseStream: false,
      options: {}
    },
    containerStop: {
      name: "ContainerStop",
      requestType: ContainerStopRequest,
      requestStream: false,
      responseType: ContainerStopResponse,
      responseStream: false,
      options: {}
    },
    /** Dicts */
    dictClear: {
      name: "DictClear",
      requestType: DictClearRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    dictContains: {
      name: "DictContains",
      requestType: DictContainsRequest,
      requestStream: false,
      responseType: DictContainsResponse,
      responseStream: false,
      options: {}
    },
    dictContents: {
      name: "DictContents",
      requestType: DictContentsRequest,
      requestStream: false,
      responseType: DictEntry,
      responseStream: true,
      options: {}
    },
    dictDelete: {
      name: "DictDelete",
      requestType: DictDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    dictGet: {
      name: "DictGet",
      requestType: DictGetRequest,
      requestStream: false,
      responseType: DictGetResponse,
      responseStream: false,
      options: {}
    },
    dictGetOrCreate: {
      name: "DictGetOrCreate",
      requestType: DictGetOrCreateRequest,
      requestStream: false,
      responseType: DictGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    dictHeartbeat: {
      name: "DictHeartbeat",
      requestType: DictHeartbeatRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    dictLen: {
      name: "DictLen",
      requestType: DictLenRequest,
      requestStream: false,
      responseType: DictLenResponse,
      responseStream: false,
      options: {}
    },
    dictList: {
      name: "DictList",
      requestType: DictListRequest,
      requestStream: false,
      responseType: DictListResponse,
      responseStream: false,
      options: {}
    },
    dictPop: {
      name: "DictPop",
      requestType: DictPopRequest,
      requestStream: false,
      responseType: DictPopResponse,
      responseStream: false,
      options: {}
    },
    dictUpdate: {
      name: "DictUpdate",
      requestType: DictUpdateRequest,
      requestStream: false,
      responseType: DictUpdateResponse,
      responseStream: false,
      options: {}
    },
    /** Domains */
    domainCertificateVerify: {
      name: "DomainCertificateVerify",
      requestType: DomainCertificateVerifyRequest,
      requestStream: false,
      responseType: DomainCertificateVerifyResponse,
      responseStream: false,
      options: {}
    },
    domainCreate: {
      name: "DomainCreate",
      requestType: DomainCreateRequest,
      requestStream: false,
      responseType: DomainCreateResponse,
      responseStream: false,
      options: {}
    },
    domainList: {
      name: "DomainList",
      requestType: DomainListRequest,
      requestStream: false,
      responseType: DomainListResponse,
      responseStream: false,
      options: {}
    },
    /** Environments */
    environmentCreate: {
      name: "EnvironmentCreate",
      requestType: EnvironmentCreateRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    environmentDelete: {
      name: "EnvironmentDelete",
      requestType: EnvironmentDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    environmentGetOrCreate: {
      name: "EnvironmentGetOrCreate",
      requestType: EnvironmentGetOrCreateRequest,
      requestStream: false,
      responseType: EnvironmentGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    environmentList: {
      name: "EnvironmentList",
      requestType: Empty,
      requestStream: false,
      responseType: EnvironmentListResponse,
      responseStream: false,
      options: {}
    },
    environmentUpdate: {
      name: "EnvironmentUpdate",
      requestType: EnvironmentUpdateRequest,
      requestStream: false,
      responseType: EnvironmentListItem,
      responseStream: false,
      options: {}
    },
    /** Modal Flash (experimental) */
    flashContainerDeregister: {
      name: "FlashContainerDeregister",
      requestType: FlashContainerDeregisterRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    flashContainerList: {
      name: "FlashContainerList",
      requestType: FlashContainerListRequest,
      requestStream: false,
      responseType: FlashContainerListResponse,
      responseStream: false,
      options: {}
    },
    flashContainerRegister: {
      name: "FlashContainerRegister",
      requestType: FlashContainerRegisterRequest,
      requestStream: false,
      responseType: FlashContainerRegisterResponse,
      responseStream: false,
      options: {}
    },
    /** Functions */
    functionAsyncInvoke: {
      name: "FunctionAsyncInvoke",
      requestType: FunctionAsyncInvokeRequest,
      requestStream: false,
      responseType: FunctionAsyncInvokeResponse,
      responseStream: false,
      options: {}
    },
    functionBindParams: {
      name: "FunctionBindParams",
      requestType: FunctionBindParamsRequest,
      requestStream: false,
      responseType: FunctionBindParamsResponse,
      responseStream: false,
      options: {}
    },
    functionCallCancel: {
      name: "FunctionCallCancel",
      requestType: FunctionCallCancelRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    functionCallFromId: {
      name: "FunctionCallFromId",
      requestType: FunctionCallFromIdRequest,
      requestStream: false,
      responseType: FunctionCallFromIdResponse,
      responseStream: false,
      options: {}
    },
    functionCallGetDataIn: {
      name: "FunctionCallGetDataIn",
      requestType: FunctionCallGetDataRequest,
      requestStream: false,
      responseType: DataChunk,
      responseStream: true,
      options: {}
    },
    functionCallGetDataOut: {
      name: "FunctionCallGetDataOut",
      requestType: FunctionCallGetDataRequest,
      requestStream: false,
      responseType: DataChunk,
      responseStream: true,
      options: {}
    },
    functionCallList: {
      name: "FunctionCallList",
      requestType: FunctionCallListRequest,
      requestStream: false,
      responseType: FunctionCallListResponse,
      responseStream: false,
      options: {}
    },
    functionCallPutDataOut: {
      name: "FunctionCallPutDataOut",
      requestType: FunctionCallPutDataRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    functionCreate: {
      name: "FunctionCreate",
      requestType: FunctionCreateRequest,
      requestStream: false,
      responseType: FunctionCreateResponse,
      responseStream: false,
      options: {}
    },
    /** For map RPCs, to signal that all inputs have been sent */
    functionFinishInputs: {
      name: "FunctionFinishInputs",
      requestType: FunctionFinishInputsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    functionGet: {
      name: "FunctionGet",
      requestType: FunctionGetRequest,
      requestStream: false,
      responseType: FunctionGetResponse,
      responseStream: false,
      options: {}
    },
    functionGetCallGraph: {
      name: "FunctionGetCallGraph",
      requestType: FunctionGetCallGraphRequest,
      requestStream: false,
      responseType: FunctionGetCallGraphResponse,
      responseStream: false,
      options: {}
    },
    functionGetCurrentStats: {
      name: "FunctionGetCurrentStats",
      requestType: FunctionGetCurrentStatsRequest,
      requestStream: false,
      responseType: FunctionStats,
      responseStream: false,
      options: {}
    },
    functionGetDynamicConcurrency: {
      name: "FunctionGetDynamicConcurrency",
      requestType: FunctionGetDynamicConcurrencyRequest,
      requestStream: false,
      responseType: FunctionGetDynamicConcurrencyResponse,
      responseStream: false,
      options: {}
    },
    /** For containers to request next call */
    functionGetInputs: {
      name: "FunctionGetInputs",
      requestType: FunctionGetInputsRequest,
      requestStream: false,
      responseType: FunctionGetInputsResponse,
      responseStream: false,
      options: {}
    },
    /** Returns the next result(s) for an entire function call (FunctionMap) */
    functionGetOutputs: {
      name: "FunctionGetOutputs",
      requestType: FunctionGetOutputsRequest,
      requestStream: false,
      responseType: FunctionGetOutputsResponse,
      responseStream: false,
      options: {}
    },
    functionGetSerialized: {
      name: "FunctionGetSerialized",
      requestType: FunctionGetSerializedRequest,
      requestStream: false,
      responseType: FunctionGetSerializedResponse,
      responseStream: false,
      options: {}
    },
    functionMap: {
      name: "FunctionMap",
      requestType: FunctionMapRequest,
      requestStream: false,
      responseType: FunctionMapResponse,
      responseStream: false,
      options: {}
    },
    functionPrecreate: {
      name: "FunctionPrecreate",
      requestType: FunctionPrecreateRequest,
      requestStream: false,
      responseType: FunctionPrecreateResponse,
      responseStream: false,
      options: {}
    },
    functionPutInputs: {
      name: "FunctionPutInputs",
      requestType: FunctionPutInputsRequest,
      requestStream: false,
      responseType: FunctionPutInputsResponse,
      responseStream: false,
      options: {}
    },
    /** For containers to return result */
    functionPutOutputs: {
      name: "FunctionPutOutputs",
      requestType: FunctionPutOutputsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    functionRetryInputs: {
      name: "FunctionRetryInputs",
      requestType: FunctionRetryInputsRequest,
      requestStream: false,
      responseType: FunctionRetryInputsResponse,
      responseStream: false,
      options: {}
    },
    functionStartPtyShell: {
      name: "FunctionStartPtyShell",
      requestType: Empty,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    functionUpdateSchedulingParams: {
      name: "FunctionUpdateSchedulingParams",
      requestType: FunctionUpdateSchedulingParamsRequest,
      requestStream: false,
      responseType: FunctionUpdateSchedulingParamsResponse,
      responseStream: false,
      options: {}
    },
    /** Images */
    imageDelete: {
      name: "ImageDelete",
      requestType: ImageDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    imageFromId: {
      name: "ImageFromId",
      requestType: ImageFromIdRequest,
      requestStream: false,
      responseType: ImageFromIdResponse,
      responseStream: false,
      options: {}
    },
    imageGetOrCreate: {
      name: "ImageGetOrCreate",
      requestType: ImageGetOrCreateRequest,
      requestStream: false,
      responseType: ImageGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    imageJoinStreaming: {
      name: "ImageJoinStreaming",
      requestType: ImageJoinStreamingRequest,
      requestStream: false,
      responseType: ImageJoinStreamingResponse,
      responseStream: true,
      options: {}
    },
    /** Input Plane Map */
    mapAwait: {
      name: "MapAwait",
      requestType: MapAwaitRequest,
      requestStream: false,
      responseType: MapAwaitResponse,
      responseStream: false,
      options: {}
    },
    mapCheckInputs: {
      name: "MapCheckInputs",
      requestType: MapCheckInputsRequest,
      requestStream: false,
      responseType: MapCheckInputsResponse,
      responseStream: false,
      options: {}
    },
    mapStartOrContinue: {
      name: "MapStartOrContinue",
      requestType: MapStartOrContinueRequest,
      requestStream: false,
      responseType: MapStartOrContinueResponse,
      responseStream: false,
      options: {}
    },
    /** Mounts */
    mountGetOrCreate: {
      name: "MountGetOrCreate",
      requestType: MountGetOrCreateRequest,
      requestStream: false,
      responseType: MountGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    mountPutFile: {
      name: "MountPutFile",
      requestType: MountPutFileRequest,
      requestStream: false,
      responseType: MountPutFileResponse,
      responseStream: false,
      options: {}
    },
    /** Notebooks */
    notebookKernelPublishResults: {
      name: "NotebookKernelPublishResults",
      requestType: NotebookKernelPublishResultsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Proxies */
    proxyAddIp: {
      name: "ProxyAddIp",
      requestType: ProxyAddIpRequest,
      requestStream: false,
      responseType: ProxyAddIpResponse,
      responseStream: false,
      options: {}
    },
    proxyCreate: {
      name: "ProxyCreate",
      requestType: ProxyCreateRequest,
      requestStream: false,
      responseType: ProxyCreateResponse,
      responseStream: false,
      options: {}
    },
    proxyDelete: {
      name: "ProxyDelete",
      requestType: ProxyDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    proxyGet: {
      name: "ProxyGet",
      requestType: ProxyGetRequest,
      requestStream: false,
      responseType: ProxyGetResponse,
      responseStream: false,
      options: {}
    },
    proxyGetOrCreate: {
      name: "ProxyGetOrCreate",
      requestType: ProxyGetOrCreateRequest,
      requestStream: false,
      responseType: ProxyGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    proxyList: {
      name: "ProxyList",
      requestType: Empty,
      requestStream: false,
      responseType: ProxyListResponse,
      responseStream: false,
      options: {}
    },
    proxyRemoveIp: {
      name: "ProxyRemoveIp",
      requestType: ProxyRemoveIpRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Queues */
    queueClear: {
      name: "QueueClear",
      requestType: QueueClearRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    queueDelete: {
      name: "QueueDelete",
      requestType: QueueDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    queueGet: {
      name: "QueueGet",
      requestType: QueueGetRequest,
      requestStream: false,
      responseType: QueueGetResponse,
      responseStream: false,
      options: {}
    },
    queueGetOrCreate: {
      name: "QueueGetOrCreate",
      requestType: QueueGetOrCreateRequest,
      requestStream: false,
      responseType: QueueGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    queueHeartbeat: {
      name: "QueueHeartbeat",
      requestType: QueueHeartbeatRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    queueLen: {
      name: "QueueLen",
      requestType: QueueLenRequest,
      requestStream: false,
      responseType: QueueLenResponse,
      responseStream: false,
      options: {}
    },
    queueList: {
      name: "QueueList",
      requestType: QueueListRequest,
      requestStream: false,
      responseType: QueueListResponse,
      responseStream: false,
      options: {}
    },
    queueNextItems: {
      name: "QueueNextItems",
      requestType: QueueNextItemsRequest,
      requestStream: false,
      responseType: QueueNextItemsResponse,
      responseStream: false,
      options: {}
    },
    queuePut: {
      name: "QueuePut",
      requestType: QueuePutRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Sandboxes */
    sandboxCreate: {
      name: "SandboxCreate",
      requestType: SandboxCreateRequest,
      requestStream: false,
      responseType: SandboxCreateResponse,
      responseStream: false,
      options: {}
    },
    sandboxCreateConnectToken: {
      name: "SandboxCreateConnectToken",
      requestType: SandboxCreateConnectTokenRequest,
      requestStream: false,
      responseType: SandboxCreateConnectTokenResponse,
      responseStream: false,
      options: {}
    },
    sandboxGetFromName: {
      name: "SandboxGetFromName",
      requestType: SandboxGetFromNameRequest,
      requestStream: false,
      responseType: SandboxGetFromNameResponse,
      responseStream: false,
      options: {}
    },
    sandboxGetLogs: {
      name: "SandboxGetLogs",
      requestType: SandboxGetLogsRequest,
      requestStream: false,
      responseType: TaskLogsBatch,
      responseStream: true,
      options: {}
    },
    sandboxGetResourceUsage: {
      name: "SandboxGetResourceUsage",
      requestType: SandboxGetResourceUsageRequest,
      requestStream: false,
      responseType: SandboxGetResourceUsageResponse,
      responseStream: false,
      options: {}
    },
    /** needed for modal container exec */
    sandboxGetTaskId: {
      name: "SandboxGetTaskId",
      requestType: SandboxGetTaskIdRequest,
      requestStream: false,
      responseType: SandboxGetTaskIdResponse,
      responseStream: false,
      options: {}
    },
    sandboxGetTunnels: {
      name: "SandboxGetTunnels",
      requestType: SandboxGetTunnelsRequest,
      requestStream: false,
      responseType: SandboxGetTunnelsResponse,
      responseStream: false,
      options: {}
    },
    sandboxList: {
      name: "SandboxList",
      requestType: SandboxListRequest,
      requestStream: false,
      responseType: SandboxListResponse,
      responseStream: false,
      options: {}
    },
    sandboxRestore: {
      name: "SandboxRestore",
      requestType: SandboxRestoreRequest,
      requestStream: false,
      responseType: SandboxRestoreResponse,
      responseStream: false,
      options: {}
    },
    sandboxSnapshot: {
      name: "SandboxSnapshot",
      requestType: SandboxSnapshotRequest,
      requestStream: false,
      responseType: SandboxSnapshotResponse,
      responseStream: false,
      options: {}
    },
    sandboxSnapshotFs: {
      name: "SandboxSnapshotFs",
      requestType: SandboxSnapshotFsRequest,
      requestStream: false,
      responseType: SandboxSnapshotFsResponse,
      responseStream: false,
      options: {}
    },
    sandboxSnapshotFsAsync: {
      name: "SandboxSnapshotFsAsync",
      requestType: SandboxSnapshotFsAsyncRequest,
      requestStream: false,
      responseType: SandboxSnapshotFsAsyncResponse,
      responseStream: false,
      options: {}
    },
    sandboxSnapshotFsAsyncGet: {
      name: "SandboxSnapshotFsAsyncGet",
      requestType: SandboxSnapshotFsAsyncGetRequest,
      requestStream: false,
      responseType: SandboxSnapshotFsResponse,
      responseStream: false,
      options: {}
    },
    sandboxSnapshotGet: {
      name: "SandboxSnapshotGet",
      requestType: SandboxSnapshotGetRequest,
      requestStream: false,
      responseType: SandboxSnapshotGetResponse,
      responseStream: false,
      options: {}
    },
    sandboxSnapshotWait: {
      name: "SandboxSnapshotWait",
      requestType: SandboxSnapshotWaitRequest,
      requestStream: false,
      responseType: SandboxSnapshotWaitResponse,
      responseStream: false,
      options: {}
    },
    sandboxStdinWrite: {
      name: "SandboxStdinWrite",
      requestType: SandboxStdinWriteRequest,
      requestStream: false,
      responseType: SandboxStdinWriteResponse,
      responseStream: false,
      options: {}
    },
    sandboxTagsGet: {
      name: "SandboxTagsGet",
      requestType: SandboxTagsGetRequest,
      requestStream: false,
      responseType: SandboxTagsGetResponse,
      responseStream: false,
      options: {}
    },
    sandboxTagsSet: {
      name: "SandboxTagsSet",
      requestType: SandboxTagsSetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    sandboxTerminate: {
      name: "SandboxTerminate",
      requestType: SandboxTerminateRequest,
      requestStream: false,
      responseType: SandboxTerminateResponse,
      responseStream: false,
      options: {}
    },
    sandboxWait: {
      name: "SandboxWait",
      requestType: SandboxWaitRequest,
      requestStream: false,
      responseType: SandboxWaitResponse,
      responseStream: false,
      options: {}
    },
    /** Secrets */
    secretDelete: {
      name: "SecretDelete",
      requestType: SecretDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    secretGetOrCreate: {
      name: "SecretGetOrCreate",
      requestType: SecretGetOrCreateRequest,
      requestStream: false,
      responseType: SecretGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    secretList: {
      name: "SecretList",
      requestType: SecretListRequest,
      requestStream: false,
      responseType: SecretListResponse,
      responseStream: false,
      options: {}
    },
    /** SharedVolumes */
    sharedVolumeDelete: {
      name: "SharedVolumeDelete",
      requestType: SharedVolumeDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    sharedVolumeGetFile: {
      name: "SharedVolumeGetFile",
      requestType: SharedVolumeGetFileRequest,
      requestStream: false,
      responseType: SharedVolumeGetFileResponse,
      responseStream: false,
      options: {}
    },
    sharedVolumeGetOrCreate: {
      name: "SharedVolumeGetOrCreate",
      requestType: SharedVolumeGetOrCreateRequest,
      requestStream: false,
      responseType: SharedVolumeGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    sharedVolumeHeartbeat: {
      name: "SharedVolumeHeartbeat",
      requestType: SharedVolumeHeartbeatRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    sharedVolumeList: {
      name: "SharedVolumeList",
      requestType: SharedVolumeListRequest,
      requestStream: false,
      responseType: SharedVolumeListResponse,
      responseStream: false,
      options: {}
    },
    sharedVolumeListFiles: {
      name: "SharedVolumeListFiles",
      requestType: SharedVolumeListFilesRequest,
      requestStream: false,
      responseType: SharedVolumeListFilesResponse,
      responseStream: false,
      options: {}
    },
    sharedVolumeListFilesStream: {
      name: "SharedVolumeListFilesStream",
      requestType: SharedVolumeListFilesRequest,
      requestStream: false,
      responseType: SharedVolumeListFilesResponse,
      responseStream: true,
      options: {}
    },
    sharedVolumePutFile: {
      name: "SharedVolumePutFile",
      requestType: SharedVolumePutFileRequest,
      requestStream: false,
      responseType: SharedVolumePutFileResponse,
      responseStream: false,
      options: {}
    },
    sharedVolumeRemoveFile: {
      name: "SharedVolumeRemoveFile",
      requestType: SharedVolumeRemoveFileRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Tasks */
    taskClusterHello: {
      name: "TaskClusterHello",
      requestType: TaskClusterHelloRequest,
      requestStream: false,
      responseType: TaskClusterHelloResponse,
      responseStream: false,
      options: {}
    },
    taskCurrentInputs: {
      name: "TaskCurrentInputs",
      requestType: Empty,
      requestStream: false,
      responseType: TaskCurrentInputsResponse,
      responseStream: false,
      options: {}
    },
    /** Used for flash autoscaling */
    taskGetAutoscalingMetrics: {
      name: "TaskGetAutoscalingMetrics",
      requestType: TaskGetAutoscalingMetricsRequest,
      requestStream: false,
      responseType: TaskGetAutoscalingMetricsResponse,
      responseStream: false,
      options: {}
    },
    taskList: {
      name: "TaskList",
      requestType: TaskListRequest,
      requestStream: false,
      responseType: TaskListResponse,
      responseStream: false,
      options: {}
    },
    taskResult: {
      name: "TaskResult",
      requestType: TaskResultRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Tokens (web auth flow) */
    tokenFlowCreate: {
      name: "TokenFlowCreate",
      requestType: TokenFlowCreateRequest,
      requestStream: false,
      responseType: TokenFlowCreateResponse,
      responseStream: false,
      options: {}
    },
    tokenFlowWait: {
      name: "TokenFlowWait",
      requestType: TokenFlowWaitRequest,
      requestStream: false,
      responseType: TokenFlowWaitResponse,
      responseStream: false,
      options: {}
    },
    /** Tunnels */
    tunnelStart: {
      name: "TunnelStart",
      requestType: TunnelStartRequest,
      requestStream: false,
      responseType: TunnelStartResponse,
      responseStream: false,
      options: {}
    },
    tunnelStop: {
      name: "TunnelStop",
      requestType: TunnelStopRequest,
      requestStream: false,
      responseType: TunnelStopResponse,
      responseStream: false,
      options: {}
    },
    /** Volumes */
    volumeCommit: {
      name: "VolumeCommit",
      requestType: VolumeCommitRequest,
      requestStream: false,
      responseType: VolumeCommitResponse,
      responseStream: false,
      options: {}
    },
    volumeCopyFiles: {
      name: "VolumeCopyFiles",
      requestType: VolumeCopyFilesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeCopyFiles2: {
      name: "VolumeCopyFiles2",
      requestType: VolumeCopyFiles2Request,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeDelete: {
      name: "VolumeDelete",
      requestType: VolumeDeleteRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeGetFile: {
      name: "VolumeGetFile",
      requestType: VolumeGetFileRequest,
      requestStream: false,
      responseType: VolumeGetFileResponse,
      responseStream: false,
      options: {}
    },
    volumeGetFile2: {
      name: "VolumeGetFile2",
      requestType: VolumeGetFile2Request,
      requestStream: false,
      responseType: VolumeGetFile2Response,
      responseStream: false,
      options: {}
    },
    volumeGetOrCreate: {
      name: "VolumeGetOrCreate",
      requestType: VolumeGetOrCreateRequest,
      requestStream: false,
      responseType: VolumeGetOrCreateResponse,
      responseStream: false,
      options: {}
    },
    volumeHeartbeat: {
      name: "VolumeHeartbeat",
      requestType: VolumeHeartbeatRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeList: {
      name: "VolumeList",
      requestType: VolumeListRequest,
      requestStream: false,
      responseType: VolumeListResponse,
      responseStream: false,
      options: {}
    },
    volumeListFiles: {
      name: "VolumeListFiles",
      requestType: VolumeListFilesRequest,
      requestStream: false,
      responseType: VolumeListFilesResponse,
      responseStream: true,
      options: {}
    },
    volumeListFiles2: {
      name: "VolumeListFiles2",
      requestType: VolumeListFiles2Request,
      requestStream: false,
      responseType: VolumeListFiles2Response,
      responseStream: true,
      options: {}
    },
    volumePutFiles: {
      name: "VolumePutFiles",
      requestType: VolumePutFilesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumePutFiles2: {
      name: "VolumePutFiles2",
      requestType: VolumePutFiles2Request,
      requestStream: false,
      responseType: VolumePutFiles2Response,
      responseStream: false,
      options: {}
    },
    volumeReload: {
      name: "VolumeReload",
      requestType: VolumeReloadRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeRemoveFile: {
      name: "VolumeRemoveFile",
      requestType: VolumeRemoveFileRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeRemoveFile2: {
      name: "VolumeRemoveFile2",
      requestType: VolumeRemoveFile2Request,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    volumeRename: {
      name: "VolumeRename",
      requestType: VolumeRenameRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {}
    },
    /** Workspaces */
    workspaceNameLookup: {
      name: "WorkspaceNameLookup",
      requestType: Empty,
      requestStream: false,
      responseType: WorkspaceNameLookupResponse,
      responseStream: false,
      options: {}
    }
  }
};
function bytesFromBase64(b64) {
  if (globalThis.Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}
function base64FromBytes(arr) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}
function longToNumber(int64) {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function isSet3(value) {
  return value !== null && value !== void 0;
}

// src/client.ts
import { v4 as uuidv4 } from "uuid";
import {
  ClientError,
  createChannel,
  createClientFactory,
  Metadata,
  Status
} from "nice-grpc";

// src/config.ts
import { readFileSync } from "node:fs";
import { homedir } from "node:os";
import path from "node:path";
import { parse as parseToml } from "smol-toml";
function readConfigFile() {
  try {
    const configContent = readFileSync(path.join(homedir(), ".modal.toml"), {
      encoding: "utf-8"
    });
    return parseToml(configContent);
  } catch (err) {
    if (err.code === "ENOENT") {
      return {};
    }
    return {};
  }
}
var config = readConfigFile();
function getProfile(profileName) {
  if (!profileName) {
    for (const [name, profileData2] of Object.entries(config)) {
      if (profileData2.active) {
        profileName = name;
        break;
      }
    }
  }
  const profileData = profileName && Object.hasOwn(config, profileName) ? config[profileName] : {};
  const profile = {
    serverUrl: process.env["MODAL_SERVER_URL"] || profileData.server_url || "https://api.modal.com:443",
    tokenId: process.env["MODAL_TOKEN_ID"] || profileData.token_id,
    tokenSecret: process.env["MODAL_TOKEN_SECRET"] || profileData.token_secret,
    environment: process.env["MODAL_ENVIRONMENT"] || profileData.environment,
    imageBuilderVersion: process.env["MODAL_IMAGE_BUILDER_VERSION"] || profileData.imageBuilderVersion
  };
  return profile;
}
function environmentName(environment) {
  return environment || clientProfile.environment || "";
}
function imageBuilderVersion(version) {
  return version || clientProfile.imageBuilderVersion || "2024.10";
}

// src/auth_token_manager.ts
var REFRESH_WINDOW = 5 * 60;
var DEFAULT_EXPIRY_OFFSET = 20 * 60;
var AuthTokenManager = class {
  client;
  currentToken = "";
  tokenExpiry = 0;
  stopped = false;
  timeoutId = null;
  initialTokenPromise = null;
  constructor(client2) {
    this.client = client2;
  }
  /**
   * Returns the current cached token.
   * If the initial token fetch is still in progress, waits for it to complete.
   */
  async getToken() {
    if (this.initialTokenPromise) {
      await this.initialTokenPromise;
    }
    if (this.currentToken && !this.isExpired()) {
      return this.currentToken;
    }
    throw new Error("No valid auth token available");
  }
  /**
   * Fetches a new auth token from the server and stores it.
   */
  async fetchToken() {
    const response = await this.client.authTokenGet({});
    const token = response.token;
    if (!token) {
      throw new Error(
        "Internal error: did not receive auth token from server, please contact Modal support"
      );
    }
    this.currentToken = token;
    const exp = this.decodeJWT(token);
    if (exp > 0) {
      this.tokenExpiry = exp;
    } else {
      console.warn("Failed to decode x-modal-auth-token exp field");
      this.tokenExpiry = Math.floor(Date.now() / 1e3) + DEFAULT_EXPIRY_OFFSET;
    }
  }
  /**
   * Background loop that refreshes tokens REFRESH_WINDOW seconds before they expire.
   */
  async backgroundRefresh() {
    while (!this.stopped) {
      const now = Math.floor(Date.now() / 1e3);
      const refreshTime = this.tokenExpiry - REFRESH_WINDOW;
      const delay = Math.max(0, refreshTime - now) * 1e3;
      await new Promise((resolve) => {
        this.timeoutId = setTimeout(resolve, delay);
        this.timeoutId.unref();
      });
      if (this.stopped) {
        return;
      }
      try {
        await this.fetchToken();
      } catch (error) {
        console.error("Failed to refresh auth token:", error);
        await new Promise((resolve) => setTimeout(resolve, 5e3));
      }
    }
  }
  /**
   * Fetches the initial token and starts the refresh loop.
   * Throws an error if the initial token fetch fails.
   */
  async start() {
    this.initialTokenPromise = this.fetchToken();
    try {
      await this.initialTokenPromise;
    } finally {
      this.initialTokenPromise = null;
    }
    this.stopped = false;
    this.backgroundRefresh();
  }
  /**
   * Stops the background refresh.
   */
  stop() {
    this.stopped = true;
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  /**
   * Extracts the exp claim from a JWT token.
   */
  decodeJWT(token) {
    try {
      const parts = token.split(".");
      if (parts.length !== 3) {
        return 0;
      }
      let payload = parts[1];
      while (payload.length % 4 !== 0) {
        payload += "=";
      }
      const decoded = atob(payload);
      const claims = JSON.parse(decoded);
      return claims.exp || 0;
    } catch {
      return 0;
    }
  }
  isExpired() {
    const now = Math.floor(Date.now() / 1e3);
    return now >= this.tokenExpiry;
  }
  getCurrentToken() {
    return this.currentToken;
  }
  setToken(token, expiry) {
    this.currentToken = token;
    this.tokenExpiry = expiry;
  }
};

// src/client.ts
var defaultProfile = getProfile(process.env["MODAL_PROFILE"]);
var authTokenManager = null;
function authMiddleware(profile) {
  return async function* authMiddleware2(call, options) {
    if (!profile.tokenId || !profile.tokenSecret) {
      throw new Error(
        `Profile is missing token_id or token_secret. Please set them in .modal.toml, or as environment variables, or initializeClient().`
      );
    }
    const { tokenId, tokenSecret } = profile;
    options.metadata ??= new Metadata();
    options.metadata.set(
      "x-modal-client-type",
      String(8 /* CLIENT_TYPE_LIBMODAL_JS */)
    );
    options.metadata.set("x-modal-client-version", "1.0.0");
    options.metadata.set("x-modal-token-id", tokenId);
    options.metadata.set("x-modal-token-secret", tokenSecret);
    if (call.method.path !== "/modal.client.ModalClient/AuthTokenGet") {
      if (!authTokenManager) {
        authTokenManager = new AuthTokenManager(client);
        authTokenManager.start();
      }
      const token = await authTokenManager.getToken();
      if (token) {
        options.metadata.set("x-modal-auth-token", token);
      }
    }
    return yield* call.next(call.request, options);
  };
}
var timeoutMiddleware = async function* timeoutMiddleware2(call, options) {
  if (!options.timeout || options.signal?.aborted) {
    return yield* call.next(call.request, options);
  }
  const { timeout, signal: origSignal, ...restOptions } = options;
  const abortController = new AbortController();
  const abortListener = () => abortController.abort();
  origSignal?.addEventListener("abort", abortListener);
  let timedOut = false;
  const timer = setTimeout(() => {
    timedOut = true;
    abortController.abort();
  }, timeout);
  try {
    return yield* call.next(call.request, {
      ...restOptions,
      signal: abortController.signal
    });
  } finally {
    origSignal?.removeEventListener("abort", abortListener);
    clearTimeout(timer);
    if (timedOut) {
      throw new ClientError(
        call.method.path,
        Status.DEADLINE_EXCEEDED,
        `Timed out after ${timeout}ms`
      );
    }
  }
};
var retryableGrpcStatusCodes = /* @__PURE__ */ new Set([
  Status.DEADLINE_EXCEEDED,
  Status.UNAVAILABLE,
  Status.CANCELLED,
  Status.INTERNAL,
  Status.UNKNOWN
]);
function isRetryableGrpc(err) {
  if (err instanceof ClientError) {
    return retryableGrpcStatusCodes.has(err.code);
  }
  return false;
}
var sleep = (ms, signal) => new Promise((resolve, reject) => {
  if (signal?.aborted) return reject(signal.reason);
  const t = setTimeout(resolve, ms);
  signal?.addEventListener(
    "abort",
    () => {
      clearTimeout(t);
      reject(signal.reason);
    },
    { once: true }
  );
});
var retryMiddleware = async function* retryMiddleware2(call, options) {
  const {
    retries = 3,
    baseDelay = 100,
    maxDelay = 1e3,
    delayFactor = 2,
    additionalStatusCodes = [],
    signal,
    ...restOptions
  } = options;
  if (call.requestStream || call.responseStream || !retries) {
    return yield* call.next(call.request, restOptions);
  }
  const retryableCodes = /* @__PURE__ */ new Set([
    ...retryableGrpcStatusCodes,
    ...additionalStatusCodes
  ]);
  const idempotencyKey = uuidv4();
  const startTime = Date.now();
  let attempt = 0;
  let delayMs = baseDelay;
  while (true) {
    const metadata = new Metadata(restOptions.metadata ?? {});
    metadata.set("x-idempotency-key", idempotencyKey);
    metadata.set("x-retry-attempt", String(attempt));
    if (attempt > 0) {
      metadata.set(
        "x-retry-delay",
        ((Date.now() - startTime) / 1e3).toFixed(3)
      );
    }
    try {
      return yield* call.next(call.request, {
        ...restOptions,
        metadata,
        signal
      });
    } catch (err) {
      if (!(err instanceof ClientError) || !retryableCodes.has(err.code) || attempt >= retries) {
        throw err;
      }
      await sleep(delayMs, signal);
      delayMs = Math.min(delayMs * delayFactor, maxDelay);
      attempt += 1;
    }
  }
};
var inputPlaneClients = {};
var getOrCreateInputPlaneClient = (serverUrl) => {
  const client2 = inputPlaneClients[serverUrl];
  if (client2) {
    return client2;
  }
  const profile = { ...clientProfile, serverUrl };
  const newClient = createClient(profile);
  inputPlaneClients[serverUrl] = newClient;
  return newClient;
};
function createClient(profile) {
  const channel = createChannel(profile.serverUrl, void 0, {
    "grpc.max_receive_message_length": 100 * 1024 * 1024,
    "grpc.max_send_message_length": 100 * 1024 * 1024,
    "grpc-node.flow_control_window": 64 * 1024 * 1024
  });
  return createClientFactory().use(authMiddleware(profile)).use(retryMiddleware).use(timeoutMiddleware).create(ModalClientDefinition, channel);
}
var clientProfile = defaultProfile;
var client = createClient(clientProfile);
function initializeClient(options) {
  const mergedProfile = {
    ...defaultProfile,
    tokenId: options.tokenId,
    tokenSecret: options.tokenSecret,
    environment: options.environment || defaultProfile.environment
  };
  clientProfile = mergedProfile;
  client = createClient(mergedProfile);
  authTokenManager = new AuthTokenManager(client);
  authTokenManager.start();
}

// src/secret.ts
import { ClientError as ClientError2, Status as Status2 } from "nice-grpc";

// src/errors.ts
var FunctionTimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "FunctionTimeoutError";
  }
};
var RemoteError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "RemoteError";
  }
};
var InternalFailure = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InternalFailure";
  }
};
var NotFoundError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
  }
};
var AlreadyExistsError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AlreadyExistsError";
  }
};
var InvalidError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidError";
  }
};
var QueueEmptyError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "QueueEmptyError";
  }
};
var QueueFullError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "QueueFullError";
  }
};
var SandboxFilesystemError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SandboxFilesystemError";
  }
};
var SandboxTimeoutError = class extends Error {
  constructor(message = "Sandbox operation timed out") {
    super(message);
    this.name = "SandboxTimeoutError";
  }
};

// src/secret.ts
var Secret = class _Secret {
  secretId;
  name;
  /** @ignore */
  constructor(secretId, name) {
    this.secretId = secretId;
    this.name = name;
  }
  /** Reference a Secret by its name. */
  static async fromName(name, options) {
    try {
      const resp = await client.secretGetOrCreate({
        deploymentName: name,
        environmentName: environmentName(options?.environment),
        requiredKeys: options?.requiredKeys ?? []
      });
      return new _Secret(resp.secretId, name);
    } catch (err) {
      if (err instanceof ClientError2 && err.code === Status2.NOT_FOUND)
        throw new NotFoundError(err.details);
      if (err instanceof ClientError2 && err.code === Status2.FAILED_PRECONDITION && err.details.includes("Secret is missing key"))
        throw new NotFoundError(err.details);
      throw err;
    }
  }
  /** Create a Secret from a plain object of key-value pairs. */
  static async fromObject(entries, options) {
    for (const [, value] of Object.entries(entries)) {
      if (value == null || typeof value !== "string") {
        throw new InvalidError(
          "entries must be an object mapping string keys to string values, but got:\n" + JSON.stringify(entries)
        );
      }
    }
    try {
      const resp = await client.secretGetOrCreate({
        objectCreationType: 5 /* OBJECT_CREATION_TYPE_EPHEMERAL */,
        envDict: entries,
        environmentName: environmentName(options?.environment)
      });
      return new _Secret(resp.secretId);
    } catch (err) {
      if (err instanceof ClientError2 && (err.code === Status2.INVALID_ARGUMENT || err.code === Status2.FAILED_PRECONDITION))
        throw new InvalidError(err.details);
      throw err;
    }
  }
};
async function mergeEnvAndSecrets(env, secrets) {
  const result = [...secrets || []];
  if (env && Object.keys(env).length > 0) {
    result.push(await Secret.fromObject(env));
  }
  return result;
}

// src/image.ts
import { ClientError as ClientError3 } from "nice-grpc";
import { Status as Status3 } from "nice-grpc";
var Image2 = class _Image {
  #imageId;
  #tag;
  #imageRegistryConfig;
  #layers;
  /** @ignore */
  constructor(imageId, tag, imageRegistryConfig, layers) {
    this.#imageId = imageId;
    this.#tag = tag;
    this.#imageRegistryConfig = imageRegistryConfig;
    this.#layers = layers || [
      {
        commands: [],
        env: void 0,
        secrets: void 0,
        gpuConfig: void 0,
        forceBuild: false
      }
    ];
  }
  get imageId() {
    return this.#imageId;
  }
  /**
   * Creates an Image from an Image ID
   *
   * @param imageId - Image ID.
   */
  static async fromId(imageId) {
    try {
      const resp = await client.imageFromId({ imageId });
      return new _Image(resp.imageId, "");
    } catch (err) {
      if (err instanceof ClientError3 && err.code === Status3.NOT_FOUND)
        throw new NotFoundError(err.details);
      if (err instanceof ClientError3 && err.code === Status3.FAILED_PRECONDITION && err.details.includes("Could not find image with ID"))
        throw new NotFoundError(err.details);
      throw err;
    }
  }
  /**
   * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
   *
   * @param tag - The registry tag for the Image.
   * @param secret - Optional. A Secret containing credentials for registry authentication.
   */
  static fromRegistry(tag, secret) {
    let imageRegistryConfig;
    if (secret) {
      if (!(secret instanceof Secret)) {
        throw new TypeError(
          "secret must be a reference to an existing Secret, e.g. `await Secret.fromName('my_secret')`"
        );
      }
      imageRegistryConfig = {
        registryAuthType: 4 /* REGISTRY_AUTH_TYPE_STATIC_CREDS */,
        secretId: secret.secretId
      };
    }
    return new _Image("", tag, imageRegistryConfig);
  }
  /**
   * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
   *
   * @param tag - The registry tag for the Image.
   * @param secret - A Secret containing credentials for registry authentication.
   */
  static fromAwsEcr(tag, secret) {
    let imageRegistryConfig;
    if (secret) {
      if (!(secret instanceof Secret)) {
        throw new TypeError(
          "secret must be a reference to an existing Secret, e.g. `await Secret.fromName('my_secret')`"
        );
      }
      imageRegistryConfig = {
        registryAuthType: 1 /* REGISTRY_AUTH_TYPE_AWS */,
        secretId: secret.secretId
      };
    }
    return new _Image("", tag, imageRegistryConfig);
  }
  /**
   * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
   *
   * @param tag - The registry tag for the Image.
   * @param secret - A Secret containing credentials for registry authentication.
   */
  static fromGcpArtifactRegistry(tag, secret) {
    let imageRegistryConfig;
    if (secret) {
      if (!(secret instanceof Secret)) {
        throw new TypeError(
          "secret must be a reference to an existing Secret, e.g. `await Secret.fromName('my_secret')`"
        );
      }
      imageRegistryConfig = {
        registryAuthType: 2 /* REGISTRY_AUTH_TYPE_GCP */,
        secretId: secret.secretId
      };
    }
    return new _Image("", tag, imageRegistryConfig);
  }
  static validateDockerfileCommands(commands) {
    for (const command of commands) {
      const trimmed = command.trim().toUpperCase();
      if (trimmed.startsWith("COPY ") && !trimmed.startsWith("COPY --FROM=")) {
        throw new InvalidError(
          "COPY commands that copy from local context are not yet supported."
        );
      }
    }
  }
  /**
   * Extend an image with arbitrary Dockerfile-like commands.
   *
   * Each call creates a new Image layer that will be built sequentially.
   * The provided options apply only to this layer.
   *
   * @param commands - Array of Dockerfile commands as strings
   * @param options - Optional configuration for this layer's build
   * @returns A new Image instance
   */
  dockerfileCommands(commands, options) {
    if (commands.length === 0) {
      return this;
    }
    _Image.validateDockerfileCommands(commands);
    const newLayer = {
      commands: [...commands],
      env: options?.env,
      secrets: options?.secrets,
      gpuConfig: options?.gpu ? parseGpuConfig(options.gpu) : void 0,
      forceBuild: options?.forceBuild
    };
    return new _Image("", this.#tag, this.#imageRegistryConfig, [
      ...this.#layers,
      newLayer
    ]);
  }
  /**
   * Eagerly builds an Image on Modal.
   *
   * @param app - App to use to build the Image.
   */
  async build(app) {
    if (this.imageId !== "") {
      return this;
    }
    let baseImageId;
    for (let i = 0; i < this.#layers.length; i++) {
      const layer = this.#layers[i];
      const mergedSecrets = await mergeEnvAndSecrets(layer.env, layer.secrets);
      const secretIds = mergedSecrets.map((secret) => secret.secretId);
      const gpuConfig = layer.gpuConfig;
      let dockerfileCommands;
      let baseImages;
      if (i === 0) {
        dockerfileCommands = [`FROM ${this.#tag}`, ...layer.commands];
        baseImages = [];
      } else {
        dockerfileCommands = ["FROM base", ...layer.commands];
        baseImages = [{ dockerTag: "base", imageId: baseImageId }];
      }
      const resp = await client.imageGetOrCreate({
        appId: app.appId,
        image: Image.create({
          dockerfileCommands,
          imageRegistryConfig: this.#imageRegistryConfig,
          secretIds,
          gpuConfig,
          contextFiles: [],
          baseImages
        }),
        builderVersion: imageBuilderVersion(),
        forceBuild: layer.forceBuild || false
      });
      let result;
      if (resp.result?.status) {
        result = resp.result;
      } else {
        let lastEntryId = "";
        let resultJoined = void 0;
        while (!resultJoined) {
          for await (const item of client.imageJoinStreaming({
            imageId: resp.imageId,
            timeout: 55,
            lastEntryId
          })) {
            if (item.entryId) lastEntryId = item.entryId;
            if (item.result?.status) {
              resultJoined = item.result;
              break;
            }
          }
        }
        result = resultJoined;
      }
      if (result.status === 2 /* GENERIC_STATUS_FAILURE */) {
        throw new Error(
          `Image build for ${resp.imageId} failed with the exception:
${result.exception}`
        );
      } else if (result.status === 3 /* GENERIC_STATUS_TERMINATED */) {
        throw new Error(
          `Image build for ${resp.imageId} terminated due to external shut-down. Please try again.`
        );
      } else if (result.status === 4 /* GENERIC_STATUS_TIMEOUT */) {
        throw new Error(
          `Image build for ${resp.imageId} timed out. Please try again with a larger timeout parameter.`
        );
      } else if (result.status !== 1 /* GENERIC_STATUS_SUCCESS */) {
        throw new Error(
          `Image build for ${resp.imageId} failed with unknown status: ${result.status}`
        );
      }
      baseImageId = resp.imageId;
    }
    this.#imageId = baseImageId;
    return this;
  }
  /** Delete an Image by ID. Warning: This removes an *entire Image*, and cannot be undone. */
  static async delete(imageId, _ = {}) {
    const image = await _Image.fromId(imageId);
    await client.imageDelete({ imageId: image.imageId });
  }
};

// src/sandbox.ts
import { ClientError as ClientError4, Status as Status4 } from "nice-grpc";

// src/sandbox_filesystem.ts
var SandboxFile = class {
  #fileDescriptor;
  #taskId;
  /** @ignore */
  constructor(fileDescriptor, taskId) {
    this.#fileDescriptor = fileDescriptor;
    this.#taskId = taskId;
  }
  /**
   * Read data from the file.
   * @returns Promise that resolves to the read data as Uint8Array
   */
  async read() {
    const resp = await runFilesystemExec({
      fileReadRequest: {
        fileDescriptor: this.#fileDescriptor
      },
      taskId: this.#taskId
    });
    const chunks = resp.chunks;
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }
  /**
   * Write data to the file.
   * @param data - Data to write (string or Uint8Array)
   */
  async write(data) {
    await runFilesystemExec({
      fileWriteRequest: {
        fileDescriptor: this.#fileDescriptor,
        data
      },
      taskId: this.#taskId
    });
  }
  /**
   * Flush any buffered data to the file.
   */
  async flush() {
    await runFilesystemExec({
      fileFlushRequest: {
        fileDescriptor: this.#fileDescriptor
      },
      taskId: this.#taskId
    });
  }
  /**
   * Close the file handle.
   */
  async close() {
    await runFilesystemExec({
      fileCloseRequest: {
        fileDescriptor: this.#fileDescriptor
      },
      taskId: this.#taskId
    });
  }
};
async function runFilesystemExec(request) {
  const response = await client.containerFilesystemExec(request);
  const chunks = [];
  let retries = 10;
  let completed = false;
  while (!completed) {
    try {
      const outputIterator = client.containerFilesystemExecGetOutput({
        execId: response.execId,
        timeout: 55
      });
      for await (const batch of outputIterator) {
        chunks.push(...batch.output);
        if (batch.eof) {
          completed = true;
          break;
        }
        if (batch.error !== void 0) {
          if (retries > 0) {
            retries--;
            break;
          }
          throw new SandboxFilesystemError(batch.error.errorMessage);
        }
      }
    } catch (err) {
      if (isRetryableGrpc(err) && retries > 0) {
        retries--;
      } else throw err;
    }
  }
  return { chunks, response };
}

// src/streams.ts
function toModalReadStream(stream) {
  return Object.assign(stream, readMixin);
}
function toModalWriteStream(stream) {
  return Object.assign(stream, writeMixin);
}
var readMixin = {
  async readText() {
    const reader = this.getReader();
    try {
      const decoder = new TextDecoder("utf-8");
      const chunks = [];
      while (true) {
        const { value, done } = await reader.read();
        if (value) {
          if (typeof value === "string") chunks.push(value);
          else {
            chunks.push(decoder.decode(value.buffer, { stream: true }));
          }
        }
        if (done) {
          chunks.push(decoder.decode(void 0, { stream: false }));
          break;
        }
      }
      return chunks.join("");
    } finally {
      reader.releaseLock();
    }
  },
  async readBytes() {
    const chunks = [];
    const reader = this.getReader();
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (value) {
          if (typeof value === "string") {
            chunks.push(new TextEncoder().encode(value));
          } else {
            chunks.push(value);
          }
        }
        if (done) break;
      }
    } finally {
      reader.releaseLock();
    }
    let totalLength = 0;
    for (const chunk of chunks) {
      totalLength += chunk.length;
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  }
};
var writeMixin = {
  async writeText(text) {
    const writer = this.getWriter();
    try {
      await writer.write(text);
    } finally {
      writer.releaseLock();
    }
  },
  async writeBytes(bytes) {
    const writer = this.getWriter();
    try {
      await writer.write(bytes);
    } finally {
      writer.releaseLock();
    }
  }
};
function streamConsumingIter(iterable) {
  const iter = iterable[Symbol.asyncIterator]();
  return new ReadableStream(
    {
      async pull(controller) {
        const { done, value } = await iter.next();
        if (value) {
          controller.enqueue(value);
        }
        if (done) {
          controller.close();
        }
      },
      async cancel() {
        consumeIterator(iter);
      }
    },
    new ByteLengthQueuingStrategy({
      highWaterMark: 64 * 1024
      // 64 KiB
    })
  );
}
async function consumeIterator(iter) {
  while (true) {
    const { done } = await iter.next();
    if (done) break;
  }
}

// src/sandbox.ts
var Tunnel = class {
  /** @ignore */
  constructor(host, port, unencryptedHost, unencryptedPort) {
    this.host = host;
    this.port = port;
    this.unencryptedHost = unencryptedHost;
    this.unencryptedPort = unencryptedPort;
  }
  /** Get the public HTTPS URL of the forwarded port. */
  get url() {
    let value = `https://${this.host}`;
    if (this.port !== 443) {
      value += `:${this.port}`;
    }
    return value;
  }
  /** Get the public TLS socket as a [host, port] tuple. */
  get tlsSocket() {
    return [this.host, this.port];
  }
  /** Get the public TCP socket as a [host, port] tuple. */
  get tcpSocket() {
    if (!this.unencryptedHost || this.unencryptedPort === void 0) {
      throw new InvalidError(
        "This tunnel is not configured for unencrypted TCP."
      );
    }
    return [this.unencryptedHost, this.unencryptedPort];
  }
};
function defaultSandboxPTYInfo() {
  return PTYInfo.create({
    enabled: true,
    winszRows: 24,
    winszCols: 80,
    envTerm: "xterm-256color",
    envColorterm: "truecolor",
    envTermProgram: "",
    ptyType: 2 /* PTY_TYPE_SHELL */,
    noTerminateOnIdleStdin: true
  });
}
async function buildContainerExecRequestProto(taskId, command, options) {
  const mergedSecrets = await mergeEnvAndSecrets(
    options?.env,
    options?.secrets
  );
  const secretIds = mergedSecrets.map((secret) => secret.secretId);
  let ptyInfo;
  if (options?.pty) {
    ptyInfo = defaultSandboxPTYInfo();
  }
  return ContainerExecRequest.create({
    taskId,
    command,
    workdir: options?.workdir,
    timeoutSecs: options?.timeout ? options.timeout / 1e3 : 0,
    secretIds,
    ptyInfo
  });
}
var Sandbox2 = class _Sandbox {
  sandboxId;
  stdin;
  stdout;
  stderr;
  #taskId;
  #tunnels;
  /** @ignore */
  constructor(sandboxId) {
    this.sandboxId = sandboxId;
    this.stdin = toModalWriteStream(inputStreamSb(sandboxId));
    this.stdout = toModalReadStream(
      streamConsumingIter(
        outputStreamSb(sandboxId, 1 /* FILE_DESCRIPTOR_STDOUT */)
      ).pipeThrough(new TextDecoderStream())
    );
    this.stderr = toModalReadStream(
      streamConsumingIter(
        outputStreamSb(sandboxId, 2 /* FILE_DESCRIPTOR_STDERR */)
      ).pipeThrough(new TextDecoderStream())
    );
  }
  /** Set tags (key-value pairs) on the Sandbox. Tags can be used to filter results in `Sandbox.list`. */
  async setTags(tags) {
    const tagsList = Object.entries(tags).map(([tagName, tagValue]) => ({
      tagName,
      tagValue
    }));
    try {
      await client.sandboxTagsSet({
        environmentName: environmentName(),
        sandboxId: this.sandboxId,
        tags: tagsList
      });
    } catch (err) {
      if (err instanceof ClientError4 && err.code === Status4.INVALID_ARGUMENT) {
        throw new InvalidError(err.details || err.message);
      }
      throw err;
    }
  }
  /** Get tags (key-value pairs) currently attached to this Sandbox from the server. */
  async getTags() {
    let resp;
    try {
      resp = await client.sandboxTagsGet({ sandboxId: this.sandboxId });
    } catch (err) {
      if (err instanceof ClientError4 && err.code === Status4.INVALID_ARGUMENT) {
        throw new InvalidError(err.details || err.message);
      }
      throw err;
    }
    const tags = {};
    for (const tag of resp.tags) {
      tags[tag.tagName] = tag.tagValue;
    }
    return tags;
  }
  /** Returns a running Sandbox object from an ID.
   *
   * @returns Sandbox with ID
   */
  static async fromId(sandboxId) {
    try {
      await client.sandboxWait({
        sandboxId,
        timeout: 0
      });
    } catch (err) {
      if (err instanceof ClientError4 && err.code === Status4.NOT_FOUND)
        throw new NotFoundError(`Sandbox with id: '${sandboxId}' not found`);
      throw err;
    }
    return new _Sandbox(sandboxId);
  }
  /** Get a running Sandbox by name from a deployed App.
   *
   * Raises a NotFoundError if no running Sandbox is found with the given name.
   * A Sandbox's name is the `name` argument passed to `App.createSandbox`.
   *
   * @param appName - Name of the deployed App
   * @param name - Name of the Sandbox
   * @param environment - Optional override for the environment
   * @returns Promise that resolves to a Sandbox
   */
  static async fromName(appName, name, environment) {
    try {
      const resp = await client.sandboxGetFromName({
        sandboxName: name,
        appName,
        environmentName: environmentName(environment)
      });
      return new _Sandbox(resp.sandboxId);
    } catch (err) {
      if (err instanceof ClientError4 && err.code === Status4.NOT_FOUND)
        throw new NotFoundError(
          `Sandbox with name '${name}' not found in App '${appName}'`
        );
      throw err;
    }
  }
  /**
   * Open a file in the Sandbox filesystem.
   * @param path - Path to the file to open
   * @param mode - File open mode (r, w, a, r+, w+, a+)
   * @returns Promise that resolves to a SandboxFile
   */
  async open(path2, mode = "r") {
    const taskId = await this.#getTaskId();
    const resp = await runFilesystemExec({
      fileOpenRequest: {
        path: path2,
        mode
      },
      taskId
    });
    const fileDescriptor = resp.response.fileDescriptor;
    return new SandboxFile(fileDescriptor, taskId);
  }
  async exec(command, options) {
    const taskId = await this.#getTaskId();
    const req = await buildContainerExecRequestProto(taskId, command, options);
    const resp = await client.containerExec(req);
    return new ContainerProcess(resp.execId, options);
  }
  async #getTaskId() {
    if (this.#taskId === void 0) {
      const resp = await client.sandboxGetTaskId({
        sandboxId: this.sandboxId
      });
      if (!resp.taskId) {
        throw new Error(
          `Sandbox ${this.sandboxId} does not have a task ID. It may not be running.`
        );
      }
      if (resp.taskResult) {
        throw new Error(
          `Sandbox ${this.sandboxId} has already completed with result: ${resp.taskResult}`
        );
      }
      this.#taskId = resp.taskId;
    }
    return this.#taskId;
  }
  async terminate() {
    await client.sandboxTerminate({ sandboxId: this.sandboxId });
    this.#taskId = void 0;
  }
  async wait() {
    while (true) {
      const resp = await client.sandboxWait({
        sandboxId: this.sandboxId,
        timeout: 10
      });
      if (resp.result) {
        return _Sandbox.#getReturnCode(resp.result);
      }
    }
  }
  /** Get Tunnel metadata for the Sandbox.
   *
   * Raises `SandboxTimeoutError` if the tunnels are not available after the timeout.
   *
   * @returns A dictionary of Tunnel objects which are keyed by the container port.
   */
  async tunnels(timeout = 5e4) {
    if (this.#tunnels) {
      return this.#tunnels;
    }
    const resp = await client.sandboxGetTunnels({
      sandboxId: this.sandboxId,
      timeout: timeout / 1e3
      // Convert to seconds
    });
    if (resp.result?.status === 4 /* GENERIC_STATUS_TIMEOUT */) {
      throw new SandboxTimeoutError();
    }
    this.#tunnels = {};
    for (const t of resp.tunnels) {
      this.#tunnels[t.containerPort] = new Tunnel(
        t.host,
        t.port,
        t.unencryptedHost,
        t.unencryptedPort
      );
    }
    return this.#tunnels;
  }
  /**
   * Snapshot the filesystem of the Sandbox.
   *
   * Returns an `Image` object which can be used to spawn a new Sandbox with the same filesystem.
   *
   * @param timeout - Timeout for the snapshot operation in milliseconds
   * @returns Promise that resolves to an Image
   */
  async snapshotFilesystem(timeout = 55e3) {
    const resp = await client.sandboxSnapshotFs({
      sandboxId: this.sandboxId,
      timeout: timeout / 1e3
    });
    if (resp.result?.status !== 1 /* GENERIC_STATUS_SUCCESS */) {
      throw new Error(
        `Sandbox snapshot failed: ${resp.result?.exception || "Unknown error"}`
      );
    }
    if (!resp.imageId) {
      throw new Error("Sandbox snapshot response missing `imageId`");
    }
    return new Image2(resp.imageId, "");
  }
  /**
   * Check if the Sandbox has finished running.
   *
   * Returns `null` if the Sandbox is still running, else returns the exit code.
   */
  async poll() {
    const resp = await client.sandboxWait({
      sandboxId: this.sandboxId,
      timeout: 0
    });
    return _Sandbox.#getReturnCode(resp.result);
  }
  /**
   * List all Sandboxes for the current Environment or App ID (if specified).
   * If tags are specified, only Sandboxes that have at least those tags are returned.
   */
  static async *list(options = {}) {
    const env = environmentName(options.environment);
    const tagsList = options.tags ? Object.entries(options.tags).map(([tagName, tagValue]) => ({
      tagName,
      tagValue
    })) : [];
    let beforeTimestamp = void 0;
    while (true) {
      try {
        const resp = await client.sandboxList({
          appId: options.appId,
          beforeTimestamp,
          environmentName: env,
          includeFinished: false,
          tags: tagsList
        });
        if (!resp.sandboxes || resp.sandboxes.length === 0) {
          return;
        }
        for (const info of resp.sandboxes) {
          yield new _Sandbox(info.id);
        }
        beforeTimestamp = resp.sandboxes[resp.sandboxes.length - 1].createdAt;
      } catch (err) {
        if (err instanceof ClientError4 && err.code === Status4.INVALID_ARGUMENT) {
          throw new InvalidError(err.details || err.message);
        }
        throw err;
      }
    }
  }
  static #getReturnCode(result) {
    if (result === void 0 || result.status === 0 /* GENERIC_STATUS_UNSPECIFIED */) {
      return null;
    }
    if (result.status === 4 /* GENERIC_STATUS_TIMEOUT */) {
      return 124;
    } else if (result.status === 3 /* GENERIC_STATUS_TERMINATED */) {
      return 137;
    } else {
      return result.exitcode;
    }
  }
};
var ContainerProcess = class {
  stdin;
  stdout;
  stderr;
  returncode = null;
  #execId;
  constructor(execId, options) {
    const mode = options?.mode ?? "text";
    const stdout = options?.stdout ?? "pipe";
    const stderr = options?.stderr ?? "pipe";
    this.#execId = execId;
    this.stdin = toModalWriteStream(inputStreamCp(execId));
    let stdoutStream = streamConsumingIter(
      outputStreamCp(execId, 1 /* FILE_DESCRIPTOR_STDOUT */)
    );
    if (stdout === "ignore") {
      stdoutStream.cancel();
      stdoutStream = ReadableStream.from([]);
    }
    let stderrStream = streamConsumingIter(
      outputStreamCp(execId, 2 /* FILE_DESCRIPTOR_STDERR */)
    );
    if (stderr === "ignore") {
      stderrStream.cancel();
      stderrStream = ReadableStream.from([]);
    }
    if (mode === "text") {
      this.stdout = toModalReadStream(
        stdoutStream.pipeThrough(new TextDecoderStream())
      );
      this.stderr = toModalReadStream(
        stderrStream.pipeThrough(new TextDecoderStream())
      );
    } else {
      this.stdout = toModalReadStream(stdoutStream);
      this.stderr = toModalReadStream(stderrStream);
    }
  }
  /** Wait for process completion and return the exit code. */
  async wait() {
    while (true) {
      const resp = await client.containerExecWait({
        execId: this.#execId,
        timeout: 55
      });
      if (resp.completed) {
        return resp.exitCode ?? 0;
      }
    }
  }
};
async function* outputStreamSb(sandboxId, fileDescriptor) {
  let lastIndex = "0-0";
  let completed = false;
  let retries = 10;
  while (!completed) {
    try {
      const outputIterator = client.sandboxGetLogs({
        sandboxId,
        fileDescriptor,
        timeout: 55,
        lastEntryId: lastIndex
      });
      for await (const batch of outputIterator) {
        lastIndex = batch.entryId;
        yield* batch.items.map((item) => new TextEncoder().encode(item.data));
        if (batch.eof) {
          completed = true;
          break;
        }
      }
    } catch (err) {
      if (isRetryableGrpc(err) && retries > 0) retries--;
      else throw err;
    }
  }
}
async function* outputStreamCp(execId, fileDescriptor) {
  let lastIndex = 0;
  let completed = false;
  let retries = 10;
  while (!completed) {
    try {
      const outputIterator = client.containerExecGetOutput({
        execId,
        fileDescriptor,
        timeout: 55,
        getRawBytes: true,
        lastBatchIndex: lastIndex
      });
      for await (const batch of outputIterator) {
        lastIndex = batch.batchIndex;
        yield* batch.items.map((item) => item.messageBytes);
        if (batch.exitCode !== void 0) {
          completed = true;
          break;
        }
      }
    } catch (err) {
      if (isRetryableGrpc(err) && retries > 0) retries--;
      else throw err;
    }
  }
}
function inputStreamSb(sandboxId) {
  let index = 1;
  return new WritableStream({
    async write(chunk) {
      await client.sandboxStdinWrite({
        sandboxId,
        input: encodeIfString(chunk),
        index
      });
      index++;
    },
    async close() {
      await client.sandboxStdinWrite({
        sandboxId,
        index,
        eof: true
      });
    }
  });
}
function inputStreamCp(execId) {
  let messageIndex = 1;
  return new WritableStream({
    async write(chunk) {
      await client.containerExecPutInput({
        execId,
        input: {
          message: encodeIfString(chunk),
          messageIndex
        }
      });
      messageIndex++;
    },
    async close() {
      await client.containerExecPutInput({
        execId,
        input: {
          messageIndex,
          eof: true
        }
      });
    }
  });
}
function encodeIfString(chunk) {
  return typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
}

// src/cloud_bucket_mount.ts
var CloudBucketMount2 = class {
  bucketName;
  secret;
  readOnly;
  requesterPays;
  bucketEndpointUrl;
  keyPrefix;
  oidcAuthRoleArn;
  constructor(bucketName, options = {}) {
    this.bucketName = bucketName;
    this.secret = options.secret;
    this.readOnly = options.readOnly ?? false;
    this.requesterPays = options.requesterPays ?? false;
    this.bucketEndpointUrl = options.bucketEndpointUrl;
    this.keyPrefix = options.keyPrefix;
    this.oidcAuthRoleArn = options.oidcAuthRoleArn;
    if (this.bucketEndpointUrl) {
      const url = new URL(this.bucketEndpointUrl);
      if (!url.hostname.endsWith("r2.cloudflarestorage.com") && !url.hostname.endsWith("storage.googleapis.com")) {
        console.warn(
          "CloudBucketMount received unrecognized bucket endpoint URL. Assuming AWS S3 configuration as fallback."
        );
      }
    }
    if (this.requesterPays && !this.secret) {
      throw new Error("Credentials required in order to use Requester Pays.");
    }
    if (this.keyPrefix && !this.keyPrefix.endsWith("/")) {
      throw new Error(
        "keyPrefix will be prefixed to all object paths, so it must end in a '/'"
      );
    }
  }
};
function endpointUrlToBucketType(bucketEndpointUrl) {
  if (!bucketEndpointUrl) {
    return 1 /* S3 */;
  }
  const url = new URL(bucketEndpointUrl);
  if (url.hostname.endsWith("r2.cloudflarestorage.com")) {
    return 2 /* R2 */;
  } else if (url.hostname.endsWith("storage.googleapis.com")) {
    return 3 /* GCP */;
  } else {
    return 1 /* S3 */;
  }
}
function cloudBucketMountToProto(mount, mountPath) {
  return {
    bucketName: mount.bucketName,
    mountPath,
    credentialsSecretId: mount.secret?.secretId ?? "",
    readOnly: mount.readOnly,
    bucketType: endpointUrlToBucketType(mount.bucketEndpointUrl),
    requesterPays: mount.requesterPays,
    bucketEndpointUrl: mount.bucketEndpointUrl,
    keyPrefix: mount.keyPrefix,
    oidcAuthRoleArn: mount.oidcAuthRoleArn
  };
}

// src/app.ts
function parseGpuConfig(gpu) {
  if (!gpu) {
    return void 0;
  }
  let gpuType = gpu;
  let count = 1;
  if (gpu.includes(":")) {
    const [type, countStr] = gpu.split(":", 2);
    gpuType = type;
    count = parseInt(countStr, 10);
    if (isNaN(count) || count < 1) {
      throw new Error(
        `Invalid GPU count: ${countStr}. Value must be a positive integer.`
      );
    }
  }
  return {
    type: 0,
    // Deprecated field, but required by proto
    count,
    gpuType: gpuType.toUpperCase()
  };
}
async function buildSandboxCreateRequestProto(appId, imageId, options = {}) {
  const gpuConfig = parseGpuConfig(options.gpu);
  if (options.timeout && options.timeout % 1e3 !== 0) {
    throw new Error(
      `timeout must be a multiple of 1000ms, got ${options.timeout}`
    );
  }
  if (options.idleTimeout && options.idleTimeout % 1e3 !== 0) {
    throw new Error(
      `idleTimeout must be a multiple of 1000ms, got ${options.idleTimeout}`
    );
  }
  if (options.workdir && !options.workdir.startsWith("/")) {
    throw new Error(
      `workdir must be an absolute path, got: ${options.workdir}`
    );
  }
  const volumeMounts = options.volumes ? Object.entries(options.volumes).map(([mountPath, volume]) => ({
    volumeId: volume.volumeId,
    mountPath,
    allowBackgroundCommits: true,
    readOnly: volume.isReadOnly
  })) : [];
  const cloudBucketMounts = options.cloudBucketMounts ? Object.entries(options.cloudBucketMounts).map(
    ([mountPath, mount]) => cloudBucketMountToProto(mount, mountPath)
  ) : [];
  const openPorts = [];
  if (options.encryptedPorts) {
    openPorts.push(
      ...options.encryptedPorts.map((port) => ({
        port,
        unencrypted: false
      }))
    );
  }
  if (options.h2Ports) {
    openPorts.push(
      ...options.h2Ports.map((port) => ({
        port,
        unencrypted: false,
        tunnelType: 1 /* TUNNEL_TYPE_H2 */
      }))
    );
  }
  if (options.unencryptedPorts) {
    openPorts.push(
      ...options.unencryptedPorts.map((port) => ({
        port,
        unencrypted: true
      }))
    );
  }
  const mergedSecrets = await mergeEnvAndSecrets(options.env, options.secrets);
  const secretIds = mergedSecrets.map((secret) => secret.secretId);
  let networkAccess;
  if (options.blockNetwork) {
    if (options.cidrAllowlist) {
      throw new Error(
        "cidrAllowlist cannot be used when blockNetwork is enabled"
      );
    }
    networkAccess = {
      networkAccessType: 2 /* BLOCKED */,
      allowedCidrs: []
    };
  } else if (options.cidrAllowlist) {
    networkAccess = {
      networkAccessType: 3 /* ALLOWLIST */,
      allowedCidrs: options.cidrAllowlist
    };
  } else {
    networkAccess = {
      networkAccessType: 1 /* OPEN */,
      allowedCidrs: []
    };
  }
  const schedulerPlacement = SchedulerPlacement.create({
    regions: options.regions ?? []
  });
  let ptyInfo;
  if (options.pty) {
    ptyInfo = defaultSandboxPTYInfo();
  }
  return SandboxCreateRequest.create({
    appId,
    definition: {
      // Sleep default is implicit in image builder version <=2024.10
      entrypointArgs: options.command ?? ["sleep", "48h"],
      imageId,
      timeoutSecs: options.timeout != void 0 ? options.timeout / 1e3 : 600,
      idleTimeoutSecs: options.idleTimeout != void 0 ? options.idleTimeout / 1e3 : void 0,
      workdir: options.workdir ?? void 0,
      networkAccess,
      resources: {
        // https://modal.com/docs/guide/resources
        milliCpu: Math.round(1e3 * (options.cpu ?? 0.125)),
        memoryMb: options.memory ?? 128,
        gpuConfig
      },
      volumeMounts,
      cloudBucketMounts,
      ptyInfo,
      secretIds,
      openPorts: openPorts.length > 0 ? { ports: openPorts } : void 0,
      cloudProviderStr: options.cloud ?? "",
      schedulerPlacement,
      verbose: options.verbose ?? false,
      proxyId: options.proxy?.proxyId,
      name: options.name
    }
  });
}
var App2 = class _App {
  appId;
  name;
  /** @ignore */
  constructor(appId, name) {
    this.appId = appId;
    this.name = name;
  }
  /** Lookup a deployed App by name, or create if it does not exist. */
  static async lookup(name, options = {}) {
    try {
      const resp = await client.appGetOrCreate({
        appName: name,
        environmentName: environmentName(options.environment),
        objectCreationType: options.createIfMissing ? 1 /* OBJECT_CREATION_TYPE_CREATE_IF_MISSING */ : 0 /* OBJECT_CREATION_TYPE_UNSPECIFIED */
      });
      return new _App(resp.appId, name);
    } catch (err) {
      if (err instanceof ClientError5 && err.code === Status5.NOT_FOUND)
        throw new NotFoundError(`App '${name}' not found`);
      throw err;
    }
  }
  async createSandbox(image, options = {}) {
    await image.build(this);
    const createReq = await buildSandboxCreateRequestProto(
      this.appId,
      image.imageId,
      options
    );
    let createResp;
    try {
      createResp = await client.sandboxCreate(createReq);
    } catch (err) {
      if (err instanceof ClientError5 && err.code === Status5.ALREADY_EXISTS) {
        throw new AlreadyExistsError(err.details || err.message);
      }
      throw err;
    }
    return new Sandbox2(createResp.sandboxId);
  }
  /**
   * @deprecated Use `Image.fromRegistry` instead.
   */
  async imageFromRegistry(tag, secret) {
    return await Image2.fromRegistry(tag, secret).build(this);
  }
  /**
   * @deprecated Use `Image.fromAwsEcr` instead.
   */
  async imageFromAwsEcr(tag, secret) {
    return await Image2.fromAwsEcr(tag, secret).build(this);
  }
  /**
   * @deprecated Use `Image.fromGcpArtifactRegistry` instead.
   */
  async imageFromGcpArtifactRegistry(tag, secret) {
    return await Image2.fromGcpArtifactRegistry(tag, secret).build(this);
  }
};

// src/cls.ts
import { ClientError as ClientError7, Status as Status7 } from "nice-grpc";

// src/function.ts
import { createHash } from "node:crypto";

// src/pickle.ts
var PickleError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PickleError";
  }
};
var Writer = class {
  out = [];
  byte(b) {
    this.out.push(b & 255);
  }
  bytes(arr) {
    for (const b of arr) this.byte(b);
  }
  uint32LE(x) {
    this.byte(x);
    this.byte(x >>> 8);
    this.byte(x >>> 16);
    this.byte(x >>> 24);
  }
  uint64LE(n) {
    let v = BigInt(n);
    for (let i = 0; i < 8; i++) {
      this.byte(Number(v & 0xffn));
      v >>= 8n;
    }
  }
  float64BE(v) {
    const dv = new DataView(new ArrayBuffer(8));
    dv.setFloat64(0, v, false);
    this.bytes(new Uint8Array(dv.buffer));
  }
  toUint8() {
    return new Uint8Array(this.out);
  }
};
var Reader = class {
  constructor(buf, pos = 0) {
    this.buf = buf;
    this.pos = pos;
  }
  eof() {
    return this.pos >= this.buf.length;
  }
  byte() {
    return this.buf[this.pos++];
  }
  take(n) {
    const s = this.buf.subarray(this.pos, this.pos + n);
    this.pos += n;
    return s;
  }
  uint32LE() {
    const b0 = this.byte(), b1 = this.byte(), b2 = this.byte(), b3 = this.byte();
    return b0 | b1 << 8 | b2 << 16 | b3 << 24;
  }
  uint64LE() {
    const lo = this.uint32LE() >>> 0;
    const hi = this.uint32LE() >>> 0;
    return hi * 2 ** 32 + lo;
  }
  int32LE() {
    const v = new DataView(
      this.buf.buffer,
      this.buf.byteOffset + this.pos,
      4
    ).getInt32(0, true);
    this.pos += 4;
    return v;
  }
  float64BE() {
    const v = new DataView(
      this.buf.buffer,
      this.buf.byteOffset + this.pos,
      8
    ).getFloat64(0, false);
    this.pos += 8;
    return v;
  }
};
function encodeValue(val, w, proto) {
  if (val === null || val === void 0) {
    w.byte(78 /* NONE */);
    return;
  }
  if (typeof val === "boolean") {
    w.byte(val ? 136 /* NEWTRUE */ : 137 /* NEWFALSE */);
    return;
  }
  if (typeof val === "number") {
    if (Number.isInteger(val)) {
      if (val >= 0 && val <= 255) {
        w.byte(75 /* BININT1 */);
        w.byte(val);
      } else if (val >= 0 && val <= 65535) {
        w.byte(77 /* BININT2 */);
        w.byte(val & 255);
        w.byte(val >> 8 & 255);
      } else {
        w.byte(74 /* BININT4 */);
        w.uint32LE(val >>> 0);
      }
    } else {
      w.byte(71 /* BINFLOAT */);
      w.float64BE(val);
    }
    maybeMemoize(w, proto);
    return;
  }
  if (typeof val === "string") {
    const utf8 = new TextEncoder().encode(val);
    if (proto >= 4 && utf8.length < 256) {
      w.byte(140 /* SHORT_BINUNICODE */);
      w.byte(utf8.length);
    } else if (proto >= 4 && utf8.length > 4294967295) {
      w.byte(141 /* BINUNICODE8 */);
      w.uint64LE(utf8.length);
    } else {
      w.byte(88 /* BINUNICODE */);
      w.uint32LE(utf8.length);
    }
    w.bytes(utf8);
    maybeMemoize(w, proto);
    return;
  }
  if (val instanceof Uint8Array) {
    const len = val.length;
    if (proto >= 4 && len < 256) {
      w.byte(67 /* SHORT_BINBYTES */);
      w.byte(len);
    } else if (proto >= 4 && len > 4294967295) {
      w.byte(142 /* BINBYTES8 */);
      w.uint64LE(len);
    } else {
      w.byte(66 /* BINBYTES */);
      w.uint32LE(len);
    }
    w.bytes(val);
    maybeMemoize(w, proto);
    return;
  }
  if (Array.isArray(val)) {
    w.byte(93 /* EMPTY_LIST */);
    maybeMemoize(w, proto);
    for (const item of val) {
      encodeValue(item, w, proto);
      w.byte(97 /* APPEND */);
    }
    return;
  }
  if (typeof val === "object") {
    w.byte(125 /* EMPTY_DICT */);
    maybeMemoize(w, proto);
    for (const [k, v] of Object.entries(val)) {
      encodeValue(k, w, proto);
      encodeValue(v, w, proto);
      w.byte(115 /* SETITEM */);
    }
    return;
  }
  throw new PickleError(
    `The JS Modal SDK does not support encoding/pickling data of type ${typeof val}`
  );
}
function maybeMemoize(w, proto) {
  if (proto >= 4) {
    w.byte(148 /* MEMOIZE */);
  }
}
function dumps(obj, protocol = 4) {
  if (![3, 4, 5].includes(protocol))
    throw new PickleError(
      `The JS Modal SDK does not support pickle protocol version ${protocol}`
    );
  const w = new Writer();
  w.byte(128 /* PROTO */);
  w.byte(protocol);
  if (protocol === 5) {
    w.byte(149 /* FRAME */);
    w.uint64LE(0);
  }
  encodeValue(obj, w, protocol);
  w.byte(46 /* STOP */);
  return w.toUint8();
}
function loads(buf) {
  const r = new Reader(buf);
  const op0 = r.byte();
  if (op0 !== 128 /* PROTO */) throw new PickleError("pickle missing PROTO header");
  const proto = r.byte();
  if (![3, 4, 5].includes(proto))
    throw new PickleError(
      `The JS Modal SDK does not support pickle protocol version ${proto}`
    );
  const stack = [];
  const memo = [];
  const tdec = new TextDecoder();
  function push(v) {
    stack.push(v);
  }
  function pop() {
    return stack.pop();
  }
  if (proto === 5 && buf[r["pos"]] === 149 /* FRAME */) {
    r.byte();
    const size = r.uint64LE();
    void size;
  }
  const MARK = Symbol("pickle-mark");
  while (!r.eof()) {
    const op = r.byte();
    switch (op) {
      case 46 /* STOP */:
        return stack.pop();
      case 78 /* NONE */:
        push(null);
        break;
      case 136 /* NEWTRUE */:
        push(true);
        break;
      case 137 /* NEWFALSE */:
        push(false);
        break;
      case 75 /* BININT1 */:
        push(r.byte());
        break;
      case 77 /* BININT2 */: {
        const lo = r.byte(), hi = r.byte();
        const n = hi << 8 | lo;
        push(n);
        break;
      }
      case 74 /* BININT4 */: {
        push(r.int32LE());
        break;
      }
      case 71 /* BINFLOAT */:
        push(r.float64BE());
        break;
      case 140 /* SHORT_BINUNICODE */: {
        const n = r.byte();
        push(tdec.decode(r.take(n)));
        break;
      }
      case 88 /* BINUNICODE */: {
        const n = r.uint32LE();
        push(tdec.decode(r.take(n)));
        break;
      }
      case 141 /* BINUNICODE8 */: {
        const n = r.uint64LE();
        push(tdec.decode(r.take(n)));
        break;
      }
      case 67 /* SHORT_BINBYTES */: {
        const n = r.byte();
        push(r.take(n));
        break;
      }
      case 66 /* BINBYTES */: {
        const n = r.uint32LE();
        push(r.take(n));
        break;
      }
      case 142 /* BINBYTES8 */: {
        const n = r.uint64LE();
        push(r.take(n));
        break;
      }
      case 93 /* EMPTY_LIST */:
        push([]);
        break;
      case 97 /* APPEND */: {
        const v = pop();
        const lst = pop();
        lst.push(v);
        push(lst);
        break;
      }
      case 125 /* EMPTY_DICT */:
        push({});
        break;
      case 115 /* SETITEM */: {
        const v = pop(), k = pop(), d = pop();
        d[k] = v;
        push(d);
        break;
      }
      // Memo handling ----------------------------------------
      case 148 /* MEMOIZE */:
        memo.push(stack[stack.length - 1]);
        break;
      case 113 /* BINPUT */:
        memo[r.byte()] = stack[stack.length - 1];
        break;
      case 114 /* LONG_BINPUT */:
        memo[r.uint32LE()] = stack[stack.length - 1];
        break;
      case 104 /* BINGET */:
        push(memo[r.byte()]);
        break;
      case 106 /* LONG_BINGET */:
        push(memo[r.uint32LE()]);
        break;
      case 149 /* FRAME */: {
        const _size = r.uint64LE();
        break;
      }
      case 40 /* MARK */:
        push(MARK);
        break;
      case 101 /* APPENDS */: {
        const markIndex = stack.lastIndexOf(MARK);
        if (markIndex === -1) {
          throw new PickleError("APPENDS without MARK");
        }
        const lst = stack[markIndex - 1];
        if (!Array.isArray(lst)) {
          throw new PickleError("APPENDS expects a list below MARK");
        }
        const items = stack.slice(markIndex + 1);
        lst.push(...items);
        stack.length = markIndex - 1;
        push(lst);
        break;
      }
      case 117 /* SETITEMS */: {
        const markIndex = stack.lastIndexOf(MARK);
        if (markIndex === -1) {
          throw new PickleError("SETITEMS without MARK");
        }
        const d = stack[markIndex - 1];
        if (typeof d !== "object" || d === null || Array.isArray(d)) {
          throw new PickleError("SETITEMS expects a dict below MARK");
        }
        const items = stack.slice(markIndex + 1);
        for (let i = 0; i < items.length; i += 2) {
          if (i + 1 < items.length) {
            d[items[i]] = items[i + 1];
          }
        }
        stack.length = markIndex - 1;
        push(d);
        break;
      }
      default:
        throw new PickleError(
          `The JS Modal SDK does not support decoding/unpickling this kind of data. Error: unsupported opcode 0x${op.toString(16)}`
        );
    }
  }
  throw new PickleError("pickle stream ended without STOP");
}

// src/invocation.ts
var outputsTimeout = 55 * 1e3;
var ControlPlaneInvocation = class _ControlPlaneInvocation {
  functionCallId;
  input;
  functionCallJwt;
  inputJwt;
  constructor(functionCallId, input, functionCallJwt, inputJwt) {
    this.functionCallId = functionCallId;
    this.input = input;
    this.functionCallJwt = functionCallJwt;
    this.inputJwt = inputJwt;
  }
  static async create(functionId, input, invocationType) {
    const functionPutInputsItem = FunctionPutInputsItem.create({
      idx: 0,
      input
    });
    const functionMapResponse = await client.functionMap({
      functionId,
      functionCallType: 1 /* FUNCTION_CALL_TYPE_UNARY */,
      functionCallInvocationType: invocationType,
      pipelinedInputs: [functionPutInputsItem]
    });
    return new _ControlPlaneInvocation(
      functionMapResponse.functionCallId,
      input,
      functionMapResponse.functionCallJwt,
      functionMapResponse.pipelinedInputs[0].inputJwt
    );
  }
  static fromFunctionCallId(functionCallId) {
    return new _ControlPlaneInvocation(functionCallId);
  }
  async awaitOutput(timeout) {
    return await pollFunctionOutput(
      (timeoutMillis) => this.#getOutput(timeoutMillis),
      timeout
    );
  }
  async #getOutput(timeoutMillis) {
    const response = await client.functionGetOutputs({
      functionCallId: this.functionCallId,
      maxValues: 1,
      timeout: timeoutMillis / 1e3,
      // Backend needs seconds
      lastEntryId: "0-0",
      clearOnSuccess: true,
      requestedAt: timeNowSeconds()
    });
    return response.outputs ? response.outputs[0] : void 0;
  }
  async retry(retryCount) {
    if (!this.input) {
      throw new Error("Cannot retry Function invocation - input missing");
    }
    const retryItem = {
      inputJwt: this.inputJwt,
      input: this.input,
      retryCount
    };
    const functionRetryResponse = await client.functionRetryInputs({
      functionCallJwt: this.functionCallJwt,
      inputs: [retryItem]
    });
    this.inputJwt = functionRetryResponse.inputJwts[0];
  }
};
var InputPlaneInvocation = class _InputPlaneInvocation {
  client;
  functionId;
  input;
  attemptToken;
  constructor(client2, functionId, input, attemptToken) {
    this.client = client2;
    this.functionId = functionId;
    this.input = input;
    this.attemptToken = attemptToken;
  }
  static async create(inputPlaneUrl, functionId, input) {
    const functionPutInputsItem = FunctionPutInputsItem.create({
      idx: 0,
      input
    });
    const client2 = getOrCreateInputPlaneClient(inputPlaneUrl);
    const attemptStartResponse = await client2.attemptStart({
      functionId,
      input: functionPutInputsItem
    });
    return new _InputPlaneInvocation(
      client2,
      functionId,
      functionPutInputsItem,
      attemptStartResponse.attemptToken
    );
  }
  async awaitOutput(timeout) {
    return await pollFunctionOutput(
      (timeoutMillis) => this.#getOutput(timeoutMillis),
      timeout
    );
  }
  async #getOutput(timeoutMillis) {
    const response = await this.client.attemptAwait({
      attemptToken: this.attemptToken,
      requestedAt: timeNowSeconds(),
      timeoutSecs: timeoutMillis / 1e3
    });
    return response.output;
  }
  async retry(_retryCount) {
    const attemptRetryResponse = await this.client.attemptRetry({
      functionId: this.functionId,
      input: this.input,
      attemptToken: this.attemptToken
    });
    this.attemptToken = attemptRetryResponse.attemptToken;
  }
};
function timeNowSeconds() {
  return Date.now() / 1e3;
}
async function pollFunctionOutput(getOutput, timeout) {
  const startTime = Date.now();
  let pollTimeout = outputsTimeout;
  if (timeout !== void 0) {
    pollTimeout = Math.min(timeout, outputsTimeout);
  }
  while (true) {
    const output = await getOutput(pollTimeout);
    if (output) {
      return await processResult(output.result, output.dataFormat);
    }
    if (timeout !== void 0) {
      const remainingTime = timeout - (Date.now() - startTime);
      if (remainingTime <= 0) {
        const message = `Timeout exceeded: ${(timeout / 1e3).toFixed(1)}s`;
        throw new FunctionTimeoutError(message);
      }
      pollTimeout = Math.min(outputsTimeout, remainingTime);
    }
  }
}
async function processResult(result, dataFormat) {
  if (!result) {
    throw new Error("Received null result from invocation");
  }
  let data = new Uint8Array();
  if (result.data !== void 0) {
    data = result.data;
  } else if (result.dataBlobId) {
    data = await blobDownload(result.dataBlobId);
  }
  switch (result.status) {
    case 4 /* GENERIC_STATUS_TIMEOUT */:
      throw new FunctionTimeoutError(`Timeout: ${result.exception}`);
    case 6 /* GENERIC_STATUS_INTERNAL_FAILURE */:
      throw new InternalFailure(`Internal failure: ${result.exception}`);
    case 1 /* GENERIC_STATUS_SUCCESS */:
      break;
    default:
      throw new RemoteError(`Remote error: ${result.exception}`);
  }
  return deserializeDataFormat(data, dataFormat);
}
async function blobDownload(blobId) {
  const resp = await client.blobGet({ blobId });
  const s3resp = await fetch(resp.downloadUrl);
  if (!s3resp.ok) {
    throw new Error(`Failed to download blob: ${s3resp.statusText}`);
  }
  const buf = await s3resp.arrayBuffer();
  return new Uint8Array(buf);
}
function deserializeDataFormat(data, dataFormat) {
  if (!data) {
    return null;
  }
  switch (dataFormat) {
    case 1 /* DATA_FORMAT_PICKLE */:
      return loads(data);
    case 2 /* DATA_FORMAT_ASGI */:
      throw new Error("ASGI data format is not supported in Go");
    case 3 /* DATA_FORMAT_GENERATOR_DONE */:
      return GeneratorDone.decode(data);
    default:
      throw new Error(`Unsupported data format: ${dataFormat}`);
  }
}

// src/function_call.ts
var FunctionCall = class _FunctionCall {
  functionCallId;
  /** @ignore */
  constructor(functionCallId) {
    this.functionCallId = functionCallId;
  }
  /** Create a new Function call from ID. */
  fromId(functionCallId) {
    return new _FunctionCall(functionCallId);
  }
  /** Get the result of a Function call, optionally waiting with a timeout. */
  async get(options = {}) {
    const timeout = options.timeout;
    const invocation = ControlPlaneInvocation.fromFunctionCallId(
      this.functionCallId
    );
    return invocation.awaitOutput(timeout);
  }
  /** Cancel a running Function call. */
  async cancel(options = {}) {
    await client.functionCallCancel({
      functionCallId: this.functionCallId,
      terminateContainers: options.terminateContainers
    });
  }
};

// src/function.ts
import { ClientError as ClientError6, Status as Status6 } from "nice-grpc";
var maxObjectSizeBytes = 2 * 1024 * 1024;
var maxSystemRetries = 8;
var Function_ = class _Function_ {
  functionId;
  methodName;
  #inputPlaneUrl;
  #webUrl;
  /** @ignore */
  constructor(functionId, methodName, inputPlaneUrl, webUrl) {
    this.functionId = functionId;
    this.methodName = methodName;
    this.#inputPlaneUrl = inputPlaneUrl;
    this.#webUrl = webUrl;
  }
  static async lookup(appName, name, options = {}) {
    try {
      const resp = await client.functionGet({
        appName,
        objectTag: name,
        environmentName: environmentName(options.environment)
      });
      return new _Function_(
        resp.functionId,
        void 0,
        resp.handleMetadata?.inputPlaneUrl,
        resp.handleMetadata?.webUrl
      );
    } catch (err) {
      if (err instanceof ClientError6 && err.code === Status6.NOT_FOUND)
        throw new NotFoundError(`Function '${appName}/${name}' not found`);
      throw err;
    }
  }
  // Execute a single input into a remote Function.
  async remote(args = [], kwargs = {}) {
    const input = await this.#createInput(args, kwargs);
    const invocation = await this.#createRemoteInvocation(input);
    let retryCount = 0;
    while (true) {
      try {
        return await invocation.awaitOutput();
      } catch (err) {
        if (err instanceof InternalFailure && retryCount <= maxSystemRetries) {
          await invocation.retry(retryCount);
          retryCount++;
        } else {
          throw err;
        }
      }
    }
  }
  async #createRemoteInvocation(input) {
    if (this.#inputPlaneUrl) {
      return await InputPlaneInvocation.create(
        this.#inputPlaneUrl,
        this.functionId,
        input
      );
    }
    return await ControlPlaneInvocation.create(
      this.functionId,
      input,
      4 /* FUNCTION_CALL_INVOCATION_TYPE_SYNC */
    );
  }
  // Spawn a single input into a remote Function.
  async spawn(args = [], kwargs = {}) {
    const input = await this.#createInput(args, kwargs);
    const invocation = await ControlPlaneInvocation.create(
      this.functionId,
      input,
      3 /* FUNCTION_CALL_INVOCATION_TYPE_ASYNC */
    );
    return new FunctionCall(invocation.functionCallId);
  }
  // Returns statistics about the Function.
  async getCurrentStats() {
    const resp = await client.functionGetCurrentStats(
      { functionId: this.functionId },
      { timeout: 1e4 }
    );
    return {
      backlog: resp.backlog,
      numTotalRunners: resp.numTotalTasks
    };
  }
  // Overrides the current autoscaler behavior for this Function.
  async updateAutoscaler(options) {
    await client.functionUpdateSchedulingParams({
      functionId: this.functionId,
      warmPoolSizeOverride: 0,
      // Deprecated field, always set to 0
      settings: {
        minContainers: options.minContainers,
        maxContainers: options.maxContainers,
        bufferContainers: options.bufferContainers,
        scaledownWindow: options.scaledownWindow
      }
    });
  }
  /**
   * URL of a Function running as a web endpoint.
   * @returns The web URL if this Function is a web endpoint, otherwise undefined
   */
  async getWebUrl() {
    return this.#webUrl || void 0;
  }
  async #createInput(args = [], kwargs = {}) {
    const payload = dumps([args, kwargs]);
    let argsBlobId = void 0;
    if (payload.length > maxObjectSizeBytes) {
      argsBlobId = await blobUpload(payload);
    }
    return {
      args: argsBlobId ? void 0 : payload,
      argsBlobId,
      dataFormat: 1 /* DATA_FORMAT_PICKLE */,
      methodName: this.methodName,
      finalInput: false
      // This field isn't specified in the Python client, so it defaults to false.
    };
  }
};
async function blobUpload(data) {
  const contentMd5 = createHash("md5").update(data).digest("base64");
  const contentSha256 = createHash("sha256").update(data).digest("base64");
  const resp = await client.blobCreate({
    contentMd5,
    contentSha256Base64: contentSha256,
    contentLength: data.length
  });
  if (resp.multipart) {
    throw new Error(
      "Function input size exceeds multipart upload threshold, unsupported by this SDK version"
    );
  } else if (resp.uploadUrl) {
    const uploadResp = await fetch(resp.uploadUrl, {
      method: "PUT",
      headers: {
        "Content-Type": "application/octet-stream",
        "Content-MD5": contentMd5
      },
      body: data
    });
    if (uploadResp.status < 200 || uploadResp.status >= 300) {
      throw new Error(`Failed blob upload: ${uploadResp.statusText}`);
    }
    return resp.blobId;
  } else {
    throw new Error("Missing upload URL in BlobCreate response");
  }
}

// src/retries.ts
var Retries = class {
  maxRetries;
  backoffCoefficient;
  initialDelayMs;
  maxDelayMs;
  constructor(options) {
    const {
      maxRetries,
      backoffCoefficient = 2,
      initialDelayMs = 1e3,
      maxDelayMs = 6e4
    } = options;
    if (maxRetries < 0 || maxRetries > 10) {
      throw new Error(
        `Invalid maxRetries: ${maxRetries}. Must be between 0 and 10.`
      );
    }
    if (backoffCoefficient < 1 || backoffCoefficient > 10) {
      throw new Error(
        `Invalid backoffCoefficient: ${backoffCoefficient}. Must be between 1.0 and 10.0`
      );
    }
    if (initialDelayMs < 0 || initialDelayMs > 6e4) {
      throw new Error(
        `Invalid initialDelayMs: ${initialDelayMs}. Must be between 0 and 60000 ms.`
      );
    }
    if (maxDelayMs < 1e3 || maxDelayMs > 6e4) {
      throw new Error(
        `Invalid maxDelayMs: ${maxDelayMs}. Must be between 1000 and 60000 ms.`
      );
    }
    this.maxRetries = maxRetries;
    this.backoffCoefficient = backoffCoefficient;
    this.initialDelayMs = initialDelayMs;
    this.maxDelayMs = maxDelayMs;
  }
};
function parseRetries(retries) {
  if (retries === void 0) return void 0;
  if (typeof retries === "number") {
    if (!Number.isInteger(retries) || retries < 0 || retries > 10) {
      throw new Error(
        `Retries parameter must be an integer between 0 and 10. Found: ${retries}`
      );
    }
    return new Retries({
      maxRetries: retries,
      backoffCoefficient: 1,
      initialDelayMs: 1e3
    });
  }
  if (retries instanceof Retries) return retries;
  throw new Error(
    `Retries parameter must be an integer or instance of Retries. Found: ${typeof retries}.`
  );
}

// src/cls.ts
var Cls = class _Cls {
  #serviceFunctionId;
  #schema;
  #methodNames;
  #inputPlaneUrl;
  #options;
  /** @ignore */
  constructor(serviceFunctionId, schema, methodNames, inputPlaneUrl, options) {
    this.#serviceFunctionId = serviceFunctionId;
    this.#schema = schema;
    this.#methodNames = methodNames;
    this.#inputPlaneUrl = inputPlaneUrl;
    this.#options = options;
  }
  static async lookup(appName, name, options = {}) {
    try {
      const serviceFunctionName = `${name}.*`;
      const serviceFunction = await client.functionGet({
        appName,
        objectTag: serviceFunctionName,
        environmentName: environmentName(options.environment)
      });
      const parameterInfo = serviceFunction.handleMetadata?.classParameterInfo;
      const schema = parameterInfo?.schema ?? [];
      if (schema.length > 0 && parameterInfo?.format !== 2 /* PARAM_SERIALIZATION_FORMAT_PROTO */) {
        throw new Error(
          `Unsupported parameter format: ${parameterInfo?.format}`
        );
      }
      let methodNames;
      if (serviceFunction.handleMetadata?.methodHandleMetadata) {
        methodNames = Object.keys(
          serviceFunction.handleMetadata.methodHandleMetadata
        );
      } else {
        throw new Error(
          "Cls requires Modal deployments using client v0.67 or later."
        );
      }
      return new _Cls(
        serviceFunction.functionId,
        schema,
        methodNames,
        serviceFunction.handleMetadata?.inputPlaneUrl,
        void 0
      );
    } catch (err) {
      if (err instanceof ClientError7 && err.code === Status7.NOT_FOUND)
        throw new NotFoundError(`Class '${appName}/${name}' not found`);
      throw err;
    }
  }
  /** Create a new instance of the Cls with parameters and/or runtime options. */
  async instance(params = {}) {
    let functionId;
    if (this.#schema.length === 0 && this.#options === void 0) {
      functionId = this.#serviceFunctionId;
    } else {
      functionId = await this.#bindParameters(params);
    }
    const methods = /* @__PURE__ */ new Map();
    for (const name of this.#methodNames) {
      methods.set(name, new Function_(functionId, name, this.#inputPlaneUrl));
    }
    return new ClsInstance(methods);
  }
  /** Override the static Function configuration at runtime. */
  withOptions(options) {
    const merged = mergeServiceOptions(this.#options, options);
    return new _Cls(
      this.#serviceFunctionId,
      this.#schema,
      this.#methodNames,
      this.#inputPlaneUrl,
      merged
    );
  }
  /** Create an instance of the Cls with input concurrency enabled or overridden with new values. */
  withConcurrency(options) {
    const merged = mergeServiceOptions(this.#options, {
      maxConcurrentInputs: options.maxInputs,
      targetConcurrentInputs: options.targetInputs
    });
    return new _Cls(
      this.#serviceFunctionId,
      this.#schema,
      this.#methodNames,
      this.#inputPlaneUrl,
      merged
    );
  }
  /** Create an instance of the Cls with dynamic batching enabled or overridden with new values. */
  withBatching(options) {
    const merged = mergeServiceOptions(this.#options, {
      batchMaxSize: options.maxBatchSize,
      batchWaitMs: options.waitMs
    });
    return new _Cls(
      this.#serviceFunctionId,
      this.#schema,
      this.#methodNames,
      this.#inputPlaneUrl,
      merged
    );
  }
  /** Bind parameters to the Cls function. */
  async #bindParameters(params) {
    const serializedParams = encodeParameterSet(this.#schema, params);
    const functionOptions = await buildFunctionOptionsProto(this.#options);
    const bindResp = await client.functionBindParams({
      functionId: this.#serviceFunctionId,
      serializedParams,
      functionOptions
    });
    return bindResp.boundFunctionId;
  }
};
function encodeParameterSet(schema, params) {
  const encoded = [];
  for (const paramSpec of schema) {
    const paramValue = encodeParameter(paramSpec, params[paramSpec.name]);
    encoded.push(paramValue);
  }
  encoded.sort((a, b) => a.name.localeCompare(b.name));
  return ClassParameterSet.encode({ parameters: encoded }).finish();
}
function mergeServiceOptions(base, diff) {
  const filteredDiff = Object.fromEntries(
    Object.entries(diff).filter(([, value]) => value !== void 0)
  );
  const merged = { ...base ?? {}, ...filteredDiff };
  return Object.keys(merged).length === 0 ? void 0 : merged;
}
async function buildFunctionOptionsProto(options) {
  if (!options) return void 0;
  const o = options ?? {};
  const gpuConfig = parseGpuConfig(o.gpu);
  const resources = o.cpu !== void 0 || o.memory !== void 0 || gpuConfig ? {
    milliCpu: o.cpu !== void 0 ? Math.round(1e3 * o.cpu) : void 0,
    memoryMb: o.memory,
    gpuConfig
  } : void 0;
  const mergedSecrets = await mergeEnvAndSecrets(o.env, o.secrets);
  const secretIds = mergedSecrets.map((s) => s.secretId);
  const volumeMounts = o.volumes ? Object.entries(o.volumes).map(([mountPath, volume]) => ({
    volumeId: volume.volumeId,
    mountPath,
    allowBackgroundCommits: true,
    readOnly: volume.isReadOnly
  })) : [];
  const parsedRetries = parseRetries(o.retries);
  const retryPolicy = parsedRetries ? {
    retries: parsedRetries.maxRetries,
    backoffCoefficient: parsedRetries.backoffCoefficient,
    initialDelayMs: parsedRetries.initialDelayMs,
    maxDelayMs: parsedRetries.maxDelayMs
  } : void 0;
  if (o.scaledownWindow !== void 0 && o.scaledownWindow % 1e3 !== 0) {
    throw new Error(
      `scaledownWindow must be a multiple of 1000ms, got ${o.scaledownWindow}`
    );
  }
  if (o.timeout !== void 0 && o.timeout % 1e3 !== 0) {
    throw new Error(`timeout must be a multiple of 1000ms, got ${o.timeout}`);
  }
  const functionOptions = FunctionOptions.create({
    secretIds,
    replaceSecretIds: secretIds.length > 0,
    replaceVolumeMounts: volumeMounts.length > 0,
    volumeMounts,
    resources,
    retryPolicy,
    concurrencyLimit: o.maxContainers,
    bufferContainers: o.bufferContainers,
    taskIdleTimeoutSecs: o.scaledownWindow !== void 0 ? o.scaledownWindow / 1e3 : void 0,
    timeoutSecs: o.timeout !== void 0 ? o.timeout / 1e3 : void 0,
    maxConcurrentInputs: o.maxConcurrentInputs,
    targetConcurrentInputs: o.targetConcurrentInputs,
    batchMaxSize: o.batchMaxSize,
    batchLingerMs: o.batchWaitMs
  });
  return functionOptions;
}
function encodeParameter(paramSpec, value) {
  const name = paramSpec.name;
  const paramType = paramSpec.type;
  const paramValue = { name, type: paramType };
  switch (paramType) {
    case 1 /* PARAM_TYPE_STRING */:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.stringDefault ?? "";
      }
      if (typeof value !== "string") {
        throw new Error(`Parameter '${name}' must be a string`);
      }
      paramValue.stringValue = value;
      break;
    case 2 /* PARAM_TYPE_INT */:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.intDefault ?? 0;
      }
      if (typeof value !== "number") {
        throw new Error(`Parameter '${name}' must be an integer`);
      }
      paramValue.intValue = value;
      break;
    case 9 /* PARAM_TYPE_BOOL */:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.boolDefault ?? false;
      }
      if (typeof value !== "boolean") {
        throw new Error(`Parameter '${name}' must be a boolean`);
      }
      paramValue.boolValue = value;
      break;
    case 4 /* PARAM_TYPE_BYTES */:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.bytesDefault ?? new Uint8Array();
      }
      if (!(value instanceof Uint8Array)) {
        throw new Error(`Parameter '${name}' must be a byte array`);
      }
      paramValue.bytesValue = value;
      break;
    default:
      throw new Error(`Unsupported parameter type: ${paramType}`);
  }
  return paramValue;
}
var ClsInstance = class {
  #methods;
  constructor(methods) {
    this.#methods = methods;
  }
  method(name) {
    const method = this.#methods.get(name);
    if (!method) {
      throw new NotFoundError(`Method '${name}' not found on class`);
    }
    return method;
  }
};

// src/queue.ts
import { ClientError as ClientError8, Status as Status8 } from "nice-grpc";

// src/ephemeral.ts
var ephemeralObjectHeartbeatSleep = 3e5;
var EphemeralHeartbeatManager = class {
  heartbeatFn;
  abortController;
  constructor(heartbeatFn) {
    this.heartbeatFn = heartbeatFn;
    this.abortController = new AbortController();
    this.start();
  }
  start() {
    const signal = this.abortController.signal;
    (async () => {
      while (!signal.aborted) {
        await this.heartbeatFn();
        await Promise.race([
          new Promise((resolve) => {
            setTimeout(resolve, ephemeralObjectHeartbeatSleep).unref();
          }),
          new Promise((resolve) => {
            signal.addEventListener("abort", resolve, { once: true });
          })
        ]);
      }
    })();
  }
  stop() {
    this.abortController.abort();
  }
};

// src/queue.ts
var queueInitialPutBackoff = 100;
var queueDefaultPartitionTtl = 24 * 3600 * 1e3;
var Queue = class _Queue {
  queueId;
  name;
  #ephemeralHbManager;
  /** @ignore */
  constructor(queueId, name, ephemeralHbManager) {
    this.queueId = queueId;
    this.name = name;
    this.#ephemeralHbManager = ephemeralHbManager;
  }
  static #validatePartitionKey(partition) {
    if (partition) {
      const partitionKey = new TextEncoder().encode(partition);
      if (partitionKey.length === 0 || partitionKey.length > 64) {
        throw new InvalidError(
          "Queue partition key must be between 1 and 64 bytes."
        );
      }
      return partitionKey;
    }
    return new Uint8Array();
  }
  /**
   * Create a nameless, temporary Queue.
   * You will need to call `closeEphemeral()` to delete the Queue.
   */
  static async ephemeral(options = {}) {
    const resp = await client.queueGetOrCreate({
      objectCreationType: 5 /* OBJECT_CREATION_TYPE_EPHEMERAL */,
      environmentName: environmentName(options.environment)
    });
    const ephemeralHbManager = new EphemeralHeartbeatManager(
      () => client.queueHeartbeat({ queueId: resp.queueId })
    );
    return new _Queue(resp.queueId, void 0, ephemeralHbManager);
  }
  /** Delete the ephemeral Queue. Only usable with `Queue.ephemeral()`. */
  closeEphemeral() {
    if (this.#ephemeralHbManager) {
      this.#ephemeralHbManager.stop();
    } else {
      throw new InvalidError("Queue is not ephemeral.");
    }
  }
  /**
   * Lookup a Queue by name.
   */
  static async lookup(name, options = {}) {
    const resp = await client.queueGetOrCreate({
      deploymentName: name,
      objectCreationType: options.createIfMissing ? 1 /* OBJECT_CREATION_TYPE_CREATE_IF_MISSING */ : void 0,
      environmentName: environmentName(options.environment)
    });
    return new _Queue(resp.queueId, name);
  }
  /** Delete a Queue by name. */
  static async delete(name, options = {}) {
    const queue = await _Queue.lookup(name, options);
    await client.queueDelete({ queueId: queue.queueId });
  }
  /**
   * Remove all objects from a Queue partition.
   */
  async clear(options = {}) {
    if (options.partition && options.all) {
      throw new InvalidError(
        "Partition must be null when requesting to clear all."
      );
    }
    await client.queueClear({
      queueId: this.queueId,
      partitionKey: _Queue.#validatePartitionKey(options.partition),
      allPartitions: options.all
    });
  }
  async #get(n, partition, timeout) {
    const partitionKey = _Queue.#validatePartitionKey(partition);
    const startTime = Date.now();
    let pollTimeout = 5e4;
    if (timeout !== void 0) {
      pollTimeout = Math.min(pollTimeout, timeout);
    }
    while (true) {
      const response = await client.queueGet({
        queueId: this.queueId,
        partitionKey,
        timeout: pollTimeout / 1e3,
        nValues: n
      });
      if (response.values && response.values.length > 0) {
        return response.values.map((value) => loads(value));
      }
      if (timeout !== void 0) {
        const remaining = timeout - (Date.now() - startTime);
        if (remaining <= 0) {
          const message = `Queue ${this.queueId} did not return values within ${timeout}ms.`;
          throw new QueueEmptyError(message);
        }
        pollTimeout = Math.min(pollTimeout, remaining);
      }
    }
  }
  /**
   * Remove and return the next object from the Queue.
   *
   * By default, this will wait until at least one item is present in the Queue.
   * If `timeout` is set, raises `QueueEmptyError` if no items are available
   * within that timeout in milliseconds.
   */
  async get(options = {}) {
    const values = await this.#get(1, options.partition, options.timeout);
    return values[0];
  }
  /**
   * Remove and return up to `n` objects from the Queue.
   *
   * By default, this will wait until at least one item is present in the Queue.
   * If `timeout` is set, raises `QueueEmptyError` if no items are available
   * within that timeout in milliseconds.
   */
  async getMany(n, options = {}) {
    return await this.#get(n, options.partition, options.timeout);
  }
  async #put(values, timeout, partition, partitionTtl) {
    const valuesEncoded = values.map((v) => dumps(v));
    const partitionKey = _Queue.#validatePartitionKey(partition);
    let delay = queueInitialPutBackoff;
    const deadline = timeout ? Date.now() + timeout : void 0;
    while (true) {
      try {
        await client.queuePut({
          queueId: this.queueId,
          values: valuesEncoded,
          partitionKey,
          partitionTtlSeconds: (partitionTtl || queueDefaultPartitionTtl) / 1e3
        });
        break;
      } catch (e) {
        if (e instanceof ClientError8 && e.code === Status8.RESOURCE_EXHAUSTED) {
          delay = Math.min(delay * 2, 3e4);
          if (deadline !== void 0) {
            const remaining = deadline - Date.now();
            if (remaining <= 0)
              throw new QueueFullError(`Put failed on ${this.queueId}.`);
            delay = Math.min(delay, remaining);
          }
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          throw e;
        }
      }
    }
  }
  /**
   * Add an item to the end of the Queue.
   *
   * If the Queue is full, this will retry with exponential backoff until the
   * provided `timeout` is reached, or indefinitely if `timeout` is not set.
   * Raises `QueueFullError` if the Queue is still full after the timeout.
   */
  async put(v, options = {}) {
    await this.#put(
      [v],
      options.timeout,
      options.partition,
      options.partitionTtl
    );
  }
  /**
   * Add several items to the end of the Queue.
   *
   * If the Queue is full, this will retry with exponential backoff until the
   * provided `timeout` is reached, or indefinitely if `timeout` is not set.
   * Raises `QueueFullError` if the Queue is still full after the timeout.
   */
  async putMany(values, options = {}) {
    await this.#put(
      values,
      options.timeout,
      options.partition,
      options.partitionTtl
    );
  }
  /** Return the number of objects in the Queue. */
  async len(options = {}) {
    if (options.partition && options.total) {
      throw new InvalidError(
        "Partition must be null when requesting total length."
      );
    }
    const resp = await client.queueLen({
      queueId: this.queueId,
      partitionKey: _Queue.#validatePartitionKey(options.partition),
      total: options.total
    });
    return resp.len;
  }
  /** Iterate through items in a Queue without mutation. */
  async *iterate(options = {}) {
    const { partition, itemPollTimeout = 0 } = options;
    let lastEntryId = void 0;
    const validatedPartitionKey = _Queue.#validatePartitionKey(partition);
    let fetchDeadline = Date.now() + itemPollTimeout;
    const maxPollDuration = 3e4;
    while (true) {
      const pollDuration = Math.max(
        0,
        Math.min(maxPollDuration, fetchDeadline - Date.now())
      );
      const request = {
        queueId: this.queueId,
        partitionKey: validatedPartitionKey,
        itemPollTimeout: pollDuration / 1e3,
        lastEntryId: lastEntryId || ""
      };
      const response = await client.queueNextItems(request);
      if (response.items && response.items.length > 0) {
        for (const item of response.items) {
          yield loads(item.value);
          lastEntryId = item.entryId;
        }
        fetchDeadline = Date.now() + itemPollTimeout;
      } else if (Date.now() > fetchDeadline) {
        break;
      }
    }
  }
};

// src/volume.ts
import { ClientError as ClientError9, Status as Status9 } from "nice-grpc";
var Volume = class _Volume {
  volumeId;
  name;
  _readOnly = false;
  #ephemeralHbManager;
  /** @ignore */
  constructor(volumeId, name, readOnly = false, ephemeralHbManager) {
    this.volumeId = volumeId;
    this.name = name;
    this._readOnly = readOnly;
    this.#ephemeralHbManager = ephemeralHbManager;
  }
  static async fromName(name, options) {
    try {
      const resp = await client.volumeGetOrCreate({
        deploymentName: name,
        environmentName: environmentName(options?.environment),
        objectCreationType: options?.createIfMissing ? 1 /* OBJECT_CREATION_TYPE_CREATE_IF_MISSING */ : 0 /* OBJECT_CREATION_TYPE_UNSPECIFIED */
      });
      return new _Volume(resp.volumeId, name);
    } catch (err) {
      if (err instanceof ClientError9 && err.code === Status9.NOT_FOUND)
        throw new NotFoundError(err.details);
      throw err;
    }
  }
  /** Configure Volume to mount as read-only. */
  readOnly() {
    return new _Volume(this.volumeId, this.name, true, this.#ephemeralHbManager);
  }
  get isReadOnly() {
    return this._readOnly;
  }
  /**
   * Create a nameless, temporary Volume.
   * You will need to call `closeEphemeral()` to delete the Volume.
   */
  static async ephemeral(options = {}) {
    const resp = await client.volumeGetOrCreate({
      objectCreationType: 5 /* OBJECT_CREATION_TYPE_EPHEMERAL */,
      environmentName: environmentName(options.environment)
    });
    const ephemeralHbManager = new EphemeralHeartbeatManager(
      () => client.volumeHeartbeat({ volumeId: resp.volumeId })
    );
    return new _Volume(resp.volumeId, void 0, false, ephemeralHbManager);
  }
  /** Delete the ephemeral Volume. Only usable with `Volume.ephemeral()`. */
  closeEphemeral() {
    if (this.#ephemeralHbManager) {
      this.#ephemeralHbManager.stop();
    } else {
      throw new InvalidError("Volume is not ephemeral.");
    }
  }
};

// src/proxy.ts
import { ClientError as ClientError10, Status as Status10 } from "nice-grpc";
var Proxy2 = class _Proxy {
  proxyId;
  /** @ignore */
  constructor(proxyId) {
    this.proxyId = proxyId;
  }
  /** Reference a Proxy by its name. */
  static async fromName(name, options) {
    try {
      const resp = await client.proxyGet({
        name,
        environmentName: environmentName(options?.environment)
      });
      if (!resp.proxy?.proxyId) {
        throw new NotFoundError(`Proxy '${name}' not found`);
      }
      return new _Proxy(resp.proxy.proxyId);
    } catch (err) {
      if (err instanceof ClientError10 && err.code === Status10.NOT_FOUND)
        throw new NotFoundError(`Proxy '${name}' not found`);
      throw err;
    }
  }
};
export {
  AlreadyExistsError,
  App2 as App,
  CloudBucketMount2 as CloudBucketMount,
  Cls,
  ClsInstance,
  ContainerProcess,
  FunctionCall,
  FunctionTimeoutError,
  Function_,
  Image2 as Image,
  InternalFailure,
  InvalidError,
  NotFoundError,
  Proxy2 as Proxy,
  Queue,
  QueueEmptyError,
  QueueFullError,
  RemoteError,
  Retries,
  Sandbox2 as Sandbox,
  SandboxFile,
  SandboxTimeoutError,
  Secret,
  Volume,
  initializeClient
};
